---
title: Введение в Node.js
description: Node.js - это открытая,跨 платформенная среда выполнения JavaScript, позволяющая разработчикам выполнять JavaScript на стороне сервера, обеспечивая высокую производительность и масштабируемость.
head:
  - - meta
    - name: og:title
      content: Введение в Node.js | Node.js - iDoc.dev
  - - meta
    - name: og:description
      content: Node.js - это открытая,跨 платформенная среда выполнения JavaScript, позволяющая разработчикам выполнять JavaScript на стороне сервера, обеспечивая высокую производительность и масштабируемость.
  - - meta
    - name: twitter:title
      content: Введение в Node.js | Node.js - iDoc.dev
  - - meta
    - name: twitter:description
      content: Node.js - это открытая,跨 платформенная среда выполнения JavaScript, позволяющая разработчикам выполнять JavaScript на стороне сервера, обеспечивая высокую производительность и масштабируемость.
---


# Введение в Node.js

Node.js - это кроссплатформенная среда выполнения JavaScript с открытым исходным кодом. Это популярный инструмент практически для любого типа проекта!

Node.js запускает движок V8 JavaScript, ядро Google Chrome, вне браузера. Это позволяет Node.js быть очень производительным.

Приложение Node.js запускается в одном процессе, не создавая новый поток для каждого запроса. Node.js предоставляет набор асинхронных примитивов ввода-вывода в своей стандартной библиотеке, которые предотвращают блокировку кода JavaScript, и, как правило, библиотеки в Node.js написаны с использованием неблокирующих парадигм, что делает блокирующее поведение исключением, а не нормой.

Когда Node.js выполняет операцию ввода-вывода, например чтение из сети, доступ к базе данных или файловой системе, вместо блокировки потока и траты циклов ЦП в ожидании, Node.js возобновит операции, когда вернется ответ.

Это позволяет Node.js обрабатывать тысячи одновременных соединений с одним сервером, не вводя бремя управления параллелизмом потоков, что может быть значительным источником ошибок.

Node.js имеет уникальное преимущество, поскольку миллионы frontend-разработчиков, пишущих JavaScript для браузера, теперь могут писать код на стороне сервера в дополнение к коду на стороне клиента без необходимости изучать совершенно другой язык.

В Node.js новые стандарты ECMAScript можно использовать без проблем, поскольку вам не нужно ждать, пока все ваши пользователи обновят свои браузеры - вы сами решаете, какую версию ECMAScript использовать, изменив версию Node.js, и вы также можете включить определенные экспериментальные функции, запустив Node.js с флагами.

## Пример приложения Node.js

Самый распространенный пример "Hello World" в Node.js - это веб-сервер:

```js
import { createServer } from 'node:http'
const hostname = '127.0.0.1'
const port = 3000
const server = createServer((req, res) => {
  res.statusCode = 200
  res.setHeader('Content-Type', 'text/plain')
  res.end('Hello World')
})
server.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}/`)
})
```

Чтобы запустить этот фрагмент, сохраните его как файл `server.js` и запустите `node server.js` в своем терминале. Если вы используете mjs-версию кода, вам следует сохранить ее как файл `server.mjs` и запустить `node server.mjs` в своем терминале.

Этот код сначала включает [модуль http](/ru/nodejs/api/http) Node.js.

Node.js имеет фантастическую [стандартную библиотеку](/ru/nodejs/api/synopsis), включая первоклассную поддержку сети.

Метод `createServer()` из `http` создает новый HTTP-сервер и возвращает его.

Сервер настроен на прослушивание указанного порта и имени хоста. Когда сервер готов, вызывается функция обратного вызова, в данном случае информирующая нас о том, что сервер запущен.

Всякий раз, когда получается новый запрос, вызывается [событие request](/ru/nodejs/api/http), предоставляя два объекта: запрос (объект `http.IncomingMessage`) и ответ (объект `http.ServerResponse`).

Эти 2 объекта необходимы для обработки HTTP-вызова.

Первый предоставляет детали запроса. В этом простом примере он не используется, но вы можете получить доступ к заголовкам запроса и данным запроса.

Второй используется для возврата данных вызывающему объекту.

В этом случае с:

```js
res.setHeader('Content-Type', 'text/plain')
```

мы устанавливаем свойство statusCode в 200, чтобы указать на успешный ответ.

Мы устанавливаем заголовок Content-Type:

```js
res.setHeader('Content-Type', 'text/plain')
```

и мы закрываем ответ, добавляя содержимое в качестве аргумента к `end()`:

```js
res.end('Hello World')
```

Это отправит ответ клиенту.

