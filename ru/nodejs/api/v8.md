---
title: Документация модуля v8 в Node.js
description: Модуль v8 в Node.js предоставляет API для взаимодействия с движком JavaScript V8, включая сериализацию, десериализацию и управление памятью.
head:
  - - meta
    - name: og:title
      content: Документация модуля v8 в Node.js | Node.js - iDoc.dev
  - - meta
    - name: og:description
      content: Модуль v8 в Node.js предоставляет API для взаимодействия с движком JavaScript V8, включая сериализацию, десериализацию и управление памятью.
  - - meta
    - name: twitter:title
      content: Документация модуля v8 в Node.js | Node.js - iDoc.dev
  - - meta
    - name: twitter:description
      content: Модуль v8 в Node.js предоставляет API для взаимодействия с движком JavaScript V8, включая сериализацию, десериализацию и управление памятью.
---


# V8 {#v8}

**Исходный код:** [lib/v8.js](https://github.com/nodejs/node/blob/v23.5.0/lib/v8.js)

Модуль `node:v8` предоставляет API, специфичные для версии [V8](https://developers.google.com/v8/), встроенной в бинарный файл Node.js. Доступ к нему можно получить с помощью:

```js [ESM]
const v8 = require('node:v8');
```

## `v8.cachedDataVersionTag()` {#v8cacheddataversiontag}

**Добавлено в: v8.0.0**

- Возвращает: [\<integer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

Возвращает целое число, представляющее тег версии, полученный из версии V8, флагов командной строки и обнаруженных функций ЦП. Это полезно для определения того, совместим ли буфер `cachedData` [`vm.Script`](/ru/nodejs/api/vm#new-vmscriptcode-options) с этим экземпляром V8.

```js [ESM]
console.log(v8.cachedDataVersionTag()); // 3947234607
// Значение, возвращаемое v8.cachedDataVersionTag(), выводится из версии V8,
// флагов командной строки и обнаруженных функций ЦП. Проверьте, действительно ли значение
// обновляется при переключении флагов.
v8.setFlagsFromString('--allow_natives_syntax');
console.log(v8.cachedDataVersionTag()); // 183726201
```

## `v8.getHeapCodeStatistics()` {#v8getheapcodestatistics}

**Добавлено в: v12.8.0**

- Возвращает: [\<Object\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

Получает статистику о коде и его метаданных в куче, см. V8 API [`GetHeapCodeAndMetadataStatistics`](https://v8docs.nodesource.com/node-13.2/d5/dda/classv8_1_1_isolate#a6079122af17612ef54ef3348ce170866). Возвращает объект со следующими свойствами:

- `code_and_metadata_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `bytecode_and_metadata_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `external_script_source_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `cpu_profiler_metadata_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

```js [ESM]
{
  code_and_metadata_size: 212208,
  bytecode_and_metadata_size: 161368,
  external_script_source_size: 1410794,
  cpu_profiler_metadata_size: 0,
}
```

## `v8.getHeapSnapshot([options])` {#v8getheapsnapshotoptions}

::: info [История изменений]
| Версия | Изменения |
| --- | --- |
| v19.1.0 | Поддержка опций для настройки снапшота кучи. |
| v11.13.0 | Добавлено в: v11.13.0 |
:::

-  `options` [\<Object\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    - `exposeInternals` [\<boolean\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) Если true, предоставляет внутренние компоненты в снапшоте кучи. **По умолчанию:** `false`.
    - `exposeNumericValues` [\<boolean\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) Если true, предоставляет числовые значения в искусственных полях. **По умолчанию:** `false`.
  
 
-  Возвращает: [\<stream.Readable\>](/ru/nodejs/api/stream#class-streamreadable) Readable-поток, содержащий снапшот кучи V8.

Создаёт снапшот текущей кучи V8 и возвращает Readable-поток, который можно использовать для чтения JSON-сериализованного представления. Этот формат JSON-потока предназначен для использования с такими инструментами, как Chrome DevTools. JSON-схема не документирована и специфична для движка V8. Следовательно, схема может изменяться от одной версии V8 к другой.

Создание снапшота кучи требует памяти примерно в два раза больше, чем размер кучи на момент создания снапшота. Это приводит к риску завершения процесса OOM killer'ом.

Создание снапшота - это синхронная операция, которая блокирует цикл событий на время, зависящее от размера кучи.

```js [ESM]
// Вывод снапшота кучи в консоль
const v8 = require('node:v8');
const stream = v8.getHeapSnapshot();
stream.pipe(process.stdout);
```
## `v8.getHeapSpaceStatistics()` {#v8getheapspacestatistics}

::: info [История изменений]
| Версия | Изменения |
| --- | --- |
| v7.5.0 | Поддержка значений, превышающих диапазон 32-битного целого числа без знака. |
| v6.0.0 | Добавлено в: v6.0.0 |
:::

- Возвращает: [\<Object[]\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

Возвращает статистику о пространствах кучи V8, то есть о сегментах, составляющих кучу V8. Ни порядок пространств кучи, ни доступность пространства кучи не могут быть гарантированы, поскольку статистика предоставляется через функцию V8 [`GetHeapSpaceStatistics`](https://v8docs.nodesource.com/node-13.2/d5/dda/classv8_1_1_isolate#ac673576f24fdc7a33378f8f57e1d13a4) и может изменяться от одной версии V8 к другой.

Возвращаемое значение - это массив объектов, содержащих следующие свойства:

- `space_name` [\<string\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
- `space_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `space_used_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `space_available_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `physical_space_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

```json [JSON]
[
  {
    "space_name": "new_space",
    "space_size": 2063872,
    "space_used_size": 951112,
    "space_available_size": 80824,
    "physical_space_size": 2063872
  },
  {
    "space_name": "old_space",
    "space_size": 3090560,
    "space_used_size": 2493792,
    "space_available_size": 0,
    "physical_space_size": 3090560
  },
  {
    "space_name": "code_space",
    "space_size": 1260160,
    "space_used_size": 644256,
    "space_available_size": 960,
    "physical_space_size": 1260160
  },
  {
    "space_name": "map_space",
    "space_size": 1094160,
    "space_used_size": 201608,
    "space_available_size": 0,
    "physical_space_size": 1094160
  },
  {
    "space_name": "large_object_space",
    "space_size": 0,
    "space_used_size": 0,
    "space_available_size": 1490980608,
    "physical_space_size": 0
  }
]
```

## `v8.getHeapStatistics()` {#v8getheapstatistics}

::: info [История]
| Версия | Изменения |
| --- | --- |
| v7.5.0 | Поддержка значений, превышающих диапазон 32-битного целого числа без знака. |
| v7.2.0 | Добавлены `malloced_memory`, `peak_malloced_memory` и `does_zap_garbage`. |
| v1.0.0 | Добавлено в: v1.0.0 |
:::

- Возвращает: [\<Object\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

Возвращает объект со следующими свойствами:

- `total_heap_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `total_heap_size_executable` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `total_physical_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `total_available_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `used_heap_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `heap_size_limit` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `malloced_memory` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `peak_malloced_memory` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `does_zap_garbage` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `number_of_native_contexts` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `number_of_detached_contexts` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `total_global_handles_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `used_global_handles_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `external_memory` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

`total_heap_size` Значение `total_heap_size` - это количество байтов, выделенных V8 для кучи. Это значение может увеличиваться, если `used_heap` требуется больше памяти.

`total_heap_size_executable` Значение `total_heap_size_executable` - это часть кучи, которая может содержать исполняемый код, в байтах. Это включает память, используемую JIT-скомпилированным кодом, и любую память, которая должна оставаться исполняемой.

`total_physical_size` Значение `total_physical_size` - это фактическая физическая память, используемая кучей V8, в байтах. Это объем зафиксированной (или используемой) памяти, а не зарезервированной.

`total_available_size` Значение `total_available_size` - это количество байтов памяти, доступной для кучи V8. Это значение показывает, сколько еще памяти может использовать V8, прежде чем превысит предел кучи.

`used_heap_size` Значение `used_heap_size` - это количество байтов, используемых в настоящее время JavaScript-объектами V8. Это фактическая используемая память и не включает память, которая была выделена, но еще не использована.

`heap_size_limit` Значение `heap_size_limit` - это максимальный размер кучи V8 в байтах (либо предел по умолчанию, определяемый системными ресурсами, либо значение, переданное параметру `--max_old_space_size`).

`malloced_memory` Значение `malloced_memory` - это количество байтов, выделенных V8 через `malloc`.

`peak_malloced_memory` Значение `peak_malloced_memory` - это пиковое количество байтов, выделенных V8 через `malloc` за время существования процесса.

`does_zap_garbage` - это логическое значение 0/1, которое указывает, включен или нет параметр `--zap_code_space`. Это заставляет V8 перезаписывать мусор в куче битовым шаблоном. След RSS (resident set size) становится больше, потому что он постоянно касается всех страниц кучи, и это снижает вероятность их выгрузки операционной системой.

`number_of_native_contexts` Значение `number_of_native_contexts` - это количество активных в настоящее время контекстов верхнего уровня. Увеличение этого числа с течением времени указывает на утечку памяти.

`number_of_detached_contexts` Значение `number_of_detached_contexts` - это количество контекстов, которые были отсоединены и еще не собраны сборщиком мусора. Ненулевое значение этого числа указывает на потенциальную утечку памяти.

`total_global_handles_size` Значение `total_global_handles_size` - это общий размер памяти глобальных дескрипторов V8.

`used_global_handles_size` Значение `used_global_handles_size` - это используемый размер памяти глобальных дескрипторов V8.

`external_memory` Значение `external_memory` - это размер памяти буферов массивов и внешних строк.

```js [ESM]
{
  total_heap_size: 7326976,
  total_heap_size_executable: 4194304,
  total_physical_size: 7326976,
  total_available_size: 1152656,
  used_heap_size: 3476208,
  heap_size_limit: 1535115264,
  malloced_memory: 16384,
  peak_malloced_memory: 1127496,
  does_zap_garbage: 0,
  number_of_native_contexts: 1,
  number_of_detached_contexts: 0,
  total_global_handles_size: 8192,
  used_global_handles_size: 3296,
  external_memory: 318824
}
```

## `v8.queryObjects(ctor[, options])` {#v8queryobjectsctor-options}

**Добавлено в: v22.0.0, v20.13.0**

::: warning [Stable: 1 - Experimental]
[Stable: 1](/ru/nodejs/api/documentation#stability-index) [Stability: 1](/ru/nodejs/api/documentation#stability-index).1 - Активная разработка
:::

- `ctor` [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Конструктор, который может быть использован для поиска в цепочке прототипов с целью фильтрации целевых объектов в куче.
- `options` [\<undefined\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type) | [\<Object\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    - `format` [\<string\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) Если это `'count'`, возвращается количество найденных объектов. Если это `'summary'`, возвращается массив со строками, содержащими краткое описание найденных объектов.

- Возвращает: {number|Array

Это аналогично [`queryObjects()` API консоли](https://developer.chrome.com/docs/devtools/console/utilities#queryObjects-function), предоставляемому консолью Chromium DevTools. Его можно использовать для поиска объектов, имеющих соответствующий конструктор в своей цепочке прототипов в куче после полной сборки мусора, что может быть полезно для регрессионных тестов на утечки памяти. Чтобы избежать неожиданных результатов, пользователям следует избегать использования этого API для конструкторов, реализацию которых они не контролируют, или для конструкторов, которые могут быть вызваны другими сторонами в приложении.

Чтобы избежать случайных утечек, этот API не возвращает необработанные ссылки на найденные объекты. По умолчанию он возвращает количество найденных объектов. Если `options.format` равно `'summary'`, он возвращает массив, содержащий краткие строковые представления для каждого объекта. Видимость, предоставляемая в этом API, аналогична той, которую предоставляет снимок кучи, в то время как пользователи могут сэкономить на сериализации и анализе и напрямую фильтровать целевые объекты во время поиска.

В результаты включаются только объекты, созданные в текущем контексте выполнения.

::: code-group
```js [CJS]
const { queryObjects } = require('node:v8');
class A { foo = 'bar'; }
console.log(queryObjects(A)); // 0
const a = new A();
console.log(queryObjects(A)); // 1
// [ "A { foo: 'bar' }" ]
console.log(queryObjects(A, { format: 'summary' }));

class B extends A { bar = 'qux'; }
const b = new B();
console.log(queryObjects(B)); // 1
// [ "B { foo: 'bar', bar: 'qux' }" ]
console.log(queryObjects(B, { format: 'summary' }));

// Note that, when there are child classes inheriting from a constructor,
// the constructor also shows up in the prototype chain of the child
// classes's prototype, so the child classes's prototype would also be
// included in the result.
console.log(queryObjects(A));  // 3
// [ "B { foo: 'bar', bar: 'qux' }", 'A {}', "A { foo: 'bar' }" ]
console.log(queryObjects(A, { format: 'summary' }));
```

```js [ESM]
import { queryObjects } from 'node:v8';
class A { foo = 'bar'; }
console.log(queryObjects(A)); // 0
const a = new A();
console.log(queryObjects(A)); // 1
// [ "A { foo: 'bar' }" ]
console.log(queryObjects(A, { format: 'summary' }));

class B extends A { bar = 'qux'; }
const b = new B();
console.log(queryObjects(B)); // 1
// [ "B { foo: 'bar', bar: 'qux' }" ]
console.log(queryObjects(B, { format: 'summary' }));

// Note that, when there are child classes inheriting from a constructor,
// the constructor also shows up in the prototype chain of the child
// classes's prototype, so the child classes's prototype would also be
// included in the result.
console.log(queryObjects(A));  // 3
// [ "B { foo: 'bar', bar: 'qux' }", 'A {}', "A { foo: 'bar' }" ]
console.log(queryObjects(A, { format: 'summary' }));
```
:::


## `v8.setFlagsFromString(flags)` {#v8setflagsfromstringflags}

**Добавлено в версии: v1.0.0**

- `flags` [\<string\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

Метод `v8.setFlagsFromString()` можно использовать для программной установки флагов командной строки V8. Этот метод следует использовать с осторожностью. Изменение настроек после запуска VM может привести к непредсказуемому поведению, включая сбои и потерю данных; или это может просто ничего не дать.

Параметры V8, доступные для версии Node.js, можно определить, запустив `node --v8-options`.

Использование:

```js [ESM]
// Печатать события GC в stdout в течение одной минуты.
const v8 = require('node:v8');
v8.setFlagsFromString('--trace_gc');
setTimeout(() => { v8.setFlagsFromString('--notrace_gc'); }, 60e3);
```
## `v8.stopCoverage()` {#v8stopcoverage}

**Добавлено в версии: v15.1.0, v14.18.0, v12.22.0**

Метод `v8.stopCoverage()` позволяет пользователю остановить сбор покрытия, запущенный с помощью [`NODE_V8_COVERAGE`](/ru/nodejs/api/cli#node_v8_coveragedir), чтобы V8 могла освободить записи количества выполненных операций и оптимизировать код. Это можно использовать в сочетании с [`v8.takeCoverage()`](/ru/nodejs/api/v8#v8takecoverage), если пользователь хочет собрать покрытие по требованию.

## `v8.takeCoverage()` {#v8takecoverage}

**Добавлено в версии: v15.1.0, v14.18.0, v12.22.0**

Метод `v8.takeCoverage()` позволяет пользователю записывать покрытие, запущенное с помощью [`NODE_V8_COVERAGE`](/ru/nodejs/api/cli#node_v8_coveragedir), на диск по требованию. Этот метод можно вызывать несколько раз в течение жизненного цикла процесса. Каждый раз счетчик выполнения будет сбрасываться, и новый отчет о покрытии будет записываться в каталог, указанный в [`NODE_V8_COVERAGE`](/ru/nodejs/api/cli#node_v8_coveragedir).

Когда процесс собирается завершиться, последнее покрытие все равно будет записано на диск, если [`v8.stopCoverage()`](/ru/nodejs/api/v8#v8stopcoverage) не будет вызван до завершения процесса.

## `v8.writeHeapSnapshot([filename[,options]])` {#v8writeheapsnapshotfilenameoptions}


::: info [История]
| Версия | Изменения |
| --- | --- |
| v19.1.0 | Поддержка параметров для настройки снимка кучи. |
| v18.0.0 | Теперь будет выброшено исключение, если файл не может быть записан. |
| v18.0.0 | Сделать возвращаемые коды ошибок согласованными на всех платформах. |
| v11.13.0 | Добавлено в версии: v11.13.0 |
:::

- `filename` [\<string\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) Путь к файлу, в котором должен быть сохранен снимок кучи V8. Если не указан, будет сгенерировано имя файла с шаблоном `'Heap-${yyyymmdd}-${hhmmss}-${pid}-${thread_id}.heapsnapshot'`, где `{pid}` будет PID процесса Node.js, `{thread_id}` будет `0`, когда `writeHeapSnapshot()` вызывается из основного потока Node.js, или идентификатор рабочего потока.
- `options` [\<Object\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    - `exposeInternals` [\<boolean\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) Если true, раскрывать внутренние данные в снимке кучи. **По умолчанию:** `false`.
    - `exposeNumericValues` [\<boolean\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) Если true, раскрывать числовые значения в искусственных полях. **По умолчанию:** `false`.
  
 
- Возвращает: [\<string\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) Имя файла, в котором был сохранен снимок.

Создает снимок текущей кучи V8 и записывает его в файл JSON. Этот файл предназначен для использования с такими инструментами, как Chrome DevTools. Схема JSON не документирована и специфична для движка V8 и может изменяться от одной версии V8 к другой.

Снимок кучи специфичен для одного изолированного экземпляра V8. При использовании [рабочих потоков](/ru/nodejs/api/worker_threads) снимок кучи, сгенерированный из основного потока, не будет содержать никакой информации о рабочих потоках, и наоборот.

Создание снимка кучи требует памяти примерно вдвое больше размера кучи на момент создания снимка. Это приводит к риску завершения процесса с помощью OOM killer.

Создание снимка - это синхронная операция, которая блокирует цикл событий на время, зависящее от размера кучи.

```js [ESM]
const { writeHeapSnapshot } = require('node:v8');
const {
  Worker,
  isMainThread,
  parentPort,
} = require('node:worker_threads');

if (isMainThread) {
  const worker = new Worker(__filename);

  worker.once('message', (filename) => {
    console.log(`worker heapdump: ${filename}`);
    // Теперь получим дамп кучи для основного потока.
    console.log(`main thread heapdump: ${writeHeapSnapshot()}`);
  });

  // Сообщаем рабочему потоку о создании дампа кучи.
  worker.postMessage('heapdump');
} else {
  parentPort.once('message', (message) => {
    if (message === 'heapdump') {
      // Генерируем дамп кучи для рабочего потока
      // и возвращаем имя файла родительскому процессу.
      parentPort.postMessage(writeHeapSnapshot());
    }
  });
}
```

## `v8.setHeapSnapshotNearHeapLimit(limit)` {#v8setheapsnapshotnearheaplimitlimit}

**Добавлено в: v18.10.0, v16.18.0**

::: warning [Stable: 1 - Experimental]
[Stable: 1](/ru/nodejs/api/documentation#stability-index) [Stability: 1](/ru/nodejs/api/documentation#stability-index) - Экспериментально
:::

- `limit` [\<integer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

API не выполняет никаких действий, если `--heapsnapshot-near-heap-limit` уже установлен из командной строки или API вызывается более одного раза. `limit` должен быть положительным целым числом. Смотрите [`--heapsnapshot-near-heap-limit`](/ru/nodejs/api/cli#--heapsnapshot-near-heap-limitmax_count) для получения дополнительной информации.

## API сериализации {#serialization-api}

API сериализации предоставляет средства для сериализации значений JavaScript способом, совместимым с [алгоритмом структурированного клонирования HTML](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm).

Формат обратно совместим (то есть его безопасно хранить на диске). Равные значения JavaScript могут приводить к разным сериализованным выходным данным.

### `v8.serialize(value)` {#v8serializevalue}

**Добавлено в: v8.0.0**

- `value` [\<any\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)
- Возвращает: [\<Buffer\>](/ru/nodejs/api/buffer#class-buffer)

Использует [`DefaultSerializer`](/ru/nodejs/api/v8#class-v8defaultserializer) для сериализации `value` в буфер.

[`ERR_BUFFER_TOO_LARGE`](/ru/nodejs/api/errors#err_buffer_too_large) будет выброшено при попытке сериализовать огромный объект, требующий буфер больше, чем [`buffer.constants.MAX_LENGTH`](/ru/nodejs/api/buffer#bufferconstantsmax_length).

### `v8.deserialize(buffer)` {#v8deserializebuffer}

**Добавлено в: v8.0.0**

- `buffer` [\<Buffer\>](/ru/nodejs/api/buffer#class-buffer) | [\<TypedArray\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [\<DataView\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) Буфер, возвращенный [`serialize()`](/ru/nodejs/api/v8#v8serializevalue).

Использует [`DefaultDeserializer`](/ru/nodejs/api/v8#class-v8defaultdeserializer) с параметрами по умолчанию для чтения JS значения из буфера.


### Класс: `v8.Serializer` {#class-v8serializer}

**Добавлено в: v8.0.0**

#### `new Serializer()` {#new-serializer}

Создает новый объект `Serializer`.

#### `serializer.writeHeader()` {#serializerwriteheader}

Записывает заголовок, включающий версию формата сериализации.

#### `serializer.writeValue(value)` {#serializerwritevaluevalue}

- `value` [\<any\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)

Сериализует значение JavaScript и добавляет сериализованное представление во внутренний буфер.

Выбрасывает ошибку, если `value` не может быть сериализовано.

#### `serializer.releaseBuffer()` {#serializerreleasebuffer}

- Возвращает: [\<Buffer\>](/ru/nodejs/api/buffer#class-buffer)

Возвращает сохраненный внутренний буфер. Этот сериализатор не должен использоваться после освобождения буфера. Вызов этого метода приводит к неопределенному поведению, если предыдущая запись завершилась неудачей.

#### `serializer.transferArrayBuffer(id, arrayBuffer)` {#serializertransferarraybufferid-arraybuffer}

- `id` [\<integer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 32-битное целое число без знака.
- `arrayBuffer` [\<ArrayBuffer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) Экземпляр `ArrayBuffer`.

Помечает `ArrayBuffer` как имеющий содержимое, переданное внеполосным способом. Передайте соответствующий `ArrayBuffer` в контексте десериализации в [`deserializer.transferArrayBuffer()`](/ru/nodejs/api/v8#deserializertransferarraybufferid-arraybuffer).

#### `serializer.writeUint32(value)` {#serializerwriteuint32value}

- `value` [\<integer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

Записывает необработанное 32-битное целое число без знака. Для использования внутри пользовательского [`serializer._writeHostObject()`](/ru/nodejs/api/v8#serializer_writehostobjectobject).

#### `serializer.writeUint64(hi, lo)` {#serializerwriteuint64hi-lo}

- `hi` [\<integer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `lo` [\<integer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

Записывает необработанное 64-битное целое число без знака, разделенное на старшие и младшие 32-битные части. Для использования внутри пользовательского [`serializer._writeHostObject()`](/ru/nodejs/api/v8#serializer_writehostobjectobject).


#### `serializer.writeDouble(value)` {#serializerwritedoublevalue}

- `value` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

Записывает значение JS `number`. Используется внутри пользовательской функции [`serializer._writeHostObject()`](/ru/nodejs/api/v8#serializer_writehostobjectobject).

#### `serializer.writeRawBytes(buffer)` {#serializerwriterawbytesbuffer}

- `buffer` [\<Buffer\>](/ru/nodejs/api/buffer#class-buffer) | [\<TypedArray\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [\<DataView\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)

Записывает необработанные байты во внутренний буфер сериализатора. Десериализатору потребуется способ вычисления длины буфера. Используется внутри пользовательской функции [`serializer._writeHostObject()`](/ru/nodejs/api/v8#serializer_writehostobjectobject).

#### `serializer._writeHostObject(object)` {#serializer_writehostobjectobject}

- `object` [\<Object\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

Этот метод вызывается для записи какого-либо хост-объекта, т.е. объекта, созданного нативными C++ биндингами. Если невозможно сериализовать `object`, следует сгенерировать подходящее исключение.

Этот метод отсутствует в самом классе `Serializer`, но может быть предоставлен подклассами.

#### `serializer._getDataCloneError(message)` {#serializer_getdatacloneerrormessage}

- `message` [\<string\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

Этот метод вызывается для создания объектов ошибок, которые будут сгенерированы, когда объект не может быть клонирован.

По умолчанию этот метод использует конструктор [`Error`](/ru/nodejs/api/errors#class-error) и может быть переопределен в подклассах.

#### `serializer._getSharedArrayBufferId(sharedArrayBuffer)` {#serializer_getsharedarraybufferidsharedarraybuffer}

- `sharedArrayBuffer` [\<SharedArrayBuffer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer)

Этот метод вызывается, когда сериализатор собирается сериализовать объект `SharedArrayBuffer`. Он должен возвращать 32-битный целочисленный ID без знака для объекта, используя тот же ID, если этот `SharedArrayBuffer` уже был сериализован. При десериализации этот ID будет передан в [`deserializer.transferArrayBuffer()`](/ru/nodejs/api/v8#deserializertransferarraybufferid-arraybuffer).

Если объект не может быть сериализован, должно быть сгенерировано исключение.

Этот метод отсутствует в самом классе `Serializer`, но может быть предоставлен подклассами.


#### `serializer._setTreatArrayBufferViewsAsHostObjects(flag)` {#serializer_settreatarraybufferviewsashostobjectsflag}

- `flag` [\<boolean\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) **По умолчанию:** `false`

Указывает, следует ли рассматривать объекты `TypedArray` и `DataView` как хост-объекты, т.е. передавать их в [`serializer._writeHostObject()`](/ru/nodejs/api/v8#serializer_writehostobjectobject).

### Класс: `v8.Deserializer` {#class-v8deserializer}

**Добавлено в: v8.0.0**

#### `new Deserializer(buffer)` {#new-deserializerbuffer}

- `buffer` [\<Buffer\>](/ru/nodejs/api/buffer#class-buffer) | [\<TypedArray\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [\<DataView\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) Буфер, возвращенный [`serializer.releaseBuffer()`](/ru/nodejs/api/v8#serializerreleasebuffer).

Создает новый объект `Deserializer`.

#### `deserializer.readHeader()` {#deserializerreadheader}

Считывает и проверяет заголовок (включая версию формата). Может, например, отклонить недействительный или неподдерживаемый проводной формат. В этом случае выбрасывается `Error`.

#### `deserializer.readValue()` {#deserializerreadvalue}

Десериализует значение JavaScript из буфера и возвращает его.

#### `deserializer.transferArrayBuffer(id, arrayBuffer)` {#deserializertransferarraybufferid-arraybuffer}

- `id` [\<integer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 32-битное целое число без знака.
- `arrayBuffer` [\<ArrayBuffer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [\<SharedArrayBuffer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) Экземпляр `ArrayBuffer`.

Помечает `ArrayBuffer` как имеющий содержимое, переданное вне диапазона. Передайте соответствующий `ArrayBuffer` в контексте сериализации в [`serializer.transferArrayBuffer()`](/ru/nodejs/api/v8#serializertransferarraybufferid-arraybuffer) (или верните `id` из [`serializer._getSharedArrayBufferId()`](/ru/nodejs/api/v8#serializer_getsharedarraybufferidsharedarraybuffer) в случае `SharedArrayBuffer`s).


#### `deserializer.getWireFormatVersion()` {#deserializergetwireformatversion}

- Возвращает: [\<integer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

Считывает базовую версию формата передачи данных. Вероятно, в основном полезно для устаревшего кода, читающего старые версии формата передачи данных. Не может быть вызван до `.readHeader()`.

#### `deserializer.readUint32()` {#deserializerreaduint32}

- Возвращает: [\<integer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

Считывает необработанное 32-битное целое число без знака и возвращает его. Для использования внутри пользовательского [`deserializer._readHostObject()`](/ru/nodejs/api/v8#deserializer_readhostobject).

#### `deserializer.readUint64()` {#deserializerreaduint64}

- Возвращает: [\<integer[]\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

Считывает необработанное 64-битное целое число без знака и возвращает его в виде массива `[hi, lo]` с двумя 32-битными целыми числами без знака. Для использования внутри пользовательского [`deserializer._readHostObject()`](/ru/nodejs/api/v8#deserializer_readhostobject).

#### `deserializer.readDouble()` {#deserializerreaddouble}

- Возвращает: [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

Считывает значение JS `number`. Для использования внутри пользовательского [`deserializer._readHostObject()`](/ru/nodejs/api/v8#deserializer_readhostobject).

#### `deserializer.readRawBytes(length)` {#deserializerreadrawbyteslength}

- `length` [\<integer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- Возвращает: [\<Buffer\>](/ru/nodejs/api/buffer#class-buffer)

Считывает необработанные байты из внутреннего буфера десериализатора. Параметр `length` должен соответствовать длине буфера, который был передан в [`serializer.writeRawBytes()`](/ru/nodejs/api/v8#serializerwriterawbytesbuffer). Для использования внутри пользовательского [`deserializer._readHostObject()`](/ru/nodejs/api/v8#deserializer_readhostobject).

#### `deserializer._readHostObject()` {#deserializer_readhostobject}

Этот метод вызывается для чтения какого-либо хост-объекта, т.е. объекта, созданного собственными привязками C++. Если десериализовать данные невозможно, следует выбросить соответствующее исключение.

Этот метод отсутствует в самом классе `Deserializer`, но может быть предоставлен подклассами.


### Класс: `v8.DefaultSerializer` {#class-v8defaultserializer}

**Добавлено в: v8.0.0**

Подкласс [`Serializer`](/ru/nodejs/api/v8#class-v8serializer), который сериализует объекты `TypedArray` (в частности [`Buffer`](/ru/nodejs/api/buffer)) и `DataView` как хост-объекты и хранит только ту часть их базовых `ArrayBuffer`ов, на которую они ссылаются.

### Класс: `v8.DefaultDeserializer` {#class-v8defaultdeserializer}

**Добавлено в: v8.0.0**

Подкласс [`Deserializer`](/ru/nodejs/api/v8#class-v8deserializer), соответствующий формату, записанному [`DefaultSerializer`](/ru/nodejs/api/v8#class-v8defaultserializer).

## Хуки Promise {#promise-hooks}

Интерфейс `promiseHooks` можно использовать для отслеживания событий жизненного цикла promise. Чтобы отслеживать *всю* асинхронную активность, см. [`async_hooks`](/ru/nodejs/api/async_hooks), который внутренне использует этот модуль для создания событий жизненного цикла promise в дополнение к событиям для других асинхронных ресурсов. Для управления контекстом запросов см. [`AsyncLocalStorage`](/ru/nodejs/api/async_context#class-asynclocalstorage).

```js [ESM]
import { promiseHooks } from 'node:v8';

// Существует четыре события жизненного цикла, создаваемые promise:

// Событие `init` представляет собой создание promise. Это может быть
// прямое создание, например, с помощью `new Promise(...)`, или продолжение,
// например, `then()` или `catch()`. Это также происходит всякий раз, когда вызывается
// асинхронная функция или выполняет `await`. Если создается promise продолжения,
// `parent` будет promise, из которого он является продолжением.
function init(promise, parent) {
  console.log('promise был создан', { promise, parent });
}

// Событие `settled` происходит, когда promise получает значение разрешения или
// отклонения. Это может произойти синхронно, например, при использовании
// `Promise.resolve()` для ввода, не являющегося promise.
function settled(promise) {
  console.log('promise разрешен или отклонен', { promise });
}

// Событие `before` запускается непосредственно перед запуском обработчика `then()` или `catch()`
// или возобновлением выполнения `await`.
function before(promise) {
  console.log('promise собирается вызвать обработчик then', { promise });
}

// Событие `after` запускается непосредственно после запуска обработчика `then()` или когда
// начинается `await` после возобновления выполнения из другого.
function after(promise) {
  console.log('promise завершил вызов обработчика then', { promise });
}

// Хуки жизненного цикла могут запускаться и останавливаться индивидуально
const stopWatchingInits = promiseHooks.onInit(init);
const stopWatchingSettleds = promiseHooks.onSettled(settled);
const stopWatchingBefores = promiseHooks.onBefore(before);
const stopWatchingAfters = promiseHooks.onAfter(after);

// Или их можно запускать и останавливать группами
const stopHookSet = promiseHooks.createHook({
  init,
  settled,
  before,
  after,
});

// Чтобы остановить хук, вызовите функцию, возвращенную при его создании.
stopWatchingInits();
stopWatchingSettleds();
stopWatchingBefores();
stopWatchingAfters();
stopHookSet();
```

### `promiseHooks.onInit(init)` {#promisehooksoninitinit}

**Добавлено в: v17.1.0, v16.14.0**

- `init` [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) [`init` callback](/ru/nodejs/api/v8#initpromise-parent), который вызывается при создании промиса.
- Возвращает: [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Вызов для остановки хука.

**Хук <code>init</code> должен быть простой функцией. Предоставление асинхронной функции вызовет ошибку, так как это приведет к бесконечному циклу микрозадач.**

::: code-group
```js [ESM]
import { promiseHooks } from 'node:v8';

const stop = promiseHooks.onInit((promise, parent) => {});
```

```js [CJS]
const { promiseHooks } = require('node:v8');

const stop = promiseHooks.onInit((promise, parent) => {});
```
:::

### `promiseHooks.onSettled(settled)` {#promisehooksonsettledsettled}

**Добавлено в: v17.1.0, v16.14.0**

- `settled` [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) [`settled` callback](/ru/nodejs/api/v8#settledpromise), который вызывается, когда промис выполнен или отклонен.
- Возвращает: [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Вызов для остановки хука.

**Хук <code>settled</code> должен быть простой функцией. Предоставление асинхронной функции вызовет ошибку, так как это приведет к бесконечному циклу микрозадач.**

::: code-group
```js [ESM]
import { promiseHooks } from 'node:v8';

const stop = promiseHooks.onSettled((promise) => {});
```

```js [CJS]
const { promiseHooks } = require('node:v8');

const stop = promiseHooks.onSettled((promise) => {});
```
:::

### `promiseHooks.onBefore(before)` {#promisehooksonbeforebefore}

**Добавлено в: v17.1.0, v16.14.0**

- `before` [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) [`before` callback](/ru/nodejs/api/v8#beforepromise), который вызывается перед выполнением продолжения промиса.
- Возвращает: [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Вызов для остановки хука.

**Хук <code>before</code> должен быть простой функцией. Предоставление асинхронной функции вызовет ошибку, так как это приведет к бесконечному циклу микрозадач.**

::: code-group
```js [ESM]
import { promiseHooks } from 'node:v8';

const stop = promiseHooks.onBefore((promise) => {});
```

```js [CJS]
const { promiseHooks } = require('node:v8');

const stop = promiseHooks.onBefore((promise) => {});
```
:::


### `promiseHooks.onAfter(after)` {#promisehooksonafterafter}

**Добавлено в: v17.1.0, v16.14.0**

- `after` [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) [`after` callback](/ru/nodejs/api/v8#afterpromise), вызываемый после выполнения продолжения промиса.
- Возвращает: [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Вызов для остановки хука.

**Хук <code>after</code> должен быть обычной функцией. Использование асинхронной функции приведет к ошибке, поскольку это приведет к бесконечному циклу микрозадач.**

::: code-group
```js [ESM]
import { promiseHooks } from 'node:v8';

const stop = promiseHooks.onAfter((promise) => {});
```

```js [CJS]
const { promiseHooks } = require('node:v8');

const stop = promiseHooks.onAfter((promise) => {});
```
:::

### `promiseHooks.createHook(callbacks)` {#promisehookscreatehookcallbacks}

**Добавлено в: v17.1.0, v16.14.0**

- `callbacks` [\<Object\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) [Callback-функции для хуков](/ru/nodejs/api/v8#hook-callbacks) для регистрации
    - `init` [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) [`init` callback](/ru/nodejs/api/v8#initpromise-parent).
    - `before` [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) [`before` callback](/ru/nodejs/api/v8#beforepromise).
    - `after` [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) [`after` callback](/ru/nodejs/api/v8#afterpromise).
    - `settled` [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) [`settled` callback](/ru/nodejs/api/v8#settledpromise).
  
 
- Возвращает: [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Используется для отключения хуков

**Callback-функции для хуков должны быть обычными функциями. Использование асинхронных функций приведет к ошибке, поскольку это приведет к бесконечному циклу микрозадач.**

Регистрирует функции, которые будут вызываться для различных событий жизненного цикла каждого промиса.

Callback-функции `init()`/`before()`/`after()`/`settled()` вызываются для соответствующих событий в течение жизненного цикла промиса.

Все callback-функции необязательны. Например, если нужно отслеживать только создание промиса, то нужно передать только callback-функцию `init`. Подробности обо всех функциях, которые можно передать в `callbacks`, находятся в разделе [Callback-функции для хуков](/ru/nodejs/api/v8#hook-callbacks).

::: code-group
```js [ESM]
import { promiseHooks } from 'node:v8';

const stopAll = promiseHooks.createHook({
  init(promise, parent) {},
});
```

```js [CJS]
const { promiseHooks } = require('node:v8');

const stopAll = promiseHooks.createHook({
  init(promise, parent) {},
});
```
:::


### Хуки обратного вызова {#hook-callbacks}

Ключевые события в жизненном цикле промиса были категоризированы по четырём областям: создание промиса, до/после вызова обработчика продолжения или вокруг `await`, и когда промис разрешается или отклоняется.

Хотя эти хуки похожи на хуки [`async_hooks`](/ru/nodejs/api/async_hooks), у них отсутствует хук `destroy`. Другие типы асинхронных ресурсов обычно представляют собой сокеты или файловые дескрипторы, которые имеют отчетливое "закрытое" состояние для выражения события жизненного цикла `destroy`, в то время как промисы остаются пригодными для использования до тех пор, пока код может до них добраться. Отслеживание сборки мусора используется для того, чтобы подогнать промисы под модель событий `async_hooks`, однако это отслеживание очень дорогостоящее, и они могут даже никогда не быть собраны сборщиком мусора.

Поскольку промисы являются асинхронными ресурсами, жизненный цикл которых отслеживается с помощью механизма хуков промисов, обратные вызовы `init()`, `before()`, `after()` и `settled()` *не должны* быть асинхронными функциями, поскольку они создают больше промисов, что приведет к бесконечному циклу.

Хотя этот API используется для передачи событий промисов в [`async_hooks`](/ru/nodejs/api/async_hooks), порядок между ними не определен. Оба API являются мультиарендными и поэтому могут создавать события в любом порядке относительно друг друга.

#### `init(promise, parent)` {#initpromise-parent}

- `promise` [\<Promise\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) Создаваемый промис.
- `parent` [\<Promise\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) Промис, продолженный от, если применимо.

Вызывается при создании промиса. Это *не означает*, что произойдут соответствующие события `before`/`after`, только то, что такая возможность существует. Это произойдет, если промис создан без получения продолжения.

#### `before(promise)` {#beforepromise}

- `promise` [\<Promise\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)

Вызывается перед выполнением продолжения промиса. Это может быть в форме обработчиков `then()`, `catch()` или `finally()` или возобновления `await`.

Обратный вызов `before` будет вызываться от 0 до N раз. Обратный вызов `before` обычно вызывается 0 раз, если для промиса никогда не было создано продолжение. Обратный вызов `before` может быть вызван много раз в случае, когда из одного и того же промиса было сделано много продолжений.


#### `after(promise)` {#afterpromise}

- `promise` [\<Promise\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)

Вызывается сразу после выполнения продолжения промиса. Это может произойти после обработчика `then()`, `catch()` или `finally()` или перед `await` после другого `await`.

#### `settled(promise)` {#settledpromise}

- `promise` [\<Promise\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)

Вызывается, когда промис получает значение разрешения или отклонения. Это может произойти синхронно в случае `Promise.resolve()` или `Promise.reject()`.

## API Startup Snapshot {#startup-snapshot-api}

**Добавлено в: v18.6.0, v16.17.0**

::: warning [Stable: 1 - Experimental]
[Stable: 1](/ru/nodejs/api/documentation#stability-index) [Стабильность: 1](/ru/nodejs/api/documentation#stability-index) - Экспериментальный
:::

Интерфейс `v8.startupSnapshot` можно использовать для добавления хуков сериализации и десериализации для пользовательских снапшотов запуска.

```bash [BASH]
$ node --snapshot-blob snapshot.blob --build-snapshot entry.js
# Это запускает процесс со снапшотом {#this-launches-a-process-with-the-snapshot}
$ node --snapshot-blob snapshot.blob
```
В примере выше `entry.js` может использовать методы из интерфейса `v8.startupSnapshot`, чтобы указать, как сохранять информацию для пользовательских объектов в снапшоте во время сериализации и как эту информацию можно использовать для синхронизации этих объектов во время десериализации снапшота. Например, если `entry.js` содержит следующий скрипт:

```js [CJS]
'use strict';

const fs = require('node:fs');
const zlib = require('node:zlib');
const path = require('node:path');
const assert = require('node:assert');

const v8 = require('node:v8');

class BookShelf {
  storage = new Map();

  // Чтение серии файлов из каталога и сохранение их в хранилище.
  constructor(directory, books) {
    for (const book of books) {
      this.storage.set(book, fs.readFileSync(path.join(directory, book)));
    }
  }

  static compressAll(shelf) {
    for (const [ book, content ] of shelf.storage) {
      shelf.storage.set(book, zlib.gzipSync(content));
    }
  }

  static decompressAll(shelf) {
    for (const [ book, content ] of shelf.storage) {
      shelf.storage.set(book, zlib.gunzipSync(content));
    }
  }
}

// __dirname здесь - это место, где скрипт снапшота размещается
// во время построения снапшота.
const shelf = new BookShelf(__dirname, [
  'book1.en_US.txt',
  'book1.es_ES.txt',
  'book2.zh_CN.txt',
]);

assert(v8.startupSnapshot.isBuildingSnapshot());
// При сериализации снапшота сжимаем книги для уменьшения размера.
v8.startupSnapshot.addSerializeCallback(BookShelf.compressAll, shelf);
// При десериализации снапшота распаковываем книги.
v8.startupSnapshot.addDeserializeCallback(BookShelf.decompressAll, shelf);
v8.startupSnapshot.setDeserializeMainFunction((shelf) => {
  // process.env и process.argv обновляются во время снапшота
  // десериализации.
  const lang = process.env.BOOK_LANG || 'en_US';
  const book = process.argv[1];
  const name = `${book}.${lang}.txt`;
  console.log(shelf.storage.get(name));
}, shelf);
```
Полученный бинарник будет печатать данные, десериализованные из снапшота во время запуска, используя обновленные `process.env` и `process.argv` запущенного процесса:

```bash [BASH]
$ BOOK_LANG=es_ES node --snapshot-blob snapshot.blob book1
# Печатает содержимое book1.es_ES.txt, десериализованное из снапшота. {#prints-content-of-book1es_estxt-deserialized-from-the-snapshot}
```
В настоящее время приложение, десериализованное из пользовательского снапшота, не может быть повторно заснапшотено, поэтому эти API доступны только для приложений, которые не десериализованы из пользовательского снапшота.


### `v8.startupSnapshot.addSerializeCallback(callback[, data])` {#v8startupsnapshotaddserializecallbackcallback-data}

**Добавлено в: v18.6.0, v16.17.0**

- `callback` [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Callback, который будет вызван перед сериализацией.
- `data` [\<any\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) Необязательные данные, которые будут переданы в `callback` при его вызове.

Добавляет callback, который будет вызван, когда экземпляр Node.js собирается быть сериализованным в снимок и завершить работу. Это можно использовать для освобождения ресурсов, которые не должны или не могут быть сериализованы, или для преобразования пользовательских данных в форму, более подходящую для сериализации.

Callback-и выполняются в том порядке, в котором они были добавлены.

### `v8.startupSnapshot.addDeserializeCallback(callback[, data])` {#v8startupsnapshotadddeserializecallbackcallback-data}

**Добавлено в: v18.6.0, v16.17.0**

- `callback` [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Callback, который будет вызван после десериализации снимка.
- `data` [\<any\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) Необязательные данные, которые будут переданы в `callback` при его вызове.

Добавляет callback, который будет вызван, когда экземпляр Node.js десериализуется из снимка. `callback` и `data` (если предоставлены) будут сериализованы в снимок. Их можно использовать для повторной инициализации состояния приложения или для повторного получения ресурсов, которые необходимы приложению, когда приложение перезапускается из снимка.

Callback-и выполняются в том порядке, в котором они были добавлены.

### `v8.startupSnapshot.setDeserializeMainFunction(callback[, data])` {#v8startupsnapshotsetdeserializemainfunctioncallback-data}

**Добавлено в: v18.6.0, v16.17.0**

- `callback` [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Callback, который будет вызван как точка входа после десериализации снимка.
- `data` [\<any\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) Необязательные данные, которые будут переданы в `callback` при его вызове.

Устанавливает точку входа приложения Node.js при его десериализации из снимка. Это можно вызвать только один раз в скрипте создания снимка. Если он вызывается, десериализованному приложению больше не требуется дополнительный скрипт точки входа для запуска, и он просто вызовет callback вместе с десериализованными данными (если они предоставлены), в противном случае все еще необходимо предоставить скрипт точки входа десериализованному приложению.


### `v8.startupSnapshot.isBuildingSnapshot()` {#v8startupsnapshotisbuildingsnapshot}

**Добавлено в: v18.6.0, v16.17.0**

- Возвращает: [\<boolean\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

Возвращает true, если экземпляр Node.js запущен для создания снимка.

## Класс: `v8.GCProfiler` {#class-v8gcprofiler}

**Добавлено в: v19.6.0, v18.15.0**

Этот API собирает данные GC в текущем потоке.

### `new v8.GCProfiler()` {#new-v8gcprofiler}

**Добавлено в: v19.6.0, v18.15.0**

Создает новый экземпляр класса `v8.GCProfiler`.

### `profiler.start()` {#profilerstart}

**Добавлено в: v19.6.0, v18.15.0**

Начинает сбор данных GC.

### `profiler.stop()` {#profilerstop}

**Добавлено в: v19.6.0, v18.15.0**

Прекращает сбор данных GC и возвращает объект. Содержание объекта следующее.

```json [JSON]
{
  "version": 1,
  "startTime": 1674059033862,
  "statistics": [
    {
      "gcType": "Scavenge",
      "beforeGC": {
        "heapStatistics": {
          "totalHeapSize": 5005312,
          "totalHeapSizeExecutable": 524288,
          "totalPhysicalSize": 5226496,
          "totalAvailableSize": 4341325216,
          "totalGlobalHandlesSize": 8192,
          "usedGlobalHandlesSize": 2112,
          "usedHeapSize": 4883840,
          "heapSizeLimit": 4345298944,
          "mallocedMemory": 254128,
          "externalMemory": 225138,
          "peakMallocedMemory": 181760
        },
        "heapSpaceStatistics": [
          {
            "spaceName": "read_only_space",
            "spaceSize": 0,
            "spaceUsedSize": 0,
            "spaceAvailableSize": 0,
            "physicalSpaceSize": 0
          }
        ]
      },
      "cost": 1574.14,
      "afterGC": {
        "heapStatistics": {
          "totalHeapSize": 6053888,
          "totalHeapSizeExecutable": 524288,
          "totalPhysicalSize": 5500928,
          "totalAvailableSize": 4341101384,
          "totalGlobalHandlesSize": 8192,
          "usedGlobalHandlesSize": 2112,
          "usedHeapSize": 4059096,
          "heapSizeLimit": 4345298944,
          "mallocedMemory": 254128,
          "externalMemory": 225138,
          "peakMallocedMemory": 181760
        },
        "heapSpaceStatistics": [
          {
            "spaceName": "read_only_space",
            "spaceSize": 0,
            "spaceUsedSize": 0,
            "spaceAvailableSize": 0,
            "physicalSpaceSize": 0
          }
        ]
      }
    }
  ],
  "endTime": 1674059036865
}
```
Вот пример.

```js [ESM]
const { GCProfiler } = require('node:v8');
const profiler = new GCProfiler();
profiler.start();
setTimeout(() => {
  console.log(profiler.stop());
}, 1000);
```
