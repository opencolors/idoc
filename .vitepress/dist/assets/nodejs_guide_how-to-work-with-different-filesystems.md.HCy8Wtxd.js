import{__plugin_vue_export_helper_default as e,createElementBlock as t,createStaticVNode as n,openBlock as r}from"./chunks/plugin-vue_export-helper.Bts1mPc7.js";const i=JSON.parse(`{"title":"Best Practices for Working with Different Filesystems in Node.js","description":"Learn how to handle different filesystems in Node.js, including case sensitivity, Unicode form preservation, and timestamp resolution.","frontmatter":{"title":"Best Practices for Working with Different Filesystems in Node.js","description":"Learn how to handle different filesystems in Node.js, including case sensitivity, Unicode form preservation, and timestamp resolution.","head":[["meta",{"name":"og:title","content":"Best Practices for Working with Different Filesystems in Node.js | Node.js - iDoc.dev"}],["meta",{"name":"og:description","content":"Learn how to handle different filesystems in Node.js, including case sensitivity, Unicode form preservation, and timestamp resolution."}],["meta",{"name":"twitter:title","content":"Best Practices for Working with Different Filesystems in Node.js | Node.js - iDoc.dev"}],["meta",{"name":"twitter:description","content":"Learn how to handle different filesystems in Node.js, including case sensitivity, Unicode form preservation, and timestamp resolution."}],["link",{"rel":"canonical","href":"https://idoc.dev/nodejs/guide/how-to-work-with-different-filesystems"}],["meta",{"property":"og:url","content":"https://idoc.dev/nodejs/guide/how-to-work-with-different-filesystems"}]]},"headers":[],"relativePath":"nodejs/guide/how-to-work-with-different-filesystems.md","filePath":"en/nodejs/guide/how-to-work-with-different-filesystems.md","lastUpdated":1749464498000}`),a={name:`nodejs/guide/how-to-work-with-different-filesystems.md`};function o(e,i,a,o,s,c){return r(),t(`div`,null,i[0]||=[n(`<h1 id="how-to-work-with-different-filesystems" tabindex="-1">How to Work with Different Filesystems <a class="header-anchor" href="#how-to-work-with-different-filesystems" aria-label="Permalink to “How to Work with Different Filesystems”">​</a></h1><p>Node.js exposes many features of the filesystems. But not all filesystems are alike. The following are suggested best practices to keep your code simple and safe when working with different filesystems.</p><h2 id="filesystem-behavior" tabindex="-1">Filesystem Behavior <a class="header-anchor" href="#filesystem-behavior" aria-label="Permalink to “Filesystem Behavior”">​</a></h2><p>Before you can work with a filesystem, you need to know how it behaves. Different filesystems behave differently and have more or less features than others: case sensitivity, case insensitivity, case preservation, Unicode form preservation, timestamp resolution, extended attributes, inodes, Unix permissions, alternate data streams etc.</p><p>Be wary of inferring filesystem behavior from <code>process.platform</code>. For example, do not assume that because your program is running on Darwin that you are therefore working on a case insensitive filesystem (HFS+), as the user may be using a case-sensitive filesystem (HFSX). Similarly, do not assume that because your program is running on Linux that you are therefore working on a filesystem which supports Unix permissions and inodes, as you may be on a particular external drive, USB or network drive which does not.</p><p>The operating system may not make it easy to infer filesystem behavior, but all is not lost. Instead of keeping a list of every known filesystem and behavior (which is always going to be incomplete), you can probe the filesystem to see how it actually behaves. The presence or absence of certain features which are easy to probe, are often enough to infer the behavior of other features which are more difficult to probe.</p><p>Remember that some users may have different filesystems mounted at various paths in the working tree.</p><h2 id="avoid-a-lowest-common-denominator-approach" tabindex="-1">Avoid a Lowest Common Denominator Approach <a class="header-anchor" href="#avoid-a-lowest-common-denominator-approach" aria-label="Permalink to “Avoid a Lowest Common Denominator Approach”">​</a></h2><p>You might be tempted to make your program act like a lowest common denominator filesystem, by normalizing all filenames to uppercase, normalizing all filenames to NFC Unicode form, and normalizing all file timestamps to say 1-second resolution. This would be the lowest common denominator approach.</p><p>Do not do this. You would only be able to interact safely with a filesystem which has the exact same lowest common denominator characteristics in every respect. You would be unable to work with more advanced filesystems in the way that users expect, and you would run into filename or timestamp collisions. You would most certainly lose and corrupt user data through a series of complicated dependent events, and you would create bugs that would be difficult if not impossible to solve.</p><p>What happens when you later need to support a filesystem that only has 2-second or 24-hour timestamp resolution? What happens when the Unicode standard advances to include a slightly different normalization algorithm (as has happened in the past)?</p><p>A lowest common denominator approach would tend to try to create a portable program by using only &quot;portable&quot; system calls. This leads to programs that are leaky and not in fact portable.</p><h2 id="adopt-a-superset-approach" tabindex="-1">Adopt a Superset Approach <a class="header-anchor" href="#adopt-a-superset-approach" aria-label="Permalink to “Adopt a Superset Approach”">​</a></h2><p>Make the best use of each platform you support by adopting a superset approach. For example, a portable backup program should sync btimes (the created time of a file or folder) correctly between Windows systems, and should not destroy or alter btimes, even though btimes are not supported on Linux systems. The same portable backup program should sync Unix permissions correctly between Linux systems, and should not destroy or alter Unix permissions, even though Unix permissions are not supported on Windows systems.</p><p>Handle different filesystems by making your program act like a more advanced filesystem. Support a superset of all possible features: case-sensitivity, case-preservation, Unicode form sensitivity, Unicode form preservation, Unix permissions, high-resolution nanosecond timestamps, extended attributes etc.</p><p>Once you have case-preservation in your program, you can always implement case-insensitivity if you need to interact with a case-insensitive filesystem. But if you forego case-preservation in your program, you cannot interact safely with a case-preserving filesystem. The same is true for Unicode form preservation and timestamp resolution preservation.</p><p>If a filesystem provides you with a filename in a mix of lowercase and uppercase, then keep the filename in the exact case given. If a filesystem provides you with a filename in mixed Unicode form or NFC or NFD (or NFKC or NFKD), then keep the filename in the exact byte sequence given. If a filesystem provides you with a millisecond timestamp, then keep the timestamp in millisecond resolution.</p><p>When you work with a lesser filesystem, you can always downsample appropriately, with comparison functions as required by the behavior of the filesystem on which your program is running. lIf you know that the filesystem does not support Unix permissions, then you should not expect to read the same Unix permissions you write. If you know that the filesystem does not preserve case, then you should be prepared to see <code>ABC</code> in a directory listing when your program creates <code>abc</code>. But if you know that the filesystem does preserve case, then you should consider <code>ABC</code> to be a different filename to <code>abc</code>, when detecting file renames or if the filesystem is case sensitive.</p><h2 id="case-preservation" tabindex="-1">Case Preservation <a class="header-anchor" href="#case-preservation" aria-label="Permalink to “Case Preservation”">​</a></h2><p>You may create a directory called <code>test /abc</code> and be surprised to see sometimes that <code>fs.readdir(&#39;test&#39;)</code> returns <code>[&#39;ABC&#39;]</code>. This is not a bug in Node. Node returns the filename as the filesystem stores it, and not all filesystems support case-preservation. Some filesystems convert all filenames to uppercase (or lowercase).</p><h2 id="unicode-form-preservation" tabindex="-1">Unicode Form Preservation <a class="header-anchor" href="#unicode-form-preservation" aria-label="Permalink to “Unicode Form Preservation”">​</a></h2><p>Case preservation and Unicode form preservation are similar concepts. To understand why Unicode form should be preserved, make sure that you first understand why case should be preserved. Unicode form preservation is just as simple when understood correctly. Unicode can encode the same characters using several different byte sequences. Several strings may look the same, but have different byte sequences. When working with UTF-8 strings, be careful that your expectations are in line with how Unicode works. Just as you would not expect all UTF-8 characters to encode to a single byte, you should not expect several UTF-8 strings that look the same to the human eye to have the same byte representation. This may be an expectation that you can have of ASCll, but not of UTF-8.</p><p>You may create a directory called <code>test/ café</code> (NFC Unicode form with byte sequence <code>&lt;63 61 66 c3 a9&gt;</code> and <code>string.length ===5</code>) and be surprised to see sometimes that <code>fs.readdir(&#39;test&#39;)</code> returns <code>[&#39;café&#39;]</code> (NFD Unicode form with byte sequence <code>&lt;63 61 66 65 cc 81&gt;</code> and <code>string.length ===6</code>). This is not a bug in Node. Node.js returns the filename as the filesystem stores it, and not all filesystems support Unicode form preservation. HFS+, for example, will normalize all filenames to a form almost always the same as NFD form. Do not expect HFS+ to behave the same as NTFS or EXT 4 and vice-versa. Do not try to change data permanently through normalization as a leaky abstraction to paper over Unicode differences between filesystems. This would create problems without solving any. Rather, preserve Unicode form and use normalization as a comparison function only.</p><h2 id="unicode-form-insensitivity" tabindex="-1">Unicode Form Insensitivity <a class="header-anchor" href="#unicode-form-insensitivity" aria-label="Permalink to “Unicode Form Insensitivity”">​</a></h2><p>Unicode form insensitivity and Unicode form preservation are two different filesystem behaviors often mistaken for each other. Just as case-insensitivity has sometimes been incorrectly implemented by permanently normalizing filenames to uppercase when storing and transmitting filenames, so Unicode form insensitivity has sometimes been incorrectly implemented by permanently normalizing filenames to a certain Unicode form (NFD in the case of HFS+) when storing and transmitting filenames. It is possible and much better to implement Unicode form insensitivity without sacrificing Unicode form preservation, by using Unicode normalization for comparison only.</p><h2 id="comparing-different-unicode-forms" tabindex="-1">Comparing Different Unicode Forms <a class="header-anchor" href="#comparing-different-unicode-forms" aria-label="Permalink to “Comparing Different Unicode Forms”">​</a></h2><p>Node.js provides <code>string.normalize (&#39;NFC&#39; / &#39;NFD&#39;)</code> which you can use to normalize a UTF-8 string to either NFC or NFD. You should never store the output from this function but only use it as part of a comparison function to test whether two UTF-8 strings would look the same to the user. You can use <code>string1.normalize(&#39;NFC&#39;)=== string2.normalize(&#39;NFC&#39;)</code> or <code>string1.normalize(&#39;NFD&#39;)=== string2.normalize(&#39;NFD&#39;)</code> as your comparison function. Which form you use does not matter.</p><p>Normalization is fast but you may want to use a cache as input to your comparison function to avoid normalizing the same string many times over. If the string is not present in the cache then normalize it and cache it. Be careful not to store or persist the cache, use it only as a cache.</p><p>Note that using <code>normalize ()</code> requires that your version of Node.js include ICU (otherwise <code>normalize ()</code> will just return the original string). If you download the latest version of Node.js from the website then it will include ICU.</p><h2 id="timestamp-resolution" tabindex="-1">Timestamp Resolution <a class="header-anchor" href="#timestamp-resolution" aria-label="Permalink to “Timestamp Resolution”">​</a></h2><p>You may set the mtime (the modified time) of a file to 1444291759414 (millisecond resolution) and be surprised to see sometimes that <code>fs.stat</code> returns the new mtime as 1444291759000 (1 second resolution) or 1444291758000 (2-second resolution). This is not a bug in Node. Node.js returns the timestamp as the filesystem stores it, and not all filesystems support nanosecond, millisecond or 1-second timestamp resolution. Some filesystems even have very coarse resolution for the atime timestamp in particular, e.g. 24 hours for some FAT filesystems.</p><h2 id="do-not-corrupt-filenames-and-timestamps-through-normalization" tabindex="-1">Do Not Corrupt Filenames and Timestamps Through Normalization <a class="header-anchor" href="#do-not-corrupt-filenames-and-timestamps-through-normalization" aria-label="Permalink to “Do Not Corrupt Filenames and Timestamps Through Normalization”">​</a></h2><p>Filenames and timestamps are user data. Just as you would never automatically rewrite user file data to uppercase the data or normalize CRLF to LF line-endings, so you should never change, interfere or corrupt filenames or timestamps through case / Unicode form / timestamp normalization. Normalization should only ever be used for comparison, never for altering data.</p><p>Normalization is effectively a lossy hash code. You can use it to test for certain kinds of equivalence (e.g. do several strings look the same even though they have different byte sequences) but you can never use it as a substitute for the actual data. Your program should pass on filename and timestamp data as is.</p><p>Your program can create new data in NFC (or in any combination of Unicode form it prefers) or with a lowercase or uppercase filename, or with a 2-second resolution timestamp, but your program should not corrupt existing user data by imposing case / Unicode form / timestamp normalization. Rather, adopt a superset approach and preserve case, Unicode form and timestamp resolution in your program. That way, you will be able to interact safely with filesystems which do the same.</p><h2 id="use-normalization-comparison-functions-appropriately" tabindex="-1">Use Normalization Comparison Functions Appropriately <a class="header-anchor" href="#use-normalization-comparison-functions-appropriately" aria-label="Permalink to “Use Normalization Comparison Functions Appropriately”">​</a></h2><p>Make sure that you use case / Unicode form / timestamp comparison functions appropriately. Do not use a case-insensitive filename comparison function if you are working on a case-sensitive filesystem. Do not use a Unicode form insensitive comparison function if you are working on a Unicode form sensitive filesystem (e.g. NTFS and most Linux filesystems which preserve both NFC and NFD or mixed Unicode forms). Do not compare timestamps at 2-second resolution if you are working on a nanosecond timestamp resolution filesystem.</p><h2 id="be-prepared-for-slight-differences-in-comparison-functions" tabindex="-1">Be Prepared for Slight Differences in Comparison Functions <a class="header-anchor" href="#be-prepared-for-slight-differences-in-comparison-functions" aria-label="Permalink to “Be Prepared for Slight Differences in Comparison Functions”">​</a></h2><p>Be careful that your comparison functions match those of the filesystem (or probe the filesystem if possible to see how it would actually compare). Case-insensitivity for example is more complex than a simple <code>toLowerCase()</code> comparison. In fact, <code>toUpperCase()</code> is usually better than <code>toLowerCase ()</code> (since it handles certain foreign language characters differently). But better still would be to probe the filesystem since every filesystem has its own case comparison table baked in.</p><p>As an example, Apple&#39;s HFS+ normalizes filenames to NFD form but this NFD form is actually an older version of the current NFD form and may sometimes be slightly different from the latest Unicode standard&#39;s NFD form. Do not expect HFS+ NFD to be exactly the same as Unicode NFD all the time.</p>`,40)])}var s=e(a,[[`render`,o]]);export{i as __pageData,s as default};