import{__plugin_vue_export_helper_default as e,createElementBlock as t,createStaticVNode as n,openBlock as r}from"./chunks/plugin-vue_export-helper.Bts1mPc7.js";const i=JSON.parse(`{"title":"Migliori pratiche per lavorare con diversi sistemi di file in Node.js","description":"Scopri come gestire diversi sistemi di file in Node.js, inclusa la sensibilità alle maiuscole e minuscole, la preservazione della forma Unicode e la risoluzione dei timestamp.","frontmatter":{"title":"Migliori pratiche per lavorare con diversi sistemi di file in Node.js","description":"Scopri come gestire diversi sistemi di file in Node.js, inclusa la sensibilità alle maiuscole e minuscole, la preservazione della forma Unicode e la risoluzione dei timestamp.","head":[["meta",{"name":"og:title","content":"Migliori pratiche per lavorare con diversi sistemi di file in Node.js | Node.js - iDoc.dev"}],["meta",{"name":"og:description","content":"Scopri come gestire diversi sistemi di file in Node.js, inclusa la sensibilità alle maiuscole e minuscole, la preservazione della forma Unicode e la risoluzione dei timestamp."}],["meta",{"name":"twitter:title","content":"Migliori pratiche per lavorare con diversi sistemi di file in Node.js | Node.js - iDoc.dev"}],["meta",{"name":"twitter:description","content":"Scopri come gestire diversi sistemi di file in Node.js, inclusa la sensibilità alle maiuscole e minuscole, la preservazione della forma Unicode e la risoluzione dei timestamp."}],["link",{"rel":"canonical","href":"https://idoc.dev/it/nodejs/guide/how-to-work-with-different-filesystems"}],["meta",{"property":"og:url","content":"https://idoc.dev/it/nodejs/guide/how-to-work-with-different-filesystems"}]]},"headers":[],"relativePath":"it/nodejs/guide/how-to-work-with-different-filesystems.md","filePath":"it/nodejs/guide/how-to-work-with-different-filesystems.md","lastUpdated":null}`),a={name:`it/nodejs/guide/how-to-work-with-different-filesystems.md`};function o(e,i,a,o,s,c){return r(),t(`div`,null,i[0]||=[n(`<h1 id="come-lavorare-con-diversi-file-system" tabindex="-1">Come lavorare con diversi file system <a class="header-anchor" href="#come-lavorare-con-diversi-file-system" aria-label="Permalink to “Come lavorare con diversi file system”">​</a></h1><p>Node.js espone molte funzionalità dei file system. Ma non tutti i file system sono uguali. Di seguito sono riportate le migliori pratiche suggerite per mantenere il tuo codice semplice e sicuro quando si lavora con diversi file system.</p><h2 id="comportamento-del-file-system" tabindex="-1">Comportamento del file system <a class="header-anchor" href="#comportamento-del-file-system" aria-label="Permalink to “Comportamento del file system”">​</a></h2><p>Prima di poter lavorare con un file system, è necessario sapere come si comporta. Diversi file system si comportano in modo diverso e hanno più o meno funzionalità di altri: distinzione tra maiuscole e minuscole, indifferenza tra maiuscole e minuscole, conservazione delle maiuscole e minuscole, conservazione della forma Unicode, risoluzione del timestamp, attributi estesi, inode, autorizzazioni Unix, flussi di dati alternativi ecc.</p><p>Fai attenzione a inferire il comportamento del file system da <code>process.platform</code>. Ad esempio, non presumere che, poiché il tuo programma è in esecuzione su Darwin, stai quindi lavorando su un file system che non distingue tra maiuscole e minuscole (HFS+), poiché l&#39;utente potrebbe utilizzare un file system che distingue tra maiuscole e minuscole (HFSX). Allo stesso modo, non presumere che, poiché il tuo programma è in esecuzione su Linux, stai quindi lavorando su un file system che supporta autorizzazioni Unix e inode, poiché potresti trovarti su un particolare disco esterno, USB o di rete che non lo fa.</p><p>Il sistema operativo potrebbe non rendere facile l&#39;inferenza del comportamento del file system, ma non tutto è perduto. Invece di tenere un elenco di ogni file system e comportamento noto (che sarà sempre incompleto), puoi sondare il file system per vedere come si comporta effettivamente. La presenza o l&#39;assenza di determinate funzionalità che sono facili da sondare, sono spesso sufficienti per inferire il comportamento di altre funzionalità che sono più difficili da sondare.</p><p>Ricorda che alcuni utenti potrebbero avere diversi file system montati in vari percorsi nell&#39;albero di lavoro.</p><h2 id="evita-un-approccio-al-minimo-comune-denominatore" tabindex="-1">Evita un approccio al minimo comune denominatore <a class="header-anchor" href="#evita-un-approccio-al-minimo-comune-denominatore" aria-label="Permalink to “Evita un approccio al minimo comune denominatore”">​</a></h2><p>Potresti essere tentato di far agire il tuo programma come un file system di minimo comune denominatore, normalizzando tutti i nomi di file in maiuscolo, normalizzando tutti i nomi di file nella forma Unicode NFC e normalizzando tutti i timestamp dei file a una risoluzione di 1 secondo. Questo sarebbe l&#39;approccio del minimo comune denominatore.</p><p>Non farlo. Saresti in grado di interagire in modo sicuro solo con un file system che ha esattamente le stesse caratteristiche del minimo comune denominatore in ogni aspetto. Non saresti in grado di lavorare con file system più avanzati nel modo in cui gli utenti si aspettano e ti imbatteresti in collisioni di nomi di file o timestamp. Molto probabilmente perderesti e corromperesti i dati dell&#39;utente attraverso una serie di complicati eventi dipendenti e creeresti bug che sarebbero difficili se non impossibili da risolvere.</p><p>Cosa succede quando in seguito devi supportare un file system che ha solo una risoluzione del timestamp di 2 secondi o 24 ore? Cosa succede quando lo standard Unicode avanza per includere un algoritmo di normalizzazione leggermente diverso (come è successo in passato)?</p><p>Un approccio al minimo comune denominatore tenderebbe a cercare di creare un programma portatile utilizzando solo chiamate di sistema &quot;portatili&quot;. Questo porta a programmi che sono difettosi e in realtà non portatili.</p><h2 id="adotta-un-approccio-superset" tabindex="-1">Adotta un approccio superset <a class="header-anchor" href="#adotta-un-approccio-superset" aria-label="Permalink to “Adotta un approccio superset”">​</a></h2><p>Sfrutta al meglio ogni piattaforma che supporti adottando un approccio superset. Ad esempio, un programma di backup portatile dovrebbe sincronizzare correttamente i btime (l&#39;ora di creazione di un file o una cartella) tra i sistemi Windows e non dovrebbe distruggere o alterare i btime, anche se i btime non sono supportati sui sistemi Linux. Lo stesso programma di backup portatile dovrebbe sincronizzare correttamente i permessi Unix tra i sistemi Linux e non dovrebbe distruggere o alterare i permessi Unix, anche se i permessi Unix non sono supportati sui sistemi Windows.</p><p>Gestisci i diversi filesystem facendo agire il tuo programma come un filesystem più avanzato. Supporta un superset di tutte le funzionalità possibili: distinzione tra maiuscole e minuscole, conservazione delle maiuscole e minuscole, sensibilità alla forma Unicode, conservazione della forma Unicode, permessi Unix, timestamp ad alta risoluzione in nanosecondi, attributi estesi ecc.</p><p>Una volta che hai la conservazione delle maiuscole e minuscole nel tuo programma, puoi sempre implementare l&#39;insensibilità alle maiuscole e minuscole se hai bisogno di interagire con un filesystem insensibile alle maiuscole e minuscole. Ma se rinunci alla conservazione delle maiuscole e minuscole nel tuo programma, non puoi interagire in modo sicuro con un filesystem che conserva le maiuscole e minuscole. Lo stesso vale per la conservazione della forma Unicode e la conservazione della risoluzione dei timestamp.</p><p>Se un filesystem ti fornisce un nome file in un mix di minuscole e maiuscole, conserva il nome file esattamente nella forma fornita. Se un filesystem ti fornisce un nome file in forma Unicode mista o NFC o NFD (o NFKC o NFKD), conserva il nome file esattamente nella sequenza di byte fornita. Se un filesystem ti fornisce un timestamp in millisecondi, conserva il timestamp con una risoluzione in millisecondi.</p><p>Quando lavori con un filesystem inferiore, puoi sempre sottocampionare in modo appropriato, con funzioni di confronto come richiesto dal comportamento del filesystem su cui è in esecuzione il tuo programma. Se sai che il filesystem non supporta i permessi Unix, non dovresti aspettarti di leggere gli stessi permessi Unix che scrivi. Se sai che il filesystem non conserva le maiuscole e minuscole, dovresti essere pronto a vedere <code>ABC</code> in un elenco di directory quando il tuo programma crea <code>abc</code>. Ma se sai che il filesystem conserva le maiuscole e minuscole, dovresti considerare <code>ABC</code> come un nome file diverso da <code>abc</code>, quando rilevi la ridenominazione dei file o se il filesystem è sensibile alle maiuscole e minuscole.</p><h2 id="conservazione-della-maiuscola-minuscola" tabindex="-1">Conservazione della maiuscola/minuscola <a class="header-anchor" href="#conservazione-della-maiuscola-minuscola" aria-label="Permalink to “Conservazione della maiuscola/minuscola”">​</a></h2><p>Potresti creare una directory chiamata <code>test /abc</code> e rimanere sorpreso di vedere a volte che <code>fs.readdir(&#39;test&#39;)</code> restituisce <code>[&#39;ABC&#39;]</code>. Questo non è un bug in Node. Node restituisce il nome del file come lo memorizza il filesystem, e non tutti i filesystem supportano la conservazione della maiuscola/minuscola. Alcuni filesystem convertono tutti i nomi di file in maiuscolo (o minuscolo).</p><h2 id="conservazione-della-forma-unicode" tabindex="-1">Conservazione della forma Unicode <a class="header-anchor" href="#conservazione-della-forma-unicode" aria-label="Permalink to “Conservazione della forma Unicode”">​</a></h2><p>La conservazione della maiuscola/minuscola e la conservazione della forma Unicode sono concetti simili. Per capire perché la forma Unicode dovrebbe essere conservata, assicurati di aver prima capito perché la maiuscola/minuscola dovrebbe essere conservata. La conservazione della forma Unicode è altrettanto semplice quando compresa correttamente. Unicode può codificare gli stessi caratteri usando diverse sequenze di byte. Diverse stringhe possono sembrare uguali, ma avere sequenze di byte diverse. Quando si lavora con stringhe UTF-8, fai attenzione che le tue aspettative siano in linea con il modo in cui funziona Unicode. Proprio come non ti aspetteresti che tutti i caratteri UTF-8 codifichino in un singolo byte, non dovresti aspettarti che diverse stringhe UTF-8 che sembrano uguali all&#39;occhio umano abbiano la stessa rappresentazione in byte. Questa potrebbe essere un&#39;aspettativa che puoi avere di ASCll, ma non di UTF-8.</p><p>Potresti creare una directory chiamata <code>test/ café</code> (forma Unicode NFC con sequenza di byte <code>&lt;63 61 66 c3 a9&gt;</code> e <code>string.length ===5</code>) e rimanere sorpreso di vedere a volte che <code>fs.readdir(&#39;test&#39;)</code> restituisce <code>[&#39;café&#39;]</code> (forma Unicode NFD con sequenza di byte <code>&lt;63 61 66 65 cc 81&gt;</code> e <code>string.length ===6</code>). Questo non è un bug in Node. Node.js restituisce il nome del file come lo memorizza il filesystem, e non tutti i filesystem supportano la conservazione della forma Unicode. HFS+, per esempio, normalizzerà tutti i nomi di file in una forma quasi sempre uguale alla forma NFD. Non aspettarti che HFS+ si comporti allo stesso modo di NTFS o EXT 4 e viceversa. Non provare a cambiare i dati in modo permanente attraverso la normalizzazione come un&#39;astrazione che perde per mascherare le differenze Unicode tra i filesystem. Questo creerebbe problemi senza risolverne nessuno. Piuttosto, conserva la forma Unicode e usa la normalizzazione solo come funzione di confronto.</p><h2 id="invarianza-alla-forma-unicode" tabindex="-1">Invarianza alla Forma Unicode <a class="header-anchor" href="#invarianza-alla-forma-unicode" aria-label="Permalink to “Invarianza alla Forma Unicode”">​</a></h2><p>L&#39;invarianza alla forma Unicode e la conservazione della forma Unicode sono due comportamenti diversi del filesystem spesso confusi l&#39;uno con l&#39;altro. Proprio come l&#39;invarianza al caso è stata talvolta implementata in modo errato normalizzando permanentemente i nomi dei file in maiuscolo durante l&#39;archiviazione e la trasmissione dei nomi dei file, così l&#39;invarianza alla forma Unicode è stata talvolta implementata in modo errato normalizzando permanentemente i nomi dei file a una certa forma Unicode (NFD nel caso di HFS+) durante l&#39;archiviazione e la trasmissione dei nomi dei file. È possibile e molto meglio implementare l&#39;invarianza alla forma Unicode senza sacrificare la conservazione della forma Unicode, utilizzando la normalizzazione Unicode solo per il confronto.</p><h2 id="confronto-tra-diverse-forme-unicode" tabindex="-1">Confronto tra diverse forme Unicode <a class="header-anchor" href="#confronto-tra-diverse-forme-unicode" aria-label="Permalink to “Confronto tra diverse forme Unicode”">​</a></h2><p>Node.js fornisce <code>string.normalize (&#39;NFC&#39; / &#39;NFD&#39;)</code> che puoi usare per normalizzare una stringa UTF-8 in NFC o NFD. Non dovresti mai memorizzare l&#39;output di questa funzione ma usarlo solo come parte di una funzione di confronto per verificare se due stringhe UTF-8 apparirebbero uguali all&#39;utente. Puoi usare <code>string1.normalize(&#39;NFC&#39;)=== string2.normalize(&#39;NFC&#39;)</code> o <code>string1.normalize(&#39;NFD&#39;)=== string2.normalize(&#39;NFD&#39;)</code> come funzione di confronto. Quale forma usi non importa.</p><p>La normalizzazione è veloce, ma potresti voler usare una cache come input per la tua funzione di confronto per evitare di normalizzare la stessa stringa molte volte. Se la stringa non è presente nella cache, normalizzala e memorizzala nella cache. Fai attenzione a non archiviare o persistere la cache, usala solo come cache.</p><p>Tieni presente che l&#39;utilizzo di <code>normalize ()</code> richiede che la tua versione di Node.js includa ICU (altrimenti <code>normalize ()</code> restituirà semplicemente la stringa originale). Se scarichi l&#39;ultima versione di Node.js dal sito web, includerà ICU.</p><h2 id="risoluzione-timestamp" tabindex="-1">Risoluzione Timestamp <a class="header-anchor" href="#risoluzione-timestamp" aria-label="Permalink to “Risoluzione Timestamp”">​</a></h2><p>Potresti impostare l&#39;mtime (l&#39;ora di modifica) di un file su 1444291759414 (risoluzione in millisecondi) ed essere sorpreso di vedere a volte che <code>fs.stat</code> restituisce il nuovo mtime come 1444291759000 (risoluzione a 1 secondo) o 1444291758000 (risoluzione a 2 secondi). Questo non è un bug in Node. Node.js restituisce il timestamp così come lo memorizza il filesystem, e non tutti i filesystem supportano la risoluzione del timestamp in nanosecondi, millisecondi o 1 secondo. Alcuni filesystem hanno anche una risoluzione molto grossolana per il timestamp atime in particolare, ad esempio 24 ore per alcuni filesystem FAT.</p><h2 id="non-corrompere-nomi-di-file-e-timestamp-tramite-normalizzazione" tabindex="-1">Non Corrompere Nomi di File e Timestamp Tramite Normalizzazione <a class="header-anchor" href="#non-corrompere-nomi-di-file-e-timestamp-tramite-normalizzazione" aria-label="Permalink to “Non Corrompere Nomi di File e Timestamp Tramite Normalizzazione”">​</a></h2><p>Nomi di file e timestamp sono dati dell&#39;utente. Proprio come non riscriveresti mai automaticamente i dati dei file dell&#39;utente per trasformare i dati in maiuscolo o normalizzare i terminatori di riga CRLF in LF, così non dovresti mai modificare, interferire o corrompere nomi di file o timestamp tramite la normalizzazione di case / forma Unicode / timestamp. La normalizzazione dovrebbe essere usata solo per il confronto, mai per alterare i dati.</p><p>La normalizzazione è effettivamente un codice hash con perdita di dati. Puoi usarla per testare certi tipi di equivalenza (ad es. se diverse stringhe appaiono uguali anche se hanno sequenze di byte diverse) ma non puoi mai usarla come sostituto dei dati effettivi. Il tuo programma dovrebbe passare i dati dei nomi di file e dei timestamp così come sono.</p><p>Il tuo programma può creare nuovi dati in NFC (o in qualsiasi combinazione di forma Unicode preferisca) o con un nome file in minuscolo o maiuscolo, o con un timestamp con una risoluzione di 2 secondi, ma il tuo programma non dovrebbe corrompere i dati utente esistenti imponendo la normalizzazione di case / forma Unicode / timestamp. Piuttosto, adotta un approccio di superset e preserva case, forma Unicode e risoluzione del timestamp nel tuo programma. In questo modo, sarai in grado di interagire in sicurezza con i filesystem che fanno lo stesso.</p><h2 id="usa-le-funzioni-di-confronto-di-normalizzazione-appropriatamente" tabindex="-1">Usa le Funzioni di Confronto di Normalizzazione Appropriatamente <a class="header-anchor" href="#usa-le-funzioni-di-confronto-di-normalizzazione-appropriatamente" aria-label="Permalink to “Usa le Funzioni di Confronto di Normalizzazione Appropriatamente”">​</a></h2><p>Assicurati di usare le funzioni di confronto di case / forma Unicode / timestamp in modo appropriato. Non usare una funzione di confronto di nomi di file che non fa distinzione tra maiuscole e minuscole se stai lavorando su un filesystem che fa distinzione tra maiuscole e minuscole. Non usare una funzione di confronto che non fa distinzione tra forma Unicode se stai lavorando su un filesystem che fa distinzione tra forma Unicode (ad es. NTFS e la maggior parte dei filesystem Linux che preservano sia NFC che NFD o forme Unicode miste). Non confrontare i timestamp con una risoluzione di 2 secondi se stai lavorando su un filesystem con una risoluzione del timestamp in nanosecondi.</p><h2 id="preparati-a-leggere-differenze-nelle-funzioni-di-confronto" tabindex="-1">Preparati a Leggere Differenze nelle Funzioni di Confronto <a class="header-anchor" href="#preparati-a-leggere-differenze-nelle-funzioni-di-confronto" aria-label="Permalink to “Preparati a Leggere Differenze nelle Funzioni di Confronto”">​</a></h2><p>Fai attenzione che le tue funzioni di confronto corrispondano a quelle del filesystem (o sonda il filesystem se possibile per vedere come lo confronterebbe effettivamente). L&#39;insensibilità alle maiuscole, ad esempio, è più complessa di un semplice confronto <code>toLowerCase()</code>. In realtà, <code>toUpperCase()</code> è solitamente migliore di <code>toLowerCase()</code> (poiché gestisce alcuni caratteri di lingue straniere in modo diverso). Ma ancora meglio sarebbe sondare il filesystem poiché ogni filesystem ha la sua tabella di confronto di case integrata.</p><p>Ad esempio, HFS+ di Apple normalizza i nomi di file in forma NFD, ma questa forma NFD è in realtà una versione precedente dell&#39;attuale forma NFD e a volte può essere leggermente diversa dalla forma NFD dell&#39;ultimo standard Unicode. Non aspettarti che HFS+ NFD sia esattamente uguale a Unicode NFD tutto il tempo.</p>`,40)])}var s=e(a,[[`render`,o]]);export{i as __pageData,s as default};