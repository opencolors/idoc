import{__plugin_vue_export_helper_default as e,createElementBlock as t,createStaticVNode as n,openBlock as r}from"./chunks/plugin-vue_export-helper.Bts1mPc7.js";const i=JSON.parse(`{"title":"Grafici di fiamma per l'ottimizzazione delle prestazioni di Node.js","description":"Scopri come creare grafici di fiamma per visualizzare il tempo di CPU dedicato alle funzioni e ottimizzare le prestazioni di Node.js.","frontmatter":{"title":"Grafici di fiamma per l'ottimizzazione delle prestazioni di Node.js","description":"Scopri come creare grafici di fiamma per visualizzare il tempo di CPU dedicato alle funzioni e ottimizzare le prestazioni di Node.js.","head":[["meta",{"name":"og:title","content":"Grafici di fiamma per l'ottimizzazione delle prestazioni di Node.js | Node.js - iDoc.dev"}],["meta",{"name":"og:description","content":"Scopri come creare grafici di fiamma per visualizzare il tempo di CPU dedicato alle funzioni e ottimizzare le prestazioni di Node.js."}],["meta",{"name":"twitter:title","content":"Grafici di fiamma per l'ottimizzazione delle prestazioni di Node.js | Node.js - iDoc.dev"}],["meta",{"name":"twitter:description","content":"Scopri come creare grafici di fiamma per visualizzare il tempo di CPU dedicato alle funzioni e ottimizzare le prestazioni di Node.js."}],["link",{"rel":"canonical","href":"https://idoc.dev/it/nodejs/guide/flame-graphs"}],["meta",{"property":"og:url","content":"https://idoc.dev/it/nodejs/guide/flame-graphs"}]]},"headers":[],"relativePath":"it/nodejs/guide/flame-graphs.md","filePath":"it/nodejs/guide/flame-graphs.md","lastUpdated":null}`),a={name:`it/nodejs/guide/flame-graphs.md`};function o(e,i,a,o,s,c){return r(),t(`div`,null,i[0]||=[n(`<h1 id="grafici-a-fiamma" tabindex="-1">Grafici a fiamma <a class="header-anchor" href="#grafici-a-fiamma" aria-label="Permalink to “Grafici a fiamma”">​</a></h1><h2 id="a-cosa-serve-un-grafico-a-fiamma" tabindex="-1">A cosa serve un grafico a fiamma? <a class="header-anchor" href="#a-cosa-serve-un-grafico-a-fiamma" aria-label="Permalink to “A cosa serve un grafico a fiamma?”">​</a></h2><p>I grafici a fiamma sono un modo per visualizzare il tempo della CPU speso nelle funzioni. Possono aiutarti a individuare dove trascorri troppo tempo a eseguire operazioni sincrone.</p><h2 id="come-creare-un-grafico-a-fiamma" tabindex="-1">Come creare un grafico a fiamma <a class="header-anchor" href="#come-creare-un-grafico-a-fiamma" aria-label="Permalink to “Come creare un grafico a fiamma”">​</a></h2><p>Potresti aver sentito dire che creare un grafico a fiamma per Node.js è difficile, ma non è vero (più). Le VM Solaris non sono più necessarie per i grafici a fiamma!</p><p>I grafici a fiamma vengono generati dall&#39;output di <code>perf</code>, che non è uno strumento specifico per node. Mentre è il modo più potente per visualizzare il tempo della CPU speso, potrebbe avere problemi con il modo in cui il codice JavaScript è ottimizzato in Node.js 8 e versioni successive. Consulta la sezione <a href="#perf-output-issues">problemi di output di perf</a> di seguito.</p><h3 id="utilizzare-uno-strumento-pre-pacchettizzato" tabindex="-1">Utilizzare uno strumento pre-pacchettizzato <a class="header-anchor" href="#utilizzare-uno-strumento-pre-pacchettizzato" aria-label="Permalink to “Utilizzare uno strumento pre-pacchettizzato”">​</a></h3><p>Se desideri un singolo passaggio che produca un grafico a fiamma localmente, prova <a href="https://www.npmjs.com/package/0x" target="_blank" rel="noreferrer">0x</a></p><p>Per diagnosticare le implementazioni di produzione, leggi queste note: <a href="https://github.com/davidmarkclements/0x/blob/master/docs/production-servers.md" target="_blank" rel="noreferrer">0x server di produzione</a>.</p><h3 id="crea-un-grafico-a-fiamma-con-gli-strumenti-perf-di-sistema" tabindex="-1">Crea un grafico a fiamma con gli strumenti perf di sistema <a class="header-anchor" href="#crea-un-grafico-a-fiamma-con-gli-strumenti-perf-di-sistema" aria-label="Permalink to “Crea un grafico a fiamma con gli strumenti perf di sistema”">​</a></h3><p>Lo scopo di questa guida è mostrare i passaggi necessari per creare un grafico a fiamma e mantenerti in controllo di ogni passaggio.</p><p>Se desideri comprendere meglio ogni passaggio, dai un&#39;occhiata alle sezioni seguenti in cui approfondiamo i dettagli.</p><p>Ora mettiamoci al lavoro.</p><ol><li>Installa <code>perf</code> (di solito disponibile tramite il pacchetto linux-tools-common se non è già installato)</li><li>Prova a eseguire <code>perf</code> - potrebbe lamentarsi della mancanza di moduli del kernel, installa anche quelli</li><li>Esegui node con perf abilitato (vedi <a href="#perf-output-issues">problemi di output di perf</a> per suggerimenti specifici per le versioni di Node.js)</li></ol><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">perf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> record</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cycles:u</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --perf-basic-prof</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app.js</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ol start="4"><li>Ignora gli avvisi a meno che non ti dicano che non puoi eseguire perf a causa di pacchetti mancanti; potresti ricevere alcuni avvisi sull&#39;impossibilità di accedere agli esempi del modulo del kernel, che comunque non stai cercando.</li><li>Esegui <code>perf script &gt; perfs.out</code> per generare il file di dati che visualizzerai tra un momento. È utile applicare una pulizia per un grafico più leggibile</li><li>Installa stackvis se non è già installato <code>npm i -g stackvis</code></li><li>Esegui <code>stackvis perf &lt; perfs.out &gt; flamegraph.htm</code></li></ol><p>Ora apri il file del grafico a fiamma nel tuo browser preferito e guardalo bruciare. È codificato a colori in modo da poterti concentrare prima sulle barre arancioni più sature. È probabile che rappresentino funzioni ad alta intensità di CPU.</p><p>Vale la pena ricordare: se fai clic su un elemento di un grafico a fiamma, sopra il grafico verrà visualizzato uno zoom dei suoi dintorni.</p><h3 id="utilizzare-perf-per-campionare-un-processo-in-esecuzione" tabindex="-1">Utilizzare <code>perf</code> per campionare un processo in esecuzione <a class="header-anchor" href="#utilizzare-perf-per-campionare-un-processo-in-esecuzione" aria-label="Permalink to “Utilizzare perf per campionare un processo in esecuzione”">​</a></h3><p>Questo è ottimo per registrare dati di flame graph da un processo già in esecuzione che non si vuole interrompere. Immagina un processo di produzione con un problema difficile da riprodurre.</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">perf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> record</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -F99</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pgrep</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node\`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> --</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sleep</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>A cosa serve quello <code>sleep 3</code>? Serve per mantenere <code>perf</code> in esecuzione - nonostante l&#39;opzione <code>-p</code> punti a un PID diverso, il comando deve essere eseguito su un processo e terminare con esso. <code>perf</code> è in esecuzione per tutta la durata del comando che gli si passa, indipendentemente dal fatto che si stia effettivamente profilando quel comando. <code>sleep 3</code> assicura che <code>perf</code> sia in esecuzione per 3 secondi.</p><p>Perché <code>-F</code> (frequenza di profilazione) è impostato su 99? È un valore predefinito ragionevole. Puoi regolarlo se vuoi. <code>-F99</code> dice a <code>perf</code> di prelevare 99 campioni al secondo, per una maggiore precisione aumenta il valore. Valori inferiori dovrebbero produrre meno output con risultati meno precisi. La precisione di cui hai bisogno dipende da quanto tempo sono effettivamente in esecuzione le tue funzioni ad alta intensità di CPU. Se stai cercando la ragione di un rallentamento notevole, 99 frame al secondo dovrebbero essere più che sufficienti.</p><p>Dopo aver ottenuto quella registrazione <code>perf</code> di 3 secondi, procedi con la generazione del flame graph con gli ultimi due passaggi di sopra.</p><h3 id="filtrare-le-funzioni-interne-di-node-js" tabindex="-1">Filtrare le funzioni interne di Node.js <a class="header-anchor" href="#filtrare-le-funzioni-interne-di-node-js" aria-label="Permalink to “Filtrare le funzioni interne di Node.js”">​</a></h3><p>Di solito, vuoi solo guardare le prestazioni delle tue chiamate, quindi filtrare le funzioni interne di Node.js e V8 può rendere il grafico molto più facile da leggere. Puoi pulire il tuo file <code>perf</code> con:</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sed</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -i</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -r</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/(_libc_start|LazyCompile) |v8::internal::BuiltIn|Stub|LoadIC:\\\\[\\\\[&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/^$/d&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    perf.data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> perf.out</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Se leggi il tuo flame graph e ti sembra strano, come se mancasse qualcosa nella funzione chiave che occupa la maggior parte del tempo, prova a generare il tuo flame graph senza i filtri - forse hai un raro caso di un problema con Node.js stesso.</p><h3 id="opzioni-di-profilazione-di-node-js" tabindex="-1">Opzioni di profilazione di Node.js <a class="header-anchor" href="#opzioni-di-profilazione-di-node-js" aria-label="Permalink to “Opzioni di profilazione di Node.js”">​</a></h3><p><code>--perf-basic-prof-only-functions</code> e <code>--perf-basic-prof</code> sono le due che sono utili per il debug del tuo codice JavaScript. Altre opzioni vengono utilizzate per la profilazione di Node.js stesso, il che esula dallo scopo di questa guida.</p><p><code>--perf-basic-prof-only-functions</code> produce meno output, quindi è l&#39;opzione con il minor overhead.</p><h3 id="perche-ne-ho-bisogno" tabindex="-1">Perché ne ho bisogno? <a class="header-anchor" href="#perche-ne-ho-bisogno" aria-label="Permalink to “Perché ne ho bisogno?”">​</a></h3><p>Bene, senza queste opzioni, otterrai comunque un flame graph, ma con la maggior parte delle barre etichettate come <code>v8::Function::Call</code>.</p><h2 id="problemi-con-l-output-di-perf" tabindex="-1">Problemi con l&#39;output di <code>Perf</code> <a class="header-anchor" href="#problemi-con-l-output-di-perf" aria-label="Permalink to “Problemi con l&#39;output di Perf”">​</a></h2><h3 id="modifiche-alla-pipeline-v8-in-node-js-8-x" tabindex="-1">Modifiche alla pipeline V8 in Node.js 8.x <a class="header-anchor" href="#modifiche-alla-pipeline-v8-in-node-js-8-x" aria-label="Permalink to “Modifiche alla pipeline V8 in Node.js 8.x”">​</a></h3><p>Node.js 8.x e versioni successive vengono forniti con nuove ottimizzazioni alla pipeline di compilazione JavaScript nel motore V8 che a volte rende irraggiungibili i nomi/riferimenti delle funzioni per perf. (Si chiama Turbofan)</p><p>Il risultato è che potresti non ottenere i nomi delle tue funzioni correttamente nel flame graph.</p><p>Noterai <code>ByteCodeHandler:</code> dove ti aspetteresti i nomi delle funzioni.</p><p>0x ha alcune mitigazioni integrate per questo.</p><p>Per i dettagli, vedere:</p><ul><li><a href="https://github.com/nodejs/benchmarking/issues/168" target="_blank" rel="noreferrer">https://github.com/nodejs/benchmarking/issues/168</a></li><li><a href="https://github.com/nodejs/diagnostics/issues/148#issuecomment-369348961" target="_blank" rel="noreferrer">https://github.com/nodejs/diagnostics/issues/148#issuecomment-369348961</a></li></ul><h3 id="node-js-10" tabindex="-1">Node.js 10+ <a class="header-anchor" href="#node-js-10" aria-label="Permalink to “Node.js 10+”">​</a></h3><p>Node.js 10.x risolve il problema con Turbofan usando il flag <code>--interpreted-frames-native-stack</code>.</p><p>Esegui <code>node --interpreted-frames-native-stack --perf-basic-prof-only-functions</code> per ottenere i nomi delle funzioni nel flame graph indipendentemente da quale pipeline V8 ha utilizzato per compilare il tuo JavaScript.</p><h3 id="etichette-danneggiate-nel-flame-graph" tabindex="-1">Etichette danneggiate nel flame graph <a class="header-anchor" href="#etichette-danneggiate-nel-flame-graph" aria-label="Permalink to “Etichette danneggiate nel flame graph”">​</a></h3><p>Se vedi etichette simili a questa</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">node</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_ZN2v88internal11interpreter17BytecodeGenerator15VisitStatementsEPMS0_8Zone</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>significa che il Linux perf che stai usando non è stato compilato con il supporto demangle, vedi <a href="https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1396654" target="_blank" rel="noreferrer">https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1396654</a> per esempio</p><h2 id="esempi" tabindex="-1">Esempi <a class="header-anchor" href="#esempi" aria-label="Permalink to “Esempi”">​</a></h2><p>Esercitati a catturare flame graph da solo con un <a href="https://github.com/naugtur/node-example-flamegraph" target="_blank" rel="noreferrer">esercizio di flame graph</a>!</p>`,50)])}var s=e(a,[[`render`,o]]);export{i as __pageData,s as default};