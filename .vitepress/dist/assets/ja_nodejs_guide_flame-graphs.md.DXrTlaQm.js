import{__plugin_vue_export_helper_default as e,createElementBlock as t,createStaticVNode as n,openBlock as r}from"./chunks/plugin-vue_export-helper.Bts1mPc7.js";const i=JSON.parse(`{"title":"Node.js パフォーマンス最適化のためのフレイムグラフ","description":"関数に費やされた CPU 時間を視覚化し、Node.js のパフォーマンスを最適化するためのフレイムグラフの作成方法を学びます。","frontmatter":{"title":"Node.js パフォーマンス最適化のためのフレイムグラフ","description":"関数に費やされた CPU 時間を視覚化し、Node.js のパフォーマンスを最適化するためのフレイムグラフの作成方法を学びます。","head":[["meta",{"name":"og:title","content":"Node.js パフォーマンス最適化のためのフレイムグラフ | Node.js - iDoc.dev"}],["meta",{"name":"og:description","content":"関数に費やされた CPU 時間を視覚化し、Node.js のパフォーマンスを最適化するためのフレイムグラフの作成方法を学びます。"}],["meta",{"name":"twitter:title","content":"Node.js パフォーマンス最適化のためのフレイムグラフ | Node.js - iDoc.dev"}],["meta",{"name":"twitter:description","content":"関数に費やされた CPU 時間を視覚化し、Node.js のパフォーマンスを最適化するためのフレイムグラフの作成方法を学びます。"}],["link",{"rel":"canonical","href":"https://idoc.dev/ja/nodejs/guide/flame-graphs"}],["meta",{"property":"og:url","content":"https://idoc.dev/ja/nodejs/guide/flame-graphs"}]]},"headers":[],"relativePath":"ja/nodejs/guide/flame-graphs.md","filePath":"ja/nodejs/guide/flame-graphs.md","lastUpdated":null}`),a={name:`ja/nodejs/guide/flame-graphs.md`};function o(e,i,a,o,s,c){return r(),t(`div`,null,i[0]||=[n(`<h1 id="フレームグラフ" tabindex="-1">フレームグラフ <a class="header-anchor" href="#フレームグラフ" aria-label="Permalink to “フレームグラフ”">​</a></h1><h2 id="フレームグラフは何に役立つのか" tabindex="-1">フレームグラフは何に役立つのか？ <a class="header-anchor" href="#フレームグラフは何に役立つのか" aria-label="Permalink to “フレームグラフは何に役立つのか？”">​</a></h2><p>フレームグラフは、関数で消費されたCPU時間を可視化する方法です。同期操作に時間をかけすぎている箇所を特定するのに役立ちます。</p><h2 id="フレームグラフの作成方法" tabindex="-1">フレームグラフの作成方法 <a class="header-anchor" href="#フレームグラフの作成方法" aria-label="Permalink to “フレームグラフの作成方法”">​</a></h2><p>Node.jsのフレームグラフの作成は難しいと聞いたことがあるかもしれませんが、それは（もう）真実ではありません。Solaris VMはフレームグラフに必要なくなりました！</p><p>フレームグラフは<code>perf</code>の出力から生成されます。これはNode固有のツールではありません。CPU時間消費を可視化する最も強力な方法ですが、Node.js 8以降でJavaScriptコードが最適化される方法に問題がある可能性があります。以下の<a href="#perf-output-issues">perf出力の問題</a>セクションを参照してください。</p><h3 id="事前パッケージ化されたツールを使用する" tabindex="-1">事前パッケージ化されたツールを使用する <a class="header-anchor" href="#事前パッケージ化されたツールを使用する" aria-label="Permalink to “事前パッケージ化されたツールを使用する”">​</a></h3><p>ローカルでフレームグラフを生成する単一のステップが必要な場合は、<a href="https://www.npmjs.com/package/0x" target="_blank" rel="noreferrer">0x</a>を試してください。</p><p>本番環境のデプロイメントを診断するには、次のノートをお読みください：<a href="https://github.com/davidmarkclements/0x/blob/master/docs/production-servers.md" target="_blank" rel="noreferrer">0x production servers</a>。</p><h3 id="システムのperfツールでフレームグラフを作成する" tabindex="-1">システムのperfツールでフレームグラフを作成する <a class="header-anchor" href="#システムのperfツールでフレームグラフを作成する" aria-label="Permalink to “システムのperfツールでフレームグラフを作成する”">​</a></h3><p>このガイドの目的は、フレームグラフを作成する手順を示し、各ステップを制御できるようにすることです。</p><p>各ステップをよりよく理解したい場合は、詳細について説明する以下のセクションをご覧ください。</p><p>それでは、作業に取り掛かりましょう。</p><ol><li><code>perf</code>をインストールします（まだインストールされていない場合は、通常linux-tools-commonパッケージから入手できます）。</li><li><code>perf</code>の実行を試してください - カーネルモジュールがないというエラーが表示される場合があります。その場合は、それらもインストールしてください。</li><li>perfを有効にしてnodeを実行します（Node.jsのバージョンに固有のヒントについては、<a href="#perf-output-issues">perf出力の問題</a>を参照してください）。</li></ol><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">perf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> record</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cycles:u</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --perf-basic-prof</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app.js</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ol start="4"><li>パッケージがないためにperfを実行できないというエラーでない限り、警告は無視してください。カーネルモジュールサンプルにアクセスできないという警告が表示される場合がありますが、それは問題ありません。</li><li><code>perf script &gt; perfs.out</code>を実行して、後で可視化するデータファイルを生成します。より読みやすいグラフにするために、いくつかのクリーンアップを適用すると便利です。</li><li>まだインストールされていない場合は、stackvisをインストールします <code>npm i -g stackvis</code></li><li><code>stackvis perf &lt; perfs.out &gt; flamegraph.htm</code>を実行します。</li></ol><p>これで、お気に入りのブラウザでフレームグラフファイルを開き、燃える様子を見てください。色分けされているので、最も彩度の高いオレンジ色のバーに最初に焦点を当てることができます。それらはCPU負荷の高い関数を表している可能性があります。</p><p>言及する価値があること - フレームグラフの要素をクリックすると、その周囲の拡大図がグラフの上に表示されます。</p><h3 id="実行中のプロセスをサンプリングするために-perf-を使用する" tabindex="-1">実行中のプロセスをサンプリングするために <code>perf</code> を使用する <a class="header-anchor" href="#実行中のプロセスをサンプリングするために-perf-を使用する" aria-label="Permalink to “実行中のプロセスをサンプリングするために perf を使用する”">​</a></h3><p>これは、中断したくない既に実行中のプロセスからフレームグラフデータを記録するのに最適です。再現が難しい問題を抱えた本番プロセスを想像してみてください。</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">perf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> record</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -F99</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pgrep</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node\`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> --</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sleep</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><code>sleep 3</code> は何のためにあるのでしょうか？これは perf を実行し続けるためにあります。<code>-p</code> オプションが別の pid を指していても、コマンドはプロセスで実行され、そのプロセスで終了する必要があります。perf は、実際にそのコマンドをプロファイリングしているかどうかに関係なく、渡したコマンドのライフサイクルで実行されます。<code>sleep 3</code> は、perf が 3 秒間実行されるようにします。</p><p><code>-F</code>（プロファイリング頻度）が 99 に設定されているのはなぜですか？これは妥当なデフォルトです。必要に応じて調整できます。<code>-F99</code> は、perf に 1 秒あたり 99 サンプルを取得するように指示します。精度を高めるには、値を大きくします。値を小さくすると、出力が少なくなり、結果の精度が低下します。必要な精度は、CPU を集中的に使用する関数の実際の実行時間によって異なります。目に見える速度低下の原因を探している場合、1 秒あたり 99 フレームで十分すぎるはずです。</p><p>3 秒間の perf レコードを取得したら、上記の手順の最後の 2 つでフレームグラフを生成します。</p><h3 id="node-js-の内部関数をフィルタリングする" tabindex="-1">Node.js の内部関数をフィルタリングする <a class="header-anchor" href="#node-js-の内部関数をフィルタリングする" aria-label="Permalink to “Node.js の内部関数をフィルタリングする”">​</a></h3><p>通常、自分の呼び出しのパフォーマンスだけを見たいので、Node.js と V8 の内部関数をフィルタリングすると、グラフがはるかに読みやすくなります。perf ファイルは次のようにクリーンアップできます。</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sed</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -i</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -r</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/(_libc_start|LazyCompile) |v8::internal::BuiltIn|Stub|LoadIC:\\\\[\\\\[&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/^$/d&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    perf.data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> perf.out</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>フレームグラフを読んで、キーとなる関数がほとんどの時間を占めているのに何かが欠けているように見える場合は、フィルターなしでフレームグラフを生成してみてください。Node.js 自体の問題のまれなケースかもしれません。</p><h3 id="node-js-のプロファイリングオプション" tabindex="-1">Node.js のプロファイリングオプション <a class="header-anchor" href="#node-js-のプロファイリングオプション" aria-label="Permalink to “Node.js のプロファイリングオプション”">​</a></h3><p><code>--perf-basic-prof-only-functions</code> と <code>--perf-basic-prof</code> は、JavaScript コードをデバッグするのに役立つ 2 つのオプションです。他のオプションは Node.js 自体をプロファイリングするために使用されます。これは、このガイドの範囲外です。</p><p><code>--perf-basic-prof-only-functions</code> は、出力が少ないため、オーバーヘッドが最も少ないオプションです。</p><h3 id="なぜそれらが必要なのか" tabindex="-1">なぜそれらが必要なのか？ <a class="header-anchor" href="#なぜそれらが必要なのか" aria-label="Permalink to “なぜそれらが必要なのか？”">​</a></h3><p>これらのオプションがなければ、フレームグラフは生成されますが、ほとんどのバーには <code>v8::Function::Call</code> と表示されます。</p><h2 id="perf-の出力に関する問題" tabindex="-1"><code>Perf</code> の出力に関する問題 <a class="header-anchor" href="#perf-の出力に関する問題" aria-label="Permalink to “Perf の出力に関する問題”">​</a></h2><h3 id="node-js-8-x-v8-パイプラインの変更" tabindex="-1">Node.js 8.x V8 パイプラインの変更 <a class="header-anchor" href="#node-js-8-x-v8-パイプラインの変更" aria-label="Permalink to “Node.js 8.x V8 パイプラインの変更”">​</a></h3><p>Node.js 8.x 以降には、V8 エンジンの JavaScript コンパイルパイプラインに新しい最適化が組み込まれており、perf では関数名/参照に到達できない場合があります。（これは Turbofan と呼ばれます）</p><p>その結果、フレームグラフで関数名が正しく取得できない可能性があります。</p><p>関数名が表示されるはずの場所に <code>ByteCodeHandler:</code> が表示されることに気づくでしょう。</p><p>0x にはそのための軽減策が組み込まれています。</p><p>詳細については、以下を参照してください。</p><ul><li><a href="https://github.com/nodejs/benchmarking/issues/168" target="_blank" rel="noreferrer">https://github.com/nodejs/benchmarking/issues/168</a></li><li><a href="https://github.com/nodejs/diagnostics/issues/148#issuecomment-369348961" target="_blank" rel="noreferrer">https://github.com/nodejs/diagnostics/issues/148#issuecomment-369348961</a></li></ul><h3 id="node-js-10" tabindex="-1">Node.js 10+ <a class="header-anchor" href="#node-js-10" aria-label="Permalink to “Node.js 10+”">​</a></h3><p>Node.js 10.x では、<code>--interpreted-frames-native-stack</code> フラグを使用して Turbofan の問題に対処しています。</p><p><code>node --interpreted-frames-native-stack --perf-basic-prof-only-functions</code> を実行すると、V8 がどのパイプラインを使用して JavaScript をコンパイルしたかに関係なく、フレームグラフに関数名が表示されます。</p><h3 id="フレームグラフ内の壊れたラベル" tabindex="-1">フレームグラフ内の壊れたラベル <a class="header-anchor" href="#フレームグラフ内の壊れたラベル" aria-label="Permalink to “フレームグラフ内の壊れたラベル”">​</a></h3><p>次のようなラベルが表示される場合</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">node</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_ZN2v88internal11interpreter17BytecodeGenerator15VisitStatementsEPMS0_8Zone</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>これは、使用している Linux perf がデマングルサポート付きでコンパイルされていないことを意味します。たとえば、<a href="https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1396654" target="_blank" rel="noreferrer">https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1396654</a> を参照してください。</p><h2 id="例" tabindex="-1">例 <a class="header-anchor" href="#例" aria-label="Permalink to “例”">​</a></h2><p><a href="https://github.com/naugtur/node-example-flamegraph" target="_blank" rel="noreferrer">フレームグラフ演習</a>で、フレームグラフの取得を練習しましょう！</p>`,50)])}var s=e(a,[[`render`,o]]);export{i as __pageData,s as default};