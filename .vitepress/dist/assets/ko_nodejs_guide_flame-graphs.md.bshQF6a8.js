import{__plugin_vue_export_helper_default as e,createElementBlock as t,createStaticVNode as n,openBlock as r}from"./chunks/plugin-vue_export-helper.Bts1mPc7.js";const i=JSON.parse(`{"title":"Node.js 성능 최적화의 플레임 그래프","description":"함수에 소요된 CPU 시간을 시각화하고 Node.js 성능을 최적화하는 플레임 그래프를 생성하는 방법을 알아보십시오.","frontmatter":{"title":"Node.js 성능 최적화의 플레임 그래프","description":"함수에 소요된 CPU 시간을 시각화하고 Node.js 성능을 최적화하는 플레임 그래프를 생성하는 방법을 알아보십시오.","head":[["meta",{"name":"og:title","content":"Node.js 성능 최적화의 플레임 그래프 | Node.js - iDoc.dev"}],["meta",{"name":"og:description","content":"함수에 소요된 CPU 시간을 시각화하고 Node.js 성능을 최적화하는 플레임 그래프를 생성하는 방법을 알아보십시오."}],["meta",{"name":"twitter:title","content":"Node.js 성능 최적화의 플레임 그래프 | Node.js - iDoc.dev"}],["meta",{"name":"twitter:description","content":"함수에 소요된 CPU 시간을 시각화하고 Node.js 성능을 최적화하는 플레임 그래프를 생성하는 방법을 알아보십시오."}],["link",{"rel":"canonical","href":"https://idoc.dev/ko/nodejs/guide/flame-graphs"}],["meta",{"property":"og:url","content":"https://idoc.dev/ko/nodejs/guide/flame-graphs"}]]},"headers":[],"relativePath":"ko/nodejs/guide/flame-graphs.md","filePath":"ko/nodejs/guide/flame-graphs.md","lastUpdated":null}`),a={name:`ko/nodejs/guide/flame-graphs.md`};function o(e,i,a,o,s,c){return r(),t(`div`,null,i[0]||=[n(`<h1 id="flame-graphs" tabindex="-1">Flame Graphs <a class="header-anchor" href="#flame-graphs" aria-label="Permalink to “Flame Graphs”">​</a></h1><h2 id="flame-그래프는-무엇에-유용한가요" tabindex="-1">Flame 그래프는 무엇에 유용한가요? <a class="header-anchor" href="#flame-그래프는-무엇에-유용한가요" aria-label="Permalink to “Flame 그래프는 무엇에 유용한가요?”">​</a></h2><p>Flame 그래프는 함수에서 소비된 CPU 시간을 시각화하는 방법입니다. 동기 작업에 너무 많은 시간을 소비하는 위치를 파악하는 데 도움이 될 수 있습니다.</p><h2 id="flame-그래프를-만드는-방법" tabindex="-1">Flame 그래프를 만드는 방법 <a class="header-anchor" href="#flame-그래프를-만드는-방법" aria-label="Permalink to “Flame 그래프를 만드는 방법”">​</a></h2><p>Node.js에 대한 Flame 그래프를 만드는 것이 어렵다고 들었을 수도 있지만, 더 이상 그렇지 않습니다. Flame 그래프에 Solaris VM이 더 이상 필요하지 않습니다!</p><p>Flame 그래프는 노드 특정 도구가 아닌 <code>perf</code> 출력에서 생성됩니다. CPU 시간 소비를 시각화하는 가장 강력한 방법이지만, Node.js 8 이상에서 JavaScript 코드가 최적화되는 방식에 문제가 있을 수 있습니다. 아래의 <a href="#perf-output-issues">perf 출력 문제</a> 섹션을 참조하십시오.</p><h3 id="미리-패키지된-도구-사용" tabindex="-1">미리 패키지된 도구 사용 <a class="header-anchor" href="#미리-패키지된-도구-사용" aria-label="Permalink to “미리 패키지된 도구 사용”">​</a></h3><p>Flame 그래프를 로컬에서 생성하는 단일 단계를 원한다면 <a href="https://www.npmjs.com/package/0x" target="_blank" rel="noreferrer">0x</a>를 사용해 보세요.</p><p>프로덕션 배포를 진단하려면 다음 참고 사항을 읽어보십시오. <a href="https://github.com/davidmarkclements/0x/blob/master/docs/production-servers.md" target="_blank" rel="noreferrer">0x 프로덕션 서버</a>.</p><h3 id="시스템-perf-도구로-flame-그래프-만들기" tabindex="-1">시스템 perf 도구로 Flame 그래프 만들기 <a class="header-anchor" href="#시스템-perf-도구로-flame-그래프-만들기" aria-label="Permalink to “시스템 perf 도구로 Flame 그래프 만들기”">​</a></h3><p>이 가이드의 목적은 Flame 그래프를 만드는 데 관련된 단계를 보여주고 각 단계를 제어할 수 있도록 하는 것입니다.</p><p>각 단계를 더 잘 이해하고 싶다면, 더 자세히 살펴보는 다음 섹션을 참조하십시오.</p><p>이제 시작해 보겠습니다.</p><ol><li><code>perf</code>를 설치합니다 (아직 설치되지 않은 경우 일반적으로 linux-tools-common 패키지를 통해 사용 가능).</li><li><code>perf</code>를 실행해 보십시오. 누락된 커널 모듈에 대한 불만이 발생할 수 있으며, 이 경우 해당 모듈도 설치합니다.</li><li>perf가 활성화된 상태로 노드를 실행합니다 (Node.js 버전에 특정한 팁은 <a href="#perf-output-issues">perf 출력 문제</a> 참조).</li></ol><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">perf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> record</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cycles:u</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --perf-basic-prof</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app.js</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ol start="4"><li>누락된 패키지 때문에 perf를 실행할 수 없다는 경고가 아니면 무시하십시오. 커널 모듈 샘플에 액세스할 수 없다는 경고가 발생할 수 있지만, 이는 어쨌든 필요하지 않습니다.</li><li><code>perf script &gt; perfs.out</code>를 실행하여 잠시 후 시각화할 데이터 파일을 생성합니다. 더 읽기 쉬운 그래프를 위해 약간의 정리를 적용하는 것이 유용합니다.</li><li>stackvis가 아직 설치되지 않았다면 <code>npm i -g stackvis</code>를 설치합니다.</li><li><code>stackvis perf &lt; perfs.out &gt; flamegraph.htm</code>를 실행합니다.</li></ol><p>이제 좋아하는 브라우저에서 Flame 그래프 파일을 열고 타오르는 것을 지켜보십시오. 색상으로 구분되어 있으므로 가장 채도가 높은 주황색 막대에 먼저 집중할 수 있습니다. 이는 CPU를 많이 사용하는 함수를 나타낼 가능성이 높습니다.</p><p>언급할 가치가 있는 점은 Flame 그래프의 요소를 클릭하면 그래프 위에 해당 주변 환경이 확대되어 표시됩니다.</p><h3 id="perf를-사용하여-실행-중인-프로세스-샘플링하기" tabindex="-1"><code>perf</code>를 사용하여 실행 중인 프로세스 샘플링하기 <a class="header-anchor" href="#perf를-사용하여-실행-중인-프로세스-샘플링하기" aria-label="Permalink to “perf를 사용하여 실행 중인 프로세스 샘플링하기”">​</a></h3><p>이는 중단하고 싶지 않은 이미 실행 중인 프로세스에서 플레임 그래프 데이터를 기록하는 데 유용합니다. 재현하기 어려운 문제가 있는 프로덕션 프로세스를 상상해 보세요.</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">perf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> record</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -F99</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pgrep</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node\`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> --</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sleep</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>저 <code>sleep 3</code>은 무엇을 위한 것일까요? <code>-p</code> 옵션이 다른 PID를 가리키더라도 perf를 계속 실행하기 위한 것입니다. 명령은 프로세스에서 실행되어 종료되어야 합니다. perf는 실제로 해당 명령을 프로파일링하는지 여부에 관계없이 전달하는 명령의 수명 동안 실행됩니다. <code>sleep 3</code>은 perf가 3초 동안 실행되도록 합니다.</p><p><code>-F</code>(프로파일링 빈도)가 99로 설정된 이유는 무엇일까요? 합리적인 기본값입니다. 원하는 경우 조정할 수 있습니다. <code>-F99</code>는 perf에 초당 99개의 샘플을 가져오도록 지시합니다. 더 정확하게 하려면 값을 늘립니다. 값이 낮을수록 덜 정확한 결과로 출력이 줄어듭니다. 필요한 정확도는 CPU 집약적인 함수가 실제로 얼마나 오래 실행되는지에 따라 다릅니다. 눈에 띄는 속도 저하의 원인을 찾고 있다면 초당 99프레임이면 충분할 것입니다.</p><p>3초 perf 레코드를 얻은 후 위의 마지막 두 단계를 통해 플레임 그래프를 생성합니다.</p><h3 id="node-js-내부-함수-필터링" tabindex="-1">Node.js 내부 함수 필터링 <a class="header-anchor" href="#node-js-내부-함수-필터링" aria-label="Permalink to “Node.js 내부 함수 필터링”">​</a></h3><p>일반적으로 호출 성능만 확인하고 싶으므로 Node.js 및 V8 내부 함수를 필터링하면 그래프를 훨씬 쉽게 읽을 수 있습니다. 다음을 사용하여 perf 파일을 정리할 수 있습니다.</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sed</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -i</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -r</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/(_libc_start|LazyCompile) |v8::internal::BuiltIn|Stub|LoadIC:\\\\[\\\\[&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/^$/d&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    perf.data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> perf.out</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>플레임 그래프를 읽었는데 이상해 보이고 대부분의 시간을 차지하는 키 함수에서 무언가가 누락된 것처럼 보이면 필터 없이 플레임 그래프를 생성해 보세요. Node.js 자체에 문제가 있는 드문 경우가 있을 수 있습니다.</p><h3 id="node-js의-프로파일링-옵션" tabindex="-1">Node.js의 프로파일링 옵션 <a class="header-anchor" href="#node-js의-프로파일링-옵션" aria-label="Permalink to “Node.js의 프로파일링 옵션”">​</a></h3><p><code>--perf-basic-prof-only-functions</code> 및 <code>--perf-basic-prof</code>는 JavaScript 코드를 디버깅하는 데 유용한 두 가지 옵션입니다. 다른 옵션은 Node.js 자체를 프로파일링하는 데 사용되며 이 가이드의 범위를 벗어납니다.</p><p><code>--perf-basic-prof-only-functions</code>는 출력이 적으므로 오버헤드가 가장 적은 옵션입니다.</p><h3 id="왜-필요한가" tabindex="-1">왜 필요한가? <a class="header-anchor" href="#왜-필요한가" aria-label="Permalink to “왜 필요한가?”">​</a></h3><p>이 옵션이 없으면 플레임 그래프를 얻을 수 있지만 대부분의 막대가 <code>v8::Function::Call</code>로 표시됩니다.</p><h2 id="perf-출력-문제" tabindex="-1"><code>Perf</code> 출력 문제 <a class="header-anchor" href="#perf-출력-문제" aria-label="Permalink to “Perf 출력 문제”">​</a></h2><h3 id="node-js-8-x-v8-파이프라인-변경" tabindex="-1">Node.js 8.x V8 파이프라인 변경 <a class="header-anchor" href="#node-js-8-x-v8-파이프라인-변경" aria-label="Permalink to “Node.js 8.x V8 파이프라인 변경”">​</a></h3><p>Node.js 8.x 이상은 V8 엔진의 JavaScript 컴파일 파이프라인에 대한 새로운 최적화를 제공하므로 perf에서 함수 이름/참조에 접근할 수 없는 경우가 있습니다. (Turbofan이라고 합니다)</p><p>결과적으로 플레임 그래프에서 함수 이름을 올바르게 얻지 못할 수 있습니다.</p><p>함수 이름이 예상되는 위치에 <code>ByteCodeHandler:</code>가 표시됩니다.</p><p>0x에는 이를 완화하기 위한 몇 가지 기능이 내장되어 있습니다.</p><p>자세한 내용은 다음을 참조하십시오.</p><ul><li><a href="https://github.com/nodejs/benchmarking/issues/168" target="_blank" rel="noreferrer">https://github.com/nodejs/benchmarking/issues/168</a></li><li><a href="https://github.com/nodejs/diagnostics/issues/148#issuecomment-369348961" target="_blank" rel="noreferrer">https://github.com/nodejs/diagnostics/issues/148#issuecomment-369348961</a></li></ul><h3 id="node-js-10" tabindex="-1">Node.js 10+ <a class="header-anchor" href="#node-js-10" aria-label="Permalink to “Node.js 10+”">​</a></h3><p>Node.js 10.x는 <code>--interpreted-frames-native-stack</code> 플래그를 사용하여 Turbofan 문제를 해결합니다.</p><p><code>node --interpreted-frames-native-stack --perf-basic-prof-only-functions</code>를 실행하여 V8이 JavaScript를 컴파일하는 데 어떤 파이프라인을 사용했는지에 관계없이 플레임 그래프에서 함수 이름을 가져옵니다.</p><h3 id="플레임-그래프의-손상된-레이블" tabindex="-1">플레임 그래프의 손상된 레이블 <a class="header-anchor" href="#플레임-그래프의-손상된-레이블" aria-label="Permalink to “플레임 그래프의 손상된 레이블”">​</a></h3><p>다음과 같은 레이블이 보이는 경우</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">node</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_ZN2v88internal11interpreter17BytecodeGenerator15VisitStatementsEPMS0_8Zone</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>이는 사용 중인 Linux perf가 demangle 지원으로 컴파일되지 않았음을 의미합니다. 예를 들어 <a href="https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1396654" target="_blank" rel="noreferrer">https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1396654</a>를 참조하십시오.</p><h2 id="예제" tabindex="-1">예제 <a class="header-anchor" href="#예제" aria-label="Permalink to “예제”">​</a></h2><p><a href="https://github.com/naugtur/node-example-flamegraph" target="_blank" rel="noreferrer">플레임 그래프 연습</a>으로 플레임 그래프를 직접 캡처하는 연습을 해보세요!</p>`,50)])}var s=e(a,[[`render`,o]]);export{i as __pageData,s as default};