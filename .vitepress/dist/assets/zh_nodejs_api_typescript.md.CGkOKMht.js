import{__plugin_vue_export_helper_default as e,createElementBlock as t,createStaticVNode as n,openBlock as r}from"./chunks/plugin-vue_export-helper.Bts1mPc7.js";const i=JSON.parse(`{"title":"Node.js 中的 TypeScript 支持","description":"了解如何在 Node.js 中使用 TypeScript，包括安装、配置以及将 TypeScript 集成到 Node.js 项目中的最佳实践。","frontmatter":{"title":"Node.js 中的 TypeScript 支持","description":"了解如何在 Node.js 中使用 TypeScript，包括安装、配置以及将 TypeScript 集成到 Node.js 项目中的最佳实践。","head":[["meta",{"name":"og:title","content":"Node.js 中的 TypeScript 支持 | Node.js - iDoc.dev"}],["meta",{"name":"og:description","content":"了解如何在 Node.js 中使用 TypeScript，包括安装、配置以及将 TypeScript 集成到 Node.js 项目中的最佳实践。"}],["meta",{"name":"twitter:title","content":"Node.js 中的 TypeScript 支持 | Node.js - iDoc.dev"}],["meta",{"name":"twitter:description","content":"了解如何在 Node.js 中使用 TypeScript，包括安装、配置以及将 TypeScript 集成到 Node.js 项目中的最佳实践。"}],["link",{"rel":"canonical","href":"https://idoc.dev/zh/nodejs/api/typescript"}],["meta",{"property":"og:url","content":"https://idoc.dev/zh/nodejs/api/typescript"}]]},"headers":[],"relativePath":"zh/nodejs/api/typescript.md","filePath":"zh/nodejs/api/typescript.md","lastUpdated":null}`),a={name:`zh/nodejs/api/typescript.md`};function o(e,i,a,o,s,c){return r(),t(`div`,null,i[0]||=[n(`<h1 id="modules-typescript" tabindex="-1">模块：TypeScript <a class="header-anchor" href="#modules-typescript" aria-label="Permalink to “模块：TypeScript”">​</a></h1><div class="info custom-block"><p class="custom-block-title">[历史]</p><table tabindex="0"><thead><tr><th>版本</th><th>变更</th></tr></thead><tbody><tr><td>v22.7.0</td><td>添加了 <code>--experimental-transform-types</code> 标志。</td></tr></tbody></table></div><div class="warning custom-block"><p class="custom-block-title">[稳定度: 1 - 实验性]</p><p><a href="/zh/nodejs/api/documentation#stability-index">稳定度: 1</a> <a href="/zh/nodejs/api/documentation#stability-index">稳定性: 1</a>.1 - 活跃开发</p></div><h2 id="enabling" tabindex="-1">启用 <a class="header-anchor" href="#enabling" aria-label="Permalink to “启用”">​</a></h2><p>有两种方法可以在 Node.js 中启用运行时 TypeScript 支持：</p><h2 id="full-typescript-support" tabindex="-1">完整的 TypeScript 支持 <a class="header-anchor" href="#full-typescript-support" aria-label="Permalink to “完整的 TypeScript 支持”">​</a></h2><p>要使用 TypeScript 并完全支持所有 TypeScript 功能，包括 <code>tsconfig.json</code>，您可以使用第三方包。 以下说明以 <a href="https://tsx.is/" target="_blank" rel="noreferrer"><code>tsx</code></a> 为例，但还有许多其他类似的库可用。</p><h2 id="type-stripping" tabindex="-1">类型剥离 <a class="header-anchor" href="#type-stripping" aria-label="Permalink to “类型剥离”">​</a></h2><p><strong>添加于: v22.6.0</strong></p><div class="warning custom-block"><p class="custom-block-title">[稳定度: 1 - 实验性]</p><p><a href="/zh/nodejs/api/documentation#stability-index">稳定度: 1</a> <a href="/zh/nodejs/api/documentation#stability-index">稳定性: 1</a>.1 - 活跃开发</p></div><p>标志 <a href="/zh/nodejs/api/cli#experimental-strip-types"><code>--experimental-strip-types</code></a> 允许 Node.js 运行 TypeScript 文件。 默认情况下，Node.js 将仅执行不包含需要转换的 TypeScript 功能（例如枚举或命名空间）的文件。 Node.js 会将内联类型注解替换为空格，并且不执行类型检查。 要启用此类功能的转换，请使用标志 <a href="/zh/nodejs/api/cli#experimental-transform-types"><code>--experimental-transform-types</code></a>。 依赖于 <code>tsconfig.json</code> 中设置的 TypeScript 功能（例如路径或将较新的 JavaScript 语法转换为较旧的标准）是不支持的。 要获得完整的 TypeScript 支持，请参阅 <a href="/zh/nodejs/api/typescript#full-typescript-support">完整的 TypeScript 支持</a>。</p><p>类型剥离功能旨在轻量化。 通过故意不支持需要 JavaScript 代码生成器语法，并通过将内联类型替换为空格，Node.js 可以在不需要 source map 的情况下运行 TypeScript 代码。</p><p>类型剥离适用于大多数 TypeScript 版本，但我们建议使用 5.7 或更高版本，并具有以下 <code>tsconfig.json</code> 设置：</p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;compilerOptions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     &quot;target&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;esnext&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     &quot;module&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;nodenext&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     &quot;allowImportingTsExtensions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     &quot;rewriteRelativeImportExtensions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     &quot;verbatimModuleSyntax&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="determining-module-system" tabindex="-1">确定模块系统 <a class="header-anchor" href="#determining-module-system" aria-label="Permalink to “确定模块系统”">​</a></h3><p>Node.js 在 TypeScript 文件中同时支持 <a href="/zh/nodejs/api/modules">CommonJS</a> 和 <a href="/zh/nodejs/api/esm">ES Modules</a> 语法。 Node.js 不会从一个模块系统转换为另一个模块系统； 如果您希望您的代码作为 ES 模块运行，则必须使用 <code>import</code> 和 <code>export</code> 语法，如果您希望您的代码作为 CommonJS 运行，则必须使用 <code>require</code> 和 <code>module.exports</code>。</p><ul><li><code>.ts</code> 文件的模块系统将以<a href="/zh/nodejs/api/packages#determining-module-system">与 <code>.js</code> 文件相同的方式确定。</a> 要使用 <code>import</code> 和 <code>export</code> 语法，请将 <code>&quot;type&quot;: &quot;module&quot;</code> 添加到最近的父 <code>package.json</code> 文件中。</li><li><code>.mts</code> 文件将始终作为 ES 模块运行，类似于 <code>.mjs</code> 文件。</li><li><code>.cts</code> 文件将始终作为 CommonJS 模块运行，类似于 <code>.cjs</code> 文件。</li><li>不支持 <code>.tsx</code> 文件。</li></ul><p>与 JavaScript 文件一样，<code>import</code> 语句和 <code>import()</code> 表达式中<a href="/zh/nodejs/api/esm#mandatory-file-extensions">文件扩展名是强制性的</a>：<code>import &#39;./file.ts&#39;</code>，而不是 <code>import &#39;./file&#39;</code>。 由于向后兼容性，<code>require()</code> 调用中文件扩展名也是强制性的：<code>require(&#39;./file.ts&#39;)</code>，而不是 <code>require(&#39;./file&#39;)</code>，类似于 <code>.cjs</code> 扩展名在 CommonJS 文件中的 <code>require</code> 调用中是强制性的。</p><p><code>tsconfig.json</code> 选项 <code>allowImportingTsExtensions</code> 将允许 TypeScript 编译器 <code>tsc</code> 对具有包含 <code>.ts</code> 扩展名的 <code>import</code> 说明符的文件进行类型检查。</p><h3 id="typescript-features" tabindex="-1">TypeScript 功能 <a class="header-anchor" href="#typescript-features" aria-label="Permalink to “TypeScript 功能”">​</a></h3><p>由于 Node.js 仅删除内联类型，因此任何涉及<em>替换</em> TypeScript 语法为新的 JavaScript 语法的 TypeScript 功能都会出错，除非传递标志 <a href="/zh/nodejs/api/cli#experimental-transform-types"><code>--experimental-transform-types</code></a>。</p><p>最突出的需要转换的功能是：</p><ul><li><code>Enum</code></li><li><code>namespaces</code></li><li><code>legacy module</code></li><li>parameter properties</li></ul><p>由于装饰器目前是一个 <a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="noreferrer">TC39 Stage 3 提案</a> 并且很快将被 JavaScript 引擎支持，因此它们不会被转换，并且会导致解析器错误。 这是一个临时的限制，将来会被解决。</p><p>此外，Node.js 不读取 <code>tsconfig.json</code> 文件，也不支持依赖于 <code>tsconfig.json</code> 中设置的功能，例如路径或将较新的 JavaScript 语法转换为较旧的标准。</p><h3 id="importing-types-without-type-keyword" tabindex="-1">不使用 <code>type</code> 关键字导入类型 <a class="header-anchor" href="#importing-types-without-type-keyword" aria-label="Permalink to “不使用 type 关键字导入类型”">​</a></h3><p>由于类型删除的特性，<code>type</code> 关键字对于正确删除类型导入是必要的。如果没有 <code>type</code> 关键字，Node.js 会将导入视为值导入，这将导致运行时错误。tsconfig 选项 <a href="https://www.typescriptlang.org/tsconfig/#verbatimModuleSyntax" target="_blank" rel="noreferrer"><code>verbatimModuleSyntax</code></a> 可以用于匹配此行为。</p><p>这个例子可以正常工作：</p><div class="language-ts line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Type1, Type2 } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./module.ts&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { fn, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> FnParams } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./fn.ts&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这会导致运行时错误：</p><div class="language-ts line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Type1, Type2 } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./module.ts&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { fn, FnParams } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./fn.ts&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="non-file-forms-of-input" tabindex="-1">非文件形式的输入 <a class="header-anchor" href="#non-file-forms-of-input" aria-label="Permalink to “非文件形式的输入”">​</a></h3><p>类型删除可以为 <code>--eval</code> 启用。模块系统将由 <code>--input-type</code> 确定，就像 JavaScript 一样。</p><p>TypeScript 语法在 REPL、STDIN 输入、<code>--print</code>、<code>--check</code> 和 <code>inspect</code> 中不受支持。</p><h3 id="source-maps" tabindex="-1">源码映射 <a class="header-anchor" href="#source-maps" aria-label="Permalink to “源码映射”">​</a></h3><p>由于内联类型被空格替换，因此源码映射对于堆栈跟踪中的正确行号是不必要的；并且 Node.js 不会生成它们。当启用 <a href="/zh/nodejs/api/cli#experimental-transform-types"><code>--experimental-transform-types</code></a> 时，默认情况下会启用源码映射。</p><h3 id="type-stripping-in-dependencies" tabindex="-1">依赖项中的类型删除 <a class="header-anchor" href="#type-stripping-in-dependencies" aria-label="Permalink to “依赖项中的类型删除”">​</a></h3><p>为了阻止包作者发布用 TypeScript 编写的包，Node.js 默认情况下会拒绝处理 <code>node_modules</code> 路径下文件夹中的 TypeScript 文件。</p><h3 id="paths-aliases" tabindex="-1">路径别名 <a class="header-anchor" href="#paths-aliases" aria-label="Permalink to “路径别名”">​</a></h3><p><a href="https://www.typescriptlang.org/tsconfig/#paths" target="_blank" rel="noreferrer"><code>tsconfig</code> &quot;paths&quot;</a> 不会被转换，因此会产生错误。可用的最接近的特性是 <a href="/zh/nodejs/api/packages#subpath-imports">子路径导入</a>，但限制是它们需要以 <code>#</code> 开头。</p>`,40)])}var s=e(a,[[`render`,o]]);export{i as __pageData,s as default};