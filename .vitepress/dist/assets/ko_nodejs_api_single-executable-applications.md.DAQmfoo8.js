import{__plugin_vue_export_helper_default as e,createElementBlock as t,createStaticVNode as n,openBlock as r}from"./chunks/plugin-vue_export-helper.Bts1mPc7.js";const i=JSON.parse(`{"title":"Node.js 단일 실행 가능 애플리케이션","description":"Node.js를 사용하여 단일 실행 가능 애플리케이션을 생성하고 관리하는 방법을 배우세요. 애플리케이션 번들링, 의존성 관리 및 보안 고려 사항을 포함합니다.","frontmatter":{"title":"Node.js 단일 실행 가능 애플리케이션","description":"Node.js를 사용하여 단일 실행 가능 애플리케이션을 생성하고 관리하는 방법을 배우세요. 애플리케이션 번들링, 의존성 관리 및 보안 고려 사항을 포함합니다.","head":[["meta",{"name":"og:title","content":"Node.js 단일 실행 가능 애플리케이션 | Node.js - iDoc.dev"}],["meta",{"name":"og:description","content":"Node.js를 사용하여 단일 실행 가능 애플리케이션을 생성하고 관리하는 방법을 배우세요. 애플리케이션 번들링, 의존성 관리 및 보안 고려 사항을 포함합니다."}],["meta",{"name":"twitter:title","content":"Node.js 단일 실행 가능 애플리케이션 | Node.js - iDoc.dev"}],["meta",{"name":"twitter:description","content":"Node.js를 사용하여 단일 실행 가능 애플리케이션을 생성하고 관리하는 방법을 배우세요. 애플리케이션 번들링, 의존성 관리 및 보안 고려 사항을 포함합니다."}],["link",{"rel":"canonical","href":"https://idoc.dev/ko/nodejs/api/single-executable-applications"}],["meta",{"property":"og:url","content":"https://idoc.dev/ko/nodejs/api/single-executable-applications"}]]},"headers":[],"relativePath":"ko/nodejs/api/single-executable-applications.md","filePath":"ko/nodejs/api/single-executable-applications.md","lastUpdated":1749464498000}`),a={name:`ko/nodejs/api/single-executable-applications.md`};function o(e,i,a,o,s,c){return r(),t(`div`,null,i[0]||=[n(`<h1 id="single-executable-applications" tabindex="-1">단일 실행 파일 애플리케이션 <a class="header-anchor" href="#single-executable-applications" aria-label="Permalink to “단일 실행 파일 애플리케이션”">​</a></h1><div class="info custom-block"><p class="custom-block-title">[기록]</p><table tabindex="0"><thead><tr><th>버전</th><th>변경 사항</th></tr></thead><tbody><tr><td>v20.6.0</td><td>&quot;useSnapshot&quot; 지원 추가.</td></tr><tr><td>v20.6.0</td><td>&quot;useCodeCache&quot; 지원 추가.</td></tr><tr><td>v19.7.0, v18.16.0</td><td>다음 버전에서 추가됨: v19.7.0, v18.16.0</td></tr></tbody></table></div><div class="warning custom-block"><p class="custom-block-title">[안정성: 1 - 실험적]</p><p><a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a> <a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a>.1 - 활발한 개발</p></div><p><strong>소스 코드:</strong> <a href="https://github.com/nodejs/node/blob/v23.5.0/src/node_sea.cc" target="_blank" rel="noreferrer">src/node_sea.cc</a></p><p>이 기능은 Node.js가 설치되지 않은 시스템에 Node.js 애플리케이션을 편리하게 배포할 수 있도록 합니다.</p><p>Node.js는 번들된 스크립트를 포함할 수 있는 Node.js에서 준비한 Blob을 <code>node</code> 바이너리에 삽입할 수 있도록 하여 <a href="https://github.com/nodejs/single-executable" target="_blank" rel="noreferrer">단일 실행 파일 애플리케이션</a> 생성을 지원합니다. 시작 시 프로그램은 삽입된 내용이 있는지 확인합니다. Blob이 발견되면 Blob의 스크립트를 실행합니다. 그렇지 않으면 Node.js는 정상적으로 작동합니다.</p><p>단일 실행 파일 애플리케이션 기능은 현재 <a href="/ko/nodejs/api/modules#modules-commonjs-modules">CommonJS</a> 모듈 시스템을 사용하여 단일 임베디드 스크립트 실행만 지원합니다.</p><p>사용자는 <code>node</code> 바이너리 자체와 바이너리에 리소스를 삽입할 수 있는 도구를 사용하여 번들된 스크립트에서 단일 실행 파일 애플리케이션을 만들 수 있습니다.</p><p>다음은 <a href="https://github.com/nodejs/postject" target="_blank" rel="noreferrer">postject</a>와 같은 도구를 사용하여 단일 실행 파일 애플리케이션을 만드는 단계입니다.</p><h2 id="generating-single-executable-preparation-blobs" tabindex="-1">단일 실행 파일 준비 Blob 생성 <a class="header-anchor" href="#generating-single-executable-preparation-blobs" aria-label="Permalink to “단일 실행 파일 준비 Blob 생성”">​</a></h2><p>애플리케이션에 삽입되는 단일 실행 파일 준비 Blob은 단일 실행 파일을 빌드하는 데 사용될 Node.js 바이너리의 <code>--experimental-sea-config</code> 플래그를 사용하여 생성할 수 있습니다. 이 플래그는 JSON 형식의 구성 파일 경로를 사용합니다. 전달된 경로가 절대 경로가 아니면 Node.js는 현재 작업 디렉터리를 기준으로 경로를 사용합니다.</p><p>현재 구성은 다음과 같은 최상위 필드를 읽습니다.</p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;main&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/path/to/bundled/script.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;output&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/path/to/write/the/generated/blob.blob&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;disableExperimentalSEAWarning&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 기본값: false</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;useSnapshot&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 기본값: false</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;useCodeCache&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 기본값: false</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;assets&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 선택 사항</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;a.dat&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/path/to/a.dat&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;b.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/path/to/b.txt&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>경로가 절대 경로가 아니면 Node.js는 현재 작업 디렉터리를 기준으로 경로를 사용합니다. Blob을 생성하는 데 사용된 Node.js 바이너리의 버전은 Blob이 삽입될 바이너리의 버전과 동일해야 합니다.</p><p>참고: 교차 플랫폼 SEA를 생성할 때(예: <code>darwin-arm64</code>에서 <code>linux-x64</code>용 SEA 생성), 호환되지 않는 실행 파일 생성을 방지하려면 <code>useCodeCache</code> 및 <code>useSnapshot</code>을 false로 설정해야 합니다. 코드 캐시와 스냅샷은 컴파일된 동일한 플랫폼에서만 로드할 수 있으므로 생성된 실행 파일은 다른 플랫폼에서 빌드된 코드 캐시 또는 스냅샷을 로드하려고 할 때 시작 시 충돌할 수 있습니다.</p><h3 id="assets" tabindex="-1">에셋 <a class="header-anchor" href="#assets" aria-label="Permalink to “에셋”">​</a></h3><p>사용자는 <code>assets</code> 필드로 키-경로 사전을 구성에 추가하여 에셋을 포함할 수 있습니다. 빌드 시 Node.js는 지정된 경로에서 에셋을 읽어 준비 Blob에 번들로 묶습니다. 생성된 실행 파일에서 사용자는 <a href="/ko/nodejs/api/single-executable-applications#seagetassetkey-encoding"><code>sea.getAsset()</code></a> 및 <a href="/ko/nodejs/api/single-executable-applications#seagetassetasblobkey-options"><code>sea.getAssetAsBlob()</code></a> API를 사용하여 에셋을 검색할 수 있습니다.</p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;main&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/path/to/bundled/script.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;output&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/path/to/write/the/generated/blob.blob&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;assets&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;a.jpg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/path/to/a.jpg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;b.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/path/to/b.txt&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>단일 실행 파일 애플리케이션은 다음과 같이 에셋에 액세스할 수 있습니다.</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getAsset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getAssetAsBlob</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getRawAsset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;node:sea&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ArrayBuffer에서 데이터의 복사본을 반환합니다.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> image</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getAsset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a.jpg&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 에셋에서 UTF8로 디코딩된 문자열을 반환합니다.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> text</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getAsset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;b.txt&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;utf8&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 에셋을 포함하는 Blob을 반환합니다.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> blob</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getAssetAsBlob</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a.jpg&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 복사하지 않고 원시 에셋을 포함하는 ArrayBuffer를 반환합니다.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> raw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getRawAsset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a.jpg&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>자세한 내용은 <a href="/ko/nodejs/api/single-executable-applications#seagetassetkey-encoding"><code>sea.getAsset()</code></a>, <a href="/ko/nodejs/api/single-executable-applications#seagetassetasblobkey-options"><code>sea.getAssetAsBlob()</code></a> 및 <a href="/ko/nodejs/api/single-executable-applications#seagetrawassetkey"><code>sea.getRawAsset()</code></a> API 설명서를 참조하십시오.</p><h3 id="startup-snapshot-support" tabindex="-1">시작 스냅샷 지원 <a class="header-anchor" href="#startup-snapshot-support" aria-label="Permalink to “시작 스냅샷 지원”">​</a></h3><p><code>useSnapshot</code> 필드를 사용하여 시작 스냅샷 지원을 활성화할 수 있습니다. 이 경우 최종 실행 파일이 시작될 때 <code>main</code> 스크립트가 실행되지 않습니다. 대신 단일 실행 파일 애플리케이션 준비 Blob이 빌드 시스템에서 생성될 때 실행됩니다. 생성된 준비 Blob에는 <code>main</code> 스크립트에 의해 초기화된 상태를 캡처하는 스냅샷이 포함됩니다. 준비 Blob이 삽입된 최종 실행 파일은 런타임에 스냅샷을 역직렬화합니다.</p><p><code>useSnapshot</code>이 true이면 메인 스크립트는 <a href="/ko/nodejs/api/v8#v8startupsnapshotsetdeserializemainfunctioncallback-data"><code>v8.startupSnapshot.setDeserializeMainFunction()</code></a> API를 호출하여 사용자가 최종 실행 파일을 시작할 때 실행해야 하는 코드를 구성해야 합니다.</p><p>단일 실행 파일 애플리케이션에서 스냅샷을 사용하는 일반적인 패턴은 다음과 같습니다.</p><p>시작 스냅샷 스크립트의 일반적인 제약 조건은 단일 실행 파일 애플리케이션에 대한 스냅샷을 빌드하는 데 사용되는 메인 스크립트에도 적용되며, 메인 스크립트는 <a href="/ko/nodejs/api/v8#startup-snapshot-api"><code>v8.startupSnapshot</code> API</a>를 사용하여 이러한 제약 조건에 적응할 수 있습니다. <a href="/ko/nodejs/api/cli#build-snapshot">Node.js의 시작 스냅샷 지원에 대한 설명서</a>를 참조하십시오.</p><h3 id="v8-code-cache-support" tabindex="-1">V8 코드 캐시 지원 <a class="header-anchor" href="#v8-code-cache-support" aria-label="Permalink to “V8 코드 캐시 지원”">​</a></h3><p>구성에서 <code>useCodeCache</code>가 <code>true</code>로 설정된 경우, 단일 실행 파일 준비 blob을 생성하는 동안 Node.js는 <code>main</code> 스크립트를 컴파일하여 V8 코드 캐시를 생성합니다. 생성된 코드 캐시는 준비 blob의 일부가 되어 최종 실행 파일에 주입됩니다. 단일 실행 파일 애플리케이션이 시작되면 Node.js는 <code>main</code> 스크립트를 처음부터 컴파일하는 대신 코드 캐시를 사용하여 컴파일 속도를 높인 다음 스크립트를 실행하여 시작 성능을 향상시킵니다.</p><p><strong>참고:</strong> <code>useCodeCache</code>가 <code>true</code>이면 <code>import()</code>가 작동하지 않습니다.</p><h2 id="in-the-injected-main-script" tabindex="-1">주입된 main 스크립트에서 <a class="header-anchor" href="#in-the-injected-main-script" aria-label="Permalink to “주입된 main 스크립트에서”">​</a></h2><h3 id="single-executable-application-api" tabindex="-1">단일 실행 파일 애플리케이션 API <a class="header-anchor" href="#single-executable-application-api" aria-label="Permalink to “단일 실행 파일 애플리케이션 API”">​</a></h3><p><code>node:sea</code> 내장 모듈은 실행 파일에 내장된 JavaScript main 스크립트에서 단일 실행 파일 애플리케이션과의 상호 작용을 허용합니다.</p><h4 id="seaissea" tabindex="-1"><code>sea.isSea()</code> <a class="header-anchor" href="#seaissea" aria-label="Permalink to “sea.isSea()”">​</a></h4><p><strong>추가된 버전: v21.7.0, v20.12.0</strong></p><ul><li>반환 값: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" target="_blank" rel="noreferrer">&lt;boolean&gt;</a> 이 스크립트가 단일 실행 파일 애플리케이션 내에서 실행 중인지 여부입니다.</li></ul><h3 id="seagetassetkey-encoding" tabindex="-1"><code>sea.getAsset(key[, encoding])</code> <a class="header-anchor" href="#seagetassetkey-encoding" aria-label="Permalink to “sea.getAsset(key[, encoding])”">​</a></h3><p><strong>추가된 버전: v21.7.0, v20.12.0</strong></p><p>이 메서드를 사용하여 빌드 시 단일 실행 파일 애플리케이션에 번들로 묶도록 구성된 자산을 검색할 수 있습니다. 일치하는 자산을 찾을 수 없으면 오류가 발생합니다.</p><ul><li><code>key</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 단일 실행 파일 애플리케이션 구성의 <code>assets</code> 필드에 지정된 사전에서 자산의 키입니다.</li><li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 지정된 경우 자산은 문자열로 디코딩됩니다. <code>TextDecoder</code>에서 지원하는 모든 인코딩이 허용됩니다. 지정하지 않으면 자산의 복사본이 포함된 <code>ArrayBuffer</code>가 대신 반환됩니다.</li><li>반환 값: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noreferrer">&lt;ArrayBuffer&gt;</a></li></ul><h3 id="seagetassetasblobkey-options" tabindex="-1"><code>sea.getAssetAsBlob(key[, options])</code> <a class="header-anchor" href="#seagetassetasblobkey-options" aria-label="Permalink to “sea.getAssetAsBlob(key[, options])”">​</a></h3><p><strong>Added in: v21.7.0, v20.12.0</strong></p><p><a href="/ko/nodejs/api/single-executable-applications#seagetassetkey-encoding"><code>sea.getAsset()</code></a>과 유사하지만, 결과를 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank" rel="noreferrer"><code>Blob</code></a>으로 반환합니다. 일치하는 에셋을 찾을 수 없으면 오류가 발생합니다.</p><ul><li><p><code>key</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 단일 실행 파일 애플리케이션 구성의 <code>assets</code> 필드에 지정된 사전에서 에셋의 키입니다.</p></li><li><p><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a></p><ul><li><code>type</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> Blob의 선택적 MIME 유형입니다.</li></ul></li><li><p>반환: <a href="/ko/nodejs/api/buffer#class-blob">&lt;Blob&gt;</a></p></li></ul><h3 id="seagetrawassetkey" tabindex="-1"><code>sea.getRawAsset(key)</code> <a class="header-anchor" href="#seagetrawassetkey" aria-label="Permalink to “sea.getRawAsset(key)”">​</a></h3><p><strong>Added in: v21.7.0, v20.12.0</strong></p><p>이 메서드를 사용하여 빌드 시 단일 실행 파일 애플리케이션에 번들로 묶이도록 구성된 에셋을 검색할 수 있습니다. 일치하는 에셋을 찾을 수 없으면 오류가 발생합니다.</p><p><code>sea.getAsset()</code> 또는 <code>sea.getAssetAsBlob()</code>과 달리 이 메서드는 복사본을 반환하지 않습니다. 대신, 실행 파일 내부에 번들로 묶인 원시 에셋을 반환합니다.</p><p>현재 사용자는 반환된 배열 버퍼에 쓰는 것을 피해야 합니다. 삽입된 섹션이 쓰기 가능으로 표시되지 않거나 올바르게 정렬되지 않은 경우 반환된 배열 버퍼에 쓰면 충돌이 발생할 가능성이 높습니다.</p><ul><li><code>key</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 단일 실행 파일 애플리케이션 구성의 <code>assets</code> 필드에 지정된 사전에서 에셋의 키입니다.</li><li>반환: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noreferrer">&lt;ArrayBuffer&gt;</a></li></ul><h3 id="requireid-in-the-injected-main-script-is-not-file-based" tabindex="-1">주입된 메인 스크립트의 <code>require(id)</code>는 파일 기반이 아닙니다. <a class="header-anchor" href="#requireid-in-the-injected-main-script-is-not-file-based" aria-label="Permalink to “주입된 메인 스크립트의 require(id)는 파일 기반이 아닙니다.”">​</a></h3><p>주입된 메인 스크립트의 <code>require()</code>는 주입되지 않은 모듈에서 사용할 수 있는 <a href="/ko/nodejs/api/modules#requireid"><code>require()</code></a>와 동일하지 않습니다. 또한 주입되지 않은 <a href="/ko/nodejs/api/modules#requireid"><code>require()</code></a>가 가진 <a href="/ko/nodejs/api/modules#accessing-the-main-module"><code>require.main</code></a>을 제외한 어떤 속성도 없습니다. 내장 모듈을 로드하는 데만 사용할 수 있습니다. 파일 시스템에서만 찾을 수 있는 모듈을 로드하려고 하면 오류가 발생합니다.</p><p>파일 기반 <code>require()</code>에 의존하는 대신 애플리케이션을 독립 실행형 JavaScript 파일로 번들로 묶어 실행 파일에 주입할 수 있습니다. 이렇게 하면 보다 결정적인 종속성 그래프도 보장됩니다.</p><p>그러나 파일 기반 <code>require()</code>가 여전히 필요한 경우 다음과 같이 달성할 수도 있습니다.</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">createRequire</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;node:module&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">require </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createRequire</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__filename);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="__filename-and-modulefilename-in-the-injected-main-script" tabindex="-1">주입된 메인 스크립트의 \`__filename\` 및 \`module.filename\` <a class="header-anchor" href="#__filename-and-modulefilename-in-the-injected-main-script" aria-label="Permalink to “주입된 메인 스크립트의 \`__filename\` 및 \`module.filename\`”">​</a></h3><p>주입된 메인 스크립트에서 \`__filename\` 및 \`module.filename\`의 값은 [<code>process.execPath</code>](/ko/nodejs/api/process#processexecpath)와 같습니다.</p><h3 id="__dirname-in-the-injected-main-script" tabindex="-1">주입된 메인 스크립트의 \`__dirname\` <a class="header-anchor" href="#__dirname-in-the-injected-main-script" aria-label="Permalink to “주입된 메인 스크립트의 \`__dirname\`”">​</a></h3><p>주입된 메인 스크립트에서 \`__dirname\`의 값은 [<code>process.execPath</code>](/ko/nodejs/api/process#processexecpath)의 디렉터리 이름과 같습니다.</p><h2 id="notes" tabindex="-1">참고 사항 <a class="header-anchor" href="#notes" aria-label="Permalink to “참고 사항”">​</a></h2><h3 id="single-executable-application-creation-process" tabindex="-1">단일 실행 파일 애플리케이션 생성 프로세스 <a class="header-anchor" href="#single-executable-application-creation-process" aria-label="Permalink to “단일 실행 파일 애플리케이션 생성 프로세스”">​</a></h3><p>단일 실행 파일 Node.js 애플리케이션을 만드는 도구는 <code>--experimental-sea-config</code>로 준비된 blob의 내용을 다음 위치에 주입해야 합니다.</p><ul><li><code>node</code> 바이너리가 <a href="https://en.wikipedia.org/wiki/Portable_Executable" target="_blank" rel="noreferrer">PE</a> 파일인 경우 <code>NODE_SEA_BLOB</code>이라는 리소스</li><li><code>node</code> 바이너리가 <a href="https://en.wikipedia.org/wiki/Mach-O" target="_blank" rel="noreferrer">Mach-O</a> 파일인 경우 <code>NODE_SEA</code> 세그먼트의 <code>NODE_SEA_BLOB</code>이라는 섹션</li><li><code>node</code> 바이너리가 <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" target="_blank" rel="noreferrer">ELF</a> 파일인 경우 <code>NODE_SEA_BLOB</code>이라는 노트</li></ul><p>바이너리에서 <code>NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2:0</code> <a href="https://www.electronjs.org/docs/latest/tutorial/fuses" target="_blank" rel="noreferrer">fuse</a> 문자열을 검색하고 마지막 문자를 <code>1</code>로 뒤집어 리소스가 주입되었음을 나타냅니다.</p><h3 id="platform-support" tabindex="-1">플랫폼 지원 <a class="header-anchor" href="#platform-support" aria-label="Permalink to “플랫폼 지원”">​</a></h3><p>단일 실행 파일 지원은 다음 플랫폼에서만 CI에서 정기적으로 테스트됩니다.</p><ul><li>Windows</li><li>macOS</li><li>Linux (Alpine을 제외한 <a href="https://github.com/nodejs/node/blob/main/BUILDING.md#platform-list" target="_blank" rel="noreferrer">Node.js에서 지원하는</a> 모든 배포판 및 s390x를 제외한 <a href="https://github.com/nodejs/node/blob/main/BUILDING.md#platform-list" target="_blank" rel="noreferrer">Node.js에서 지원하는</a> 모든 아키텍처)</li></ul><p>이는 다른 플랫폼에서 이 기능을 테스트하는 데 사용할 수 있는 단일 실행 파일 생성 도구가 부족하기 때문입니다.</p><p>다른 리소스 주입 도구/워크플로에 대한 제안을 환영합니다. <a href="https://github.com/nodejs/single-executable/discussions" target="_blank" rel="noreferrer">https://github.com/nodejs/single-executable/discussions</a>에서 토론을 시작하여 문서화하는 데 도움을 주세요.</p>`,68)])}var s=e(a,[[`render`,o]]);export{i as __pageData,s as default};