import{__plugin_vue_export_helper_default as e,createElementBlock as t,createStaticVNode as n,openBlock as r}from"./chunks/plugin-vue_export-helper.Bts1mPc7.js";const i=JSON.parse(`{"title":"Node.js 文档 - TLS（传输层安全性）","description":"Node.js文档的这一部分介绍了TLS（传输层安全性）模块，该模块提供了TLS和SSL协议的实现。内容涵盖了创建安全连接、管理证书、处理安全通信以及在Node.js应用程序中配置TLS/SSL的各种选项。","frontmatter":{"title":"Node.js 文档 - TLS（传输层安全性）","description":"Node.js文档的这一部分介绍了TLS（传输层安全性）模块，该模块提供了TLS和SSL协议的实现。内容涵盖了创建安全连接、管理证书、处理安全通信以及在Node.js应用程序中配置TLS/SSL的各种选项。","head":[["meta",{"name":"og:title","content":"Node.js 文档 - TLS（传输层安全性） | Node.js - iDoc.dev"}],["meta",{"name":"og:description","content":"Node.js文档的这一部分介绍了TLS（传输层安全性）模块，该模块提供了TLS和SSL协议的实现。内容涵盖了创建安全连接、管理证书、处理安全通信以及在Node.js应用程序中配置TLS/SSL的各种选项。"}],["meta",{"name":"twitter:title","content":"Node.js 文档 - TLS（传输层安全性） | Node.js - iDoc.dev"}],["meta",{"name":"twitter:description","content":"Node.js文档的这一部分介绍了TLS（传输层安全性）模块，该模块提供了TLS和SSL协议的实现。内容涵盖了创建安全连接、管理证书、处理安全通信以及在Node.js应用程序中配置TLS/SSL的各种选项。"}],["link",{"rel":"canonical","href":"https://idoc.dev/zh/nodejs/api/tls"}],["meta",{"property":"og:url","content":"https://idoc.dev/zh/nodejs/api/tls"}]]},"headers":[],"relativePath":"zh/nodejs/api/tls.md","filePath":"zh/nodejs/api/tls.md","lastUpdated":null}`),a={name:`zh/nodejs/api/tls.md`};function o(e,i,a,o,s,c){return r(),t(`div`,null,i[0]||=[n(`<h1 id="tls-ssl" tabindex="-1">TLS (SSL) <a class="header-anchor" href="#tls-ssl" aria-label="Permalink to “TLS (SSL)”">​</a></h1><div class="tip custom-block"><p class="custom-block-title">[Stable: 2 - 稳定]</p><p><a href="/zh/nodejs/api/documentation#stability-index">Stable: 2</a> <a href="/zh/nodejs/api/documentation#stability-index">稳定性: 2</a> - 稳定</p></div><p><strong>源码:</strong> <a href="https://github.com/nodejs/node/blob/v23.5.0/lib/tls.js" target="_blank" rel="noreferrer">lib/tls.js</a></p><p><code>node:tls</code> 模块提供了一个传输层安全（TLS）和安全套接层（SSL）协议的实现，该实现构建在 OpenSSL 之上。可以使用以下方式访问该模块：</p><div class="vp-code-group"><div class="tabs"><input type="radio" name="group-14" id="tab-15" checked><label data-title="ESM" for="tab-15">ESM</label><input type="radio" name="group-14" id="tab-16"><label data-title="CJS" for="tab-16">CJS</label></div><div class="blocks"><div class="language-js active line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tls </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;node:tls&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> tls</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;node:tls&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></div></div><h2 id="determining-if-crypto-support-is-unavailable" tabindex="-1">确定 crypto 支持是否不可用 <a class="header-anchor" href="#determining-if-crypto-support-is-unavailable" aria-label="Permalink to “确定 crypto 支持是否不可用”">​</a></h2><p>Node.js 有可能在构建时未包含对 <code>node:crypto</code> 模块的支持。在这种情况下，尝试从 <code>tls</code> 中 <code>import</code> 或调用 <code>require(&#39;node:tls&#39;)</code> 将导致抛出错误。</p><p>当使用 CommonJS 时，可以使用 try/catch 捕获抛出的错误：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tls;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  tls </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;node:tls&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (err) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;tls 支持被禁用!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>当使用词法 ESM <code>import</code> 关键字时，只有在 <em>在</em> 尝试加载模块之前注册了 <code>process.on(&#39;uncaughtException&#39;)</code> 的处理程序（例如，使用预加载模块）才能捕获该错误。</p><p>当使用 ESM 时，如果代码有可能在未启用 crypto 支持的 Node.js 构建上运行，请考虑使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import" target="_blank" rel="noreferrer"><code>import()</code></a> 函数而不是词法 <code>import</code> 关键字：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tls;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  tls </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;node:tls&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (err) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;tls 支持被禁用!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="tls/ssl-concepts" tabindex="-1">TLS/SSL 概念 <a class="header-anchor" href="#tls/ssl-concepts" aria-label="Permalink to “TLS/SSL 概念”">​</a></h2><p>TLS/SSL 是一组协议，它依赖于公钥基础设施（PKI）来实现客户端和服务器之间的安全通信。对于大多数常见情况，每个服务器都必须有一个私钥。</p><p>私钥可以通过多种方式生成。下面的示例演示了使用 OpenSSL 命令行界面生成 2048 位 RSA 私钥：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">openssl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> genrsa</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -out</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ryans-key.pem</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2048</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>使用 TLS/SSL，所有服务器（和某些客户端）都必须具有<em>证书</em>。证书是对应于私钥的<em>公钥</em>，并且由证书颁发机构或私钥的所有者进行数字签名（此类证书称为“自签名”）。获取证书的第一步是创建<em>证书签名请求</em>（CSR）文件。</p><p>OpenSSL 命令行界面可用于为私钥生成 CSR：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">openssl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> req</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -sha256</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -key</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ryans-key.pem</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -out</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ryans-csr.pem</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>生成 CSR 文件后，可以将其发送到证书颁发机构进行签名，或者用于生成自签名证书。</p><p>下面的示例演示了使用 OpenSSL 命令行界面创建自签名证书：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">openssl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> x509</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -req</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -in</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ryans-csr.pem</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -signkey</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ryans-key.pem</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -out</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ryans-cert.pem</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>生成证书后，可以使用它来生成 <code>.pfx</code> 或 <code>.p12</code> 文件：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">openssl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pkcs12</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -export</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -in</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ryans-cert.pem</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -inkey</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ryans-key.pem</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      -certfile</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ca-cert.pem</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -out</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ryans.pfx</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>其中：</p><ul><li><code>in</code>: 是已签名的证书</li><li><code>inkey</code>: 是关联的私钥</li><li><code>certfile</code>: 是所有证书颁发机构（CA）证书的串联到一个文件，例如 <code>cat ca1-cert.pem ca2-cert.pem \\&gt; ca-cert.pem</code></li></ul><h3 id="perfect-forward-secrecy" tabindex="-1">完全前向保密 <a class="header-anchor" href="#perfect-forward-secrecy" aria-label="Permalink to “完全前向保密”">​</a></h3><p>术语 <em><a href="https://en.wikipedia.org/wiki/Perfect_forward_secrecy">前向保密</a></em> 或 <em>完全前向保密</em> 描述了一种密钥协商（即密钥交换）方法的特性。也就是说，服务器和客户端密钥用于协商新的临时密钥，这些密钥专门且仅用于当前的通信会话。实际上，这意味着即使服务器的私钥泄露，窃听者也只有在设法获取专门为该会话生成的密钥对时，才能解密通信。</p><p>完全前向保密是通过在每次 TLS/SSL 握手时随机生成用于密钥协商的密钥对来实现的（而不是为所有会话使用相同的密钥）。实现此技术的的方法称为“短暂的”。</p><p>目前，通常使用两种方法来实现完全前向保密（请注意附加到传统缩写中的字符“E”）：</p><ul><li><a href="https://en.wikipedia.org/wiki/Elliptic_curve_Diffie%E2%80%93Hellman" target="_blank" rel="noreferrer">ECDHE</a>：椭圆曲线 Diffie-Hellman 密钥协商协议的临时版本。</li><li><a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange" target="_blank" rel="noreferrer">DHE</a>：Diffie-Hellman 密钥协商协议的临时版本。</li></ul><p>默认情况下启用使用 ECDHE 的完全前向保密。 创建 TLS 服务器时可以使用 <code>ecdhCurve</code> 选项来自定义要使用的受支持 ECDH 曲线的列表。 有关更多信息，请参见 <a href="/zh/nodejs/api/tls#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a>。</p><p>默认情况下禁用 DHE，但可以通过将 <code>dhparam</code> 选项设置为 <code>&#39;auto&#39;</code> 来与 ECDHE 一起启用它。 也支持自定义 DHE 参数，但不建议使用，而应选择自动选择的、众所周知的参数。</p><p>在 TLSv1.2 之前，完全前向保密是可选的。 从 TLSv1.3 开始，始终使用 (EC)DHE（仅限 PSK 连接除外）。</p><h3 id="alpn-and-sni" tabindex="-1">ALPN 和 SNI <a class="header-anchor" href="#alpn-and-sni" aria-label="Permalink to “ALPN 和 SNI”">​</a></h3><p>ALPN（应用层协议协商扩展）和 SNI（服务器名称指示）是 TLS 握手扩展：</p><ul><li>ALPN：允许一个 TLS 服务器用于多个协议（HTTP，HTTP/2）</li><li>SNI：允许一个 TLS 服务器用于具有不同证书的多个主机名。</li></ul><h3 id="pre-shared-keys" tabindex="-1">预共享密钥 <a class="header-anchor" href="#pre-shared-keys" aria-label="Permalink to “预共享密钥”">​</a></h3><p>TLS-PSK 支持可作为基于证书的常规身份验证的替代方案。它使用预共享密钥而不是证书来验证 TLS 连接，从而提供相互身份验证。TLS-PSK 和公钥基础设施并非互斥。客户端和服务器可以同时支持两者，并在常规密码协商步骤中选择其中一个。</p><p>TLS-PSK 仅在存在安全地与每台连接机器共享密钥的方法时才是一个不错的选择，因此它不能替代大多数 TLS 用途的公钥基础设施 (PKI)。OpenSSL 中的 TLS-PSK 实现近年来出现了很多安全漏洞，主要是因为它仅被少数应用程序使用。在切换到 PSK 密码之前，请考虑所有替代解决方案。生成 PSK 时，至关重要的是使用足够的熵，如 <a href="https://tools.ietf.org/html/rfc4086" target="_blank" rel="noreferrer">RFC 4086</a> 中所述。从密码或其他低熵源派生共享密钥是不安全的。</p><p>PSK 密码默认情况下处于禁用状态，因此使用 TLS-PSK 需要使用 <code>ciphers</code> 选项显式指定密码套件。可以通过 <code>openssl ciphers -v &#39;PSK&#39;</code> 检索可用密码的列表。所有 TLS 1.3 密码都有资格用于 PSK，可以通过 <code>openssl ciphers -v -s -tls1_3 -psk</code> 检索。在客户端连接上，应传递自定义 <code>checkServerIdentity</code>，因为在没有证书的情况下，默认的 <code>checkServerIdentity</code> 将失败。</p><p>根据 <a href="https://tools.ietf.org/html/rfc4279" target="_blank" rel="noreferrer">RFC 4279</a>，必须支持最大长度为 128 字节的 PSK 标识和最大长度为 64 字节的 PSK。截至 OpenSSL 1.1.0，最大标识大小为 128 字节，最大 PSK 长度为 256 字节。</p><p>由于底层 OpenSSL API 的限制，当前实现不支持异步 PSK 回调。</p><p>要使用 TLS-PSK，客户端和服务器必须指定 <code>pskCallback</code> 选项，该选项是一个函数，它返回要使用的 PSK（必须与所选密码的摘要兼容）。</p><p>它将首先在客户端上调用：</p><ul><li>hint：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 从服务器发送的可选消息，以帮助客户端决定在协商期间使用哪个标识。如果使用 TLS 1.3，则始终为 <code>null</code>。</li><li>返回：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a> 格式为 <code>{ psk: \\&lt;Buffer|TypedArray|DataView\\&gt;, identity: \\&lt;string\\&gt; }</code> 或 <code>null</code>。</li></ul><p>然后在服务器上调用：</p><ul><li>socket: <a href="/zh/nodejs/api/tls#class-tlstlssocket">&lt;tls.TLSSocket&gt;</a> 服务器套接字实例，等效于 <code>this</code>。</li><li>identity：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 从客户端发送的标识参数。</li><li>返回：<a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" target="_blank" rel="noreferrer">&lt;TypedArray&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" target="_blank" rel="noreferrer">&lt;DataView&gt;</a> PSK (或 <code>null</code>)。</li></ul><p>返回 <code>null</code> 会停止协商过程，并向另一方发送 <code>unknown_psk_identity</code> 警报消息。如果服务器希望隐藏 PSK 标识未知的事实，则回调必须提供一些随机数据作为 <code>psk</code>，以使连接在协商完成之前因 <code>decrypt_error</code> 而失败。</p><h3 id="client-initiated-renegotiation-attack-mitigation" tabindex="-1">客户端发起的重新协商攻击缓解 <a class="header-anchor" href="#client-initiated-renegotiation-attack-mitigation" aria-label="Permalink to “客户端发起的重新协商攻击缓解”">​</a></h3><p>TLS 协议允许客户端重新协商 TLS 会话的某些方面。不幸的是，会话重新协商需要不成比例的服务器端资源，使其成为潜在的拒绝服务攻击向量。</p><p>为了降低风险，重新协商被限制为每十分钟三次。当超出此阈值时，会在 <a href="/zh/nodejs/api/tls#class-tlstlssocket"><code>tls.TLSSocket</code></a> 实例上发出一个 <code>&#39;error&#39;</code> 事件。这些限制是可配置的：</p><ul><li><code>tls.CLIENT_RENEG_LIMIT</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" target="_blank" rel="noreferrer">&lt;number&gt;</a> 指定重新协商请求的数量。<strong>默认值:</strong> <code>3</code>。</li><li><code>tls.CLIENT_RENEG_WINDOW</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" target="_blank" rel="noreferrer">&lt;number&gt;</a> 指定重新协商时间窗口，以秒为单位。<strong>默认值:</strong> <code>600</code> (10 分钟)。</li></ul><p>在完全理解其含义和风险的情况下，不应修改默认的重新协商限制。</p><p>TLSv1.3 不支持重新协商。</p><h3 id="session-resumption" tabindex="-1">会话恢复 <a class="header-anchor" href="#session-resumption" aria-label="Permalink to “会话恢复”">​</a></h3><p>建立 TLS 会话可能相对较慢。 通过保存并稍后重用会话状态可以加快此过程。 有几种机制可以做到这一点，这里从最旧到最新（和首选）进行讨论。</p><h4 id="session-identifiers" tabindex="-1">会话标识符 <a class="header-anchor" href="#session-identifiers" aria-label="Permalink to “会话标识符”">​</a></h4><p>服务器为新连接生成唯一的 ID 并将其发送给客户端。 客户端和服务器保存会话状态。 重新连接时，客户端发送其保存的会话状态的 ID，如果服务器也具有该 ID 的状态，则可以同意使用它。 否则，服务器将创建一个新会话。 有关更多信息，请参见 <a href="https://www.ietf.org/rfc/rfc2246.txt" target="_blank" rel="noreferrer">RFC 2246</a>，第 23 和 30 页。</p><p>在使用 HTTPS 请求时，大多数 Web 浏览器都支持使用会话标识符进行恢复。</p><p>对于 Node.js，客户端等待 <a href="/zh/nodejs/api/tls#event-session"><code>&#39;session&#39;</code></a> 事件以获取会话数据，并将数据提供给后续 <a href="/zh/nodejs/api/tls#tlsconnectoptions-callback"><code>tls.connect()</code></a> 的 <code>session</code> 选项以重用会话。 服务器必须实现 <a href="/zh/nodejs/api/tls#event-newsession"><code>&#39;newSession&#39;</code></a> 和 <a href="/zh/nodejs/api/tls#event-resumesession"><code>&#39;resumeSession&#39;</code></a> 事件的处理程序，以使用会话 ID 作为查找键来保存和恢复会话数据，以重用会话。 要跨负载均衡器或集群工作进程重用会话，服务器必须在其会话处理程序中使用共享会话缓存（例如 Redis）。</p><h4 id="session-tickets" tabindex="-1">会话票证 <a class="header-anchor" href="#session-tickets" aria-label="Permalink to “会话票证”">​</a></h4><p>服务器加密整个会话状态，并将其作为“票证”发送给客户端。重新连接时，状态将在初始连接中发送到服务器。这种机制避免了对服务器端会话缓存的需求。如果服务器由于任何原因（解密失败、票证太旧等）未使用该票证，它将创建一个新会话并发送一个新票证。有关更多信息，请参见 <a href="https://tools.ietf.org/html/rfc5077" target="_blank" rel="noreferrer">RFC 5077</a>。</p><p>当发出 HTTPS 请求时，使用会话票证恢复连接正变得越来越普遍地被许多 Web 浏览器支持。</p><p>对于 Node.js，客户端使用与使用会话标识符恢复连接相同的 API 来使用会话票证恢复连接。对于调试，如果 <a href="/zh/nodejs/api/tls#tlssocketgettlsticket"><code>tls.TLSSocket.getTLSTicket()</code></a> 返回一个值，则会话数据包含一个票证，否则它包含客户端会话状态。</p><p>使用 TLSv1.3 时，请注意服务器可能会发送多个票证，从而导致多个 <code>&#39;session&#39;</code> 事件，有关更多信息，请参见 <a href="/zh/nodejs/api/tls#event-session"><code>&#39;session&#39;</code></a>。</p><p>单进程服务器不需要任何特定的实现即可使用会话票证。要在服务器重启或负载均衡器之间使用会话票证，服务器必须都具有相同的票证密钥。内部有三个 16 字节的密钥，但为了方便起见，tls API 将它们作为一个 48 字节的缓冲区公开。</p><p>可以通过在一个服务器实例上调用 <a href="/zh/nodejs/api/tls#servergetticketkeys"><code>server.getTicketKeys()</code></a> 来获取票证密钥，然后分发它们，但更合理的是安全地生成 48 字节的安全随机数据，并使用 <a href="/zh/nodejs/api/tls#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a> 的 <code>ticketKeys</code> 选项来设置它们。应该定期重新生成密钥，并且可以使用 <a href="/zh/nodejs/api/tls#serversetticketkeyskeys"><code>server.setTicketKeys()</code></a> 重置服务器的密钥。</p><p>会话票证密钥是加密密钥，它们*<strong>必须安全存储</strong>*。对于 TLS 1.2 及以下版本，如果它们被泄露，则所有使用使用它们加密的票证的会话都可以被解密。它们不应存储在磁盘上，并且应定期重新生成。</p><p>如果客户端声明支持票证，则服务器将发送它们。服务器可以通过在 <code>secureOptions</code> 中提供 <code>require(&#39;node:constants&#39;).SSL_OP_NO_TICKET</code> 来禁用票证。</p><p>会话标识符和会话票证都会超时，从而导致服务器创建新会话。可以使用 <a href="/zh/nodejs/api/tls#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a> 的 <code>sessionTimeout</code> 选项配置超时。</p><p>对于所有机制，当恢复失败时，服务器将创建新会话。由于无法恢复会话不会导致 TLS/HTTPS 连接失败，因此很容易忽略不必要的 TLS 性能下降。可以使用 OpenSSL CLI 验证服务器是否正在恢复会话。使用 <code>openssl s_client</code> 的 <code>-reconnect</code> 选项，例如：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">openssl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> s_client</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -connect</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> localhost:443</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -reconnect</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>通读调试输出。第一个连接应该显示“New”，例如：</p><div class="language-text line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>New, TLSv1.2, Cipher is ECDHE-RSA-AES128-GCM-SHA256</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>后续连接应显示“Reused”，例如：</p><div class="language-text line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>Reused, TLSv1.2, Cipher is ECDHE-RSA-AES128-GCM-SHA256</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="modifying-the-default-tls-cipher-suite" tabindex="-1">修改默认的 TLS 密码套件 <a class="header-anchor" href="#modifying-the-default-tls-cipher-suite" aria-label="Permalink to “修改默认的 TLS 密码套件”">​</a></h2><p>Node.js 内置了一套默认启用和禁用的 TLS 密码。 这个默认密码列表可以在构建 Node.js 时进行配置，允许发行版提供他们自己的默认列表。</p><p>以下命令可用于显示默认密码套件：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">node</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> crypto.constants.defaultCoreCipherList</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> tr</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;:&#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;\\n&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TLS_AES_256_GCM_SHA384</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TLS_CHACHA20_POLY1305_SHA256</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TLS_AES_128_GCM_SHA256</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ECDHE-RSA-AES128-GCM-SHA256</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ECDHE-ECDSA-AES128-GCM-SHA256</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ECDHE-RSA-AES256-GCM-SHA384</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ECDHE-ECDSA-AES256-GCM-SHA384</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DHE-RSA-AES128-GCM-SHA256</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ECDHE-RSA-AES128-SHA256</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DHE-RSA-AES128-SHA256</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ECDHE-RSA-AES256-SHA384</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DHE-RSA-AES256-SHA384</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ECDHE-RSA-AES256-SHA256</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DHE-RSA-AES256-SHA256</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">HIGH</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aNULL</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">eNULL</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">EXPORT</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DES</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RC4</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MD5</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PSK</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SRP</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CAMELLIA</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>这个默认值可以使用 <a href="/zh/nodejs/api/cli#tls-cipher-listlist"><code>--tls-cipher-list</code></a> 命令行开关（直接或通过 <a href="/zh/nodejs/api/cli#node-optionsoptions"><code>NODE_OPTIONS</code></a> 环境变量）完全替换。 例如，以下命令使 <code>ECDHE-RSA-AES128-GCM-SHA256:!RC4</code> 成为默认的 TLS 密码套件：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">node</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --tls-cipher-list=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ECDHE-RSA-AES128-GCM-SHA256:!RC4&#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> server.js</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NODE_OPTIONS</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">--tls-cipher-list</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ECDHE-RSA-AES128-GCM-SHA256:!RC4&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">node</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> server.js</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>为了验证，使用以下命令显示设置的密码列表，注意 <code>defaultCoreCipherList</code> 和 <code>defaultCipherList</code> 之间的区别：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">node</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --tls-cipher-list=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ECDHE-RSA-AES128-GCM-SHA256:!RC4&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> crypto.constants.defaultCipherList</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> tr</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;:&#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;\\n&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ECDHE-RSA-AES128-GCM-SHA256</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RC4</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>即 <code>defaultCoreCipherList</code> 列表是在编译时设置的，而 <code>defaultCipherList</code> 是在运行时设置的。</p><p>要从运行时修改默认密码套件，请修改 <code>tls.DEFAULT_CIPHERS</code> 变量，这必须在监听任何套接字之前执行，它不会影响已经打开的套接字。 例如：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 移除过时的 CBC 密码和基于 RSA 密钥交换的密码，因为它们不提供完全前向保密</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tls.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DEFAULT_CIPHERS</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +=</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;:!ECDHE-RSA-AES128-SHA:!ECDHE-RSA-AES128-SHA256:!ECDHE-RSA-AES256-SHA:!ECDHE-RSA-AES256-SHA384&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;:!ECDHE-ECDSA-AES128-SHA:!ECDHE-ECDSA-AES128-SHA256:!ECDHE-ECDSA-AES256-SHA:!ECDHE-ECDSA-AES256-SHA384&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;:!kRSA&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>默认值也可以使用 <a href="/zh/nodejs/api/tls#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 中的 <code>ciphers</code> 选项在每个客户端或服务器的基础上进行替换，该选项也可在 <a href="/zh/nodejs/api/tls#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a>、<a href="/zh/nodejs/api/tls#tlsconnectoptions-callback"><code>tls.connect()</code></a> 以及创建新的 <a href="/zh/nodejs/api/tls#class-tlstlssocket"><code>tls.TLSSocket</code></a> 时使用。</p><p>密码列表可以包含 TLSv1.3 密码套件名称（以 <code>&#39;TLS_&#39;</code> 开头）和 TLSv1.2 及更低版本密码套件的规范的混合。 TLSv1.2 密码支持传统的规范格式，有关详细信息，请参阅 OpenSSL <a href="https://www.openssl.org/docs/man1.1.1/man1/ciphers#CIPHER-LIST-FORMAT" target="_blank" rel="noreferrer">密码列表格式</a> 文档，但这些规范<em>不</em>适用于 TLSv1.3 密码。 TLSv1.3 套件只能通过在其密码列表中包含其完整名称来启用。 例如，不能使用传统的 TLSv1.2 <code>&#39;EECDH&#39;</code> 或 <code>&#39;!EECDH&#39;</code> 规范来启用或禁用它们。</p><p>尽管 TLSv1.3 和 TLSv1.2 密码套件的相对顺序如何，但 TLSv1.3 协议比 TLSv1.2 安全得多，并且如果握手表明支持该协议并且启用了任何 TLSv1.3 密码套件，则始终会选择 TLSv1.3 协议。</p><p>Node.js 中包含的默认密码套件经过精心选择，以反映当前的安全最佳实践和风险缓解措施。 更改默认密码套件会对应用程序的安全性产生重大影响。 只有在绝对必要时才应使用 <code>--tls-cipher-list</code> 开关和 <code>ciphers</code> 选项。</p><p>默认密码套件更喜欢用于 <a href="https://www.chromium.org/Home/chromium-security/education/tls#TOC-Cipher-Suites" target="_blank" rel="noreferrer">Chrome 的“现代密码学”设置</a> 的 GCM 密码，并且更喜欢用于完美前向保密的 ECDHE 和 DHE 密码，同时提供<em>一些</em>向后兼容性。</p><p>依赖于不安全且已弃用的基于 RC4 或 DES 的密码的旧客户端（如 Internet Explorer 6）无法使用默认配置完成握手过程。 如果<em>必须</em>支持这些客户端，则 <a href="https://wiki.mozilla.org/Security/Server_Side_TLS" target="_blank" rel="noreferrer">TLS 建议</a> 可能会提供兼容的密码套件。 有关格式的更多详细信息，请参阅 OpenSSL <a href="https://www.openssl.org/docs/man1.1.1/man1/ciphers#CIPHER-LIST-FORMAT" target="_blank" rel="noreferrer">密码列表格式</a> 文档。</p><p>只有五个 TLSv1.3 密码套件：</p><ul><li><code>&#39;TLS_AES_256_GCM_SHA384&#39;</code></li><li><code>&#39;TLS_CHACHA20_POLY1305_SHA256&#39;</code></li><li><code>&#39;TLS_AES_128_GCM_SHA256&#39;</code></li><li><code>&#39;TLS_AES_128_CCM_SHA256&#39;</code></li><li><code>&#39;TLS_AES_128_CCM_8_SHA256&#39;</code></li></ul><p>前三个默认启用。 这两个基于 <code>CCM</code> 的套件受 TLSv1.3 支持，因为它们在受限系统上可能具有更高的性能，但由于它们提供的安全性较低，因此默认情况下不启用它们。</p><h2 id="openssl-security-level" tabindex="-1">OpenSSL 安全等级 <a class="header-anchor" href="#openssl-security-level" aria-label="Permalink to “OpenSSL 安全等级”">​</a></h2><p>OpenSSL 库强制执行安全等级，以控制密码操作可接受的最低安全级别。OpenSSL 的安全等级范围为 0 到 5，每个等级都施加了更严格的安全要求。默认安全等级为 1，通常适用于大多数现代应用程序。但是，某些遗留特性和协议（例如 TLSv1）需要较低的安全等级 (<code>SECLEVEL=0</code>) 才能正常运行。有关更多详细信息，请参阅 <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_security_level#DEFAULT-CALLBACK-BEHAVIOUR" target="_blank" rel="noreferrer">OpenSSL 关于安全等级的文档</a>。</p><h3 id="setting-security-levels" tabindex="-1">设置安全等级 <a class="header-anchor" href="#setting-security-levels" aria-label="Permalink to “设置安全等级”">​</a></h3><p>要在您的 Node.js 应用程序中调整安全等级，您可以在密码字符串中包含 <code>@SECLEVEL=X</code>，其中 <code>X</code> 是所需的安全等级。例如，要在使用默认 OpenSSL 密码列表的同时将安全等级设置为 0，您可以这样做：</p><div class="vp-code-group"><div class="tabs"><input type="radio" name="group-368" id="tab-369" checked><label data-title="ESM" for="tab-369">ESM</label><input type="radio" name="group-368" id="tab-370"><label data-title="CJS" for="tab-370">CJS</label></div><div class="blocks"><div class="language-js active line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { createServer, connect } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;node:tls&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> port</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 443</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ ciphers: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;DEFAULT@SECLEVEL=0&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, minVersion: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;TLSv1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">socket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Client connected with protocol:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getProtocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(port, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(port, { ciphers: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;DEFAULT@SECLEVEL=0&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, maxVersion: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;TLSv1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">createServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;node:tls&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> port</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 443</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ ciphers: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;DEFAULT@SECLEVEL=0&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, minVersion: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;TLSv1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">socket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Client connected with protocol:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getProtocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(port, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(port, { ciphers: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;DEFAULT@SECLEVEL=0&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, maxVersion: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;TLSv1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></div></div><p>这种方法将安全等级设置为 0，允许使用遗留功能，同时仍然利用默认的 OpenSSL 密码。</p><h3 id="using" tabindex="-1">使用 <a class="header-anchor" href="#using" aria-label="Permalink to “使用”">​</a></h3><p>您还可以使用 <code>--tls-cipher-list=DEFAULT@SECLEVEL=X</code> 从命令行设置安全级别和密码，如 <a href="/zh/nodejs/api/tls#modifying-the-default-tls-cipher-suite">修改默认 TLS 密码套件</a> 中所述。但是，通常不鼓励使用命令行选项设置密码，最好在应用程序代码中为各个上下文配置密码，因为这种方法提供了更精细的控制，并降低了全局降低安全级别的风险。</p><h2 id="x509-certificate-error-codes" tabindex="-1">X509 证书错误代码 <a class="header-anchor" href="#x509-certificate-error-codes" aria-label="Permalink to “X509 证书错误代码”">​</a></h2><p>由于 OpenSSL 报告的证书错误，多个函数可能会失败。在这种情况下，该函数会通过其回调提供一个 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" target="_blank" rel="noreferrer">&lt;Error&gt;</a>，该回调具有属性 <code>code</code>，它可以采用以下值之一：</p><ul><li><code>&#39;UNABLE_TO_GET_ISSUER_CERT&#39;</code>: 无法获取颁发者证书。</li><li><code>&#39;UNABLE_TO_GET_CRL&#39;</code>: 无法获取证书 CRL。</li><li><code>&#39;UNABLE_TO_DECRYPT_CERT_SIGNATURE&#39;</code>: 无法解密证书的签名。</li><li><code>&#39;UNABLE_TO_DECRYPT_CRL_SIGNATURE&#39;</code>: 无法解密 CRL 的签名。</li><li><code>&#39;UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY&#39;</code>: 无法解码颁发者的公钥。</li><li><code>&#39;CERT_SIGNATURE_FAILURE&#39;</code>: 证书签名失败。</li><li><code>&#39;CRL_SIGNATURE_FAILURE&#39;</code>: CRL 签名失败。</li><li><code>&#39;CERT_NOT_YET_VALID&#39;</code>: 证书尚未生效。</li><li><code>&#39;CERT_HAS_EXPIRED&#39;</code>: 证书已过期。</li><li><code>&#39;CRL_NOT_YET_VALID&#39;</code>: CRL 尚未生效。</li><li><code>&#39;CRL_HAS_EXPIRED&#39;</code>: CRL 已过期。</li><li><code>&#39;ERROR_IN_CERT_NOT_BEFORE_FIELD&#39;</code>: 证书的 notBefore 字段中存在格式错误。</li><li><code>&#39;ERROR_IN_CERT_NOT_AFTER_FIELD&#39;</code>: 证书的 notAfter 字段中存在格式错误。</li><li><code>&#39;ERROR_IN_CRL_LAST_UPDATE_FIELD&#39;</code>: CRL 的 lastUpdate 字段中存在格式错误。</li><li><code>&#39;ERROR_IN_CRL_NEXT_UPDATE_FIELD&#39;</code>: CRL 的 nextUpdate 字段中存在格式错误。</li><li><code>&#39;OUT_OF_MEM&#39;</code>: 内存不足。</li><li><code>&#39;DEPTH_ZERO_SELF_SIGNED_CERT&#39;</code>: 自签名证书。</li><li><code>&#39;SELF_SIGNED_CERT_IN_CHAIN&#39;</code>: 证书链中的自签名证书。</li><li><code>&#39;UNABLE_TO_GET_ISSUER_CERT_LOCALLY&#39;</code>: 无法获取本地颁发者证书。</li><li><code>&#39;UNABLE_TO_VERIFY_LEAF_SIGNATURE&#39;</code>: 无法验证第一个证书。</li><li><code>&#39;CERT_CHAIN_TOO_LONG&#39;</code>: 证书链太长。</li><li><code>&#39;CERT_REVOKED&#39;</code>: 证书已吊销。</li><li><code>&#39;INVALID_CA&#39;</code>: 无效的 CA 证书。</li><li><code>&#39;PATH_LENGTH_EXCEEDED&#39;</code>: 路径长度约束超出。</li><li><code>&#39;INVALID_PURPOSE&#39;</code>: 不支持的证书用途。</li><li><code>&#39;CERT_UNTRUSTED&#39;</code>: 证书不受信任。</li><li><code>&#39;CERT_REJECTED&#39;</code>: 证书被拒绝。</li><li><code>&#39;HOSTNAME_MISMATCH&#39;</code>: 主机名不匹配。</li></ul><h2 id="class-tlscryptostream" tabindex="-1">类: <code>tls.CryptoStream</code> <a class="header-anchor" href="#class-tlscryptostream" aria-label="Permalink to “类: tls.CryptoStream”">​</a></h2><p><strong>新增于: v0.3.4</strong></p><p><strong>已弃用自: v0.11.3</strong></p><div class="danger custom-block"><p class="custom-block-title">[稳定度: 0 - 已弃用]</p><p><a href="/zh/nodejs/api/documentation#stability-index">稳定度: 0</a> <a href="/zh/nodejs/api/documentation#stability-index">稳定性: 0</a> - 已弃用: 请使用 <a href="/zh/nodejs/api/tls#class-tlstlssocket"><code>tls.TLSSocket</code></a> 代替。</p></div><p><code>tls.CryptoStream</code> 类表示加密数据的流。 此类已弃用，不应再使用。</p><h3 id="cryptostreambyteswritten" tabindex="-1"><code>cryptoStream.bytesWritten</code> <a class="header-anchor" href="#cryptostreambyteswritten" aria-label="Permalink to “cryptoStream.bytesWritten”">​</a></h3><p><strong>新增于: v0.3.4</strong></p><p><strong>已弃用自: v0.11.3</strong></p><p><code>cryptoStream.bytesWritten</code> 属性返回写入底层套接字的总字节数，<em>包括</em>实现 TLS 协议所需的字节。</p><h2 id="class-tlssecurepair" tabindex="-1">类: <code>tls.SecurePair</code> <a class="header-anchor" href="#class-tlssecurepair" aria-label="Permalink to “类: tls.SecurePair”">​</a></h2><p><strong>新增于: v0.3.2</strong></p><p><strong>已弃用自: v0.11.3</strong></p><div class="danger custom-block"><p class="custom-block-title">[稳定度: 0 - 已弃用]</p><p><a href="/zh/nodejs/api/documentation#stability-index">稳定度: 0</a> <a href="/zh/nodejs/api/documentation#stability-index">稳定性: 0</a> - 已弃用: 请使用 <a href="/zh/nodejs/api/tls#class-tlstlssocket"><code>tls.TLSSocket</code></a> 代替。</p></div><p>由 <a href="/zh/nodejs/api/tls#tlscreatesecurepaircontext-isserver-requestcert-rejectunauthorized-options"><code>tls.createSecurePair()</code></a> 返回。</p><h3 id="event-secure" tabindex="-1">事件: <code>&#39;secure&#39;</code> <a class="header-anchor" href="#event-secure" aria-label="Permalink to “事件: &#39;secure&#39;”">​</a></h3><p><strong>新增于: v0.3.2</strong></p><p><strong>已弃用自: v0.11.3</strong></p><p>一旦建立安全连接，<code>&#39;secure&#39;</code> 事件将由 <code>SecurePair</code> 对象发出。</p><p>与检查服务器 <a href="/zh/nodejs/api/tls#event-secureconnection"><code>&#39;secureConnection&#39;</code></a> 事件一样，应检查 <code>pair.cleartext.authorized</code> 以确认所使用的证书是否已正确授权。</p><h2 id="class-tlsserver" tabindex="-1">类: <code>tls.Server</code> <a class="header-anchor" href="#class-tlsserver" aria-label="Permalink to “类: tls.Server”">​</a></h2><p><strong>新增于: v0.3.2</strong></p><ul><li>继承自: <a href="/zh/nodejs/api/net#class-netserver">&lt;net.Server&gt;</a></li></ul><p>接受使用 TLS 或 SSL 加密的连接。</p><h3 id="event-connection" tabindex="-1">事件: <code>&#39;connection&#39;</code> <a class="header-anchor" href="#event-connection" aria-label="Permalink to “事件: &#39;connection&#39;”">​</a></h3><p><strong>新增于: v0.3.2</strong></p><ul><li><code>socket</code> <a href="/zh/nodejs/api/stream#class-streamduplex">&lt;stream.Duplex&gt;</a></li></ul><p>此事件在新 TCP 流建立时发出，在 TLS 握手开始之前。 <code>socket</code> 通常是 <a href="/zh/nodejs/api/net#class-netsocket"><code>net.Socket</code></a> 类型的对象，但与从 <a href="/zh/nodejs/api/net#class-netserver"><code>net.Server</code></a> <code>&#39;connection&#39;</code> 事件创建的套接字不同，它不会接收事件。 通常，用户不希望访问此事件。</p><p>用户也可以显式发出此事件，以将连接注入到 TLS 服务器中。 在这种情况下，可以传递任何 <a href="/zh/nodejs/api/stream#class-streamduplex"><code>Duplex</code></a> 流。</p><h3 id="event-keylog" tabindex="-1">Event: <code>&#39;keylog&#39;</code> <a class="header-anchor" href="#event-keylog" aria-label="Permalink to “Event: &#39;keylog&#39;”">​</a></h3><p><strong>添加于: v12.3.0, v10.20.0</strong></p><ul><li><code>line</code> <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> ASCII 文本行，采用 NSS <code>SSLKEYLOGFILE</code> 格式。</li><li><code>tlsSocket</code> <a href="/zh/nodejs/api/tls#class-tlstlssocket">&lt;tls.TLSSocket&gt;</a> 生成该行的 <code>tls.TLSSocket</code> 实例。</li></ul><p>当连接到此服务器时生成或接收到密钥材料时（通常在握手完成之前，但不一定），会发出 <code>keylog</code> 事件。可以存储此密钥材料以进行调试，因为它允许解密捕获的 TLS 流量。每个套接字可能会发出多次。</p><p>一个典型的用例是将接收到的行追加到公共文本文件中，该文件稍后被软件（如 Wireshark）用来解密流量：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> logFile</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createWriteStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/tmp/ssl-keys.log&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { flags: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">server.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;keylog&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">line</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">tlsSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (tlsSocket.remoteAddress </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;...&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 只记录特定 IP 的密钥</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  logFile.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(line);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="event-newsession" tabindex="-1">Event: <code>&#39;newSession&#39;</code> <a class="header-anchor" href="#event-newsession" aria-label="Permalink to “Event: &#39;newSession&#39;”">​</a></h3><div class="info custom-block"><p class="custom-block-title">[历史记录]</p><table tabindex="0"><thead><tr><th>版本</th><th>更改</th></tr></thead><tbody><tr><td>v0.11.12</td><td>现在支持 <code>callback</code> 参数。</td></tr><tr><td>v0.9.2</td><td>添加于: v0.9.2</td></tr></tbody></table></div><p>当创建新的 TLS 会话时，会发出 <code>&#39;newSession&#39;</code> 事件。这可用于将会话存储在外部存储中。该数据应提供给 <a href="/zh/nodejs/api/tls#event-resumesession"><code>&#39;resumeSession&#39;</code></a> 回调。</p><p>调用侦听器回调时，将传递三个参数：</p><ul><li><code>sessionId</code> <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> TLS 会话标识符</li><li><code>sessionData</code> <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> TLS 会话数据</li><li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noreferrer">&lt;Function&gt;</a> 一个不接受任何参数的回调函数，必须调用该函数才能通过安全连接发送或接收数据。</li></ul><p>监听此事件只会影响在添加事件侦听器之后建立的连接。</p><h3 id="event-ocsprequest" tabindex="-1">Event: <code>&#39;OCSPRequest&#39;</code> <a class="header-anchor" href="#event-ocsprequest" aria-label="Permalink to “Event: &#39;OCSPRequest&#39;”">​</a></h3><p><strong>添加于: v0.11.13</strong></p><p>当客户端发送证书状态请求时，会发出 <code>&#39;OCSPRequest&#39;</code> 事件。调用侦听器回调时，将传递三个参数：</p><ul><li><code>certificate</code> <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> 服务器证书</li><li><code>issuer</code> <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> 颁发者的证书</li><li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noreferrer">&lt;Function&gt;</a> 必须调用以提供 OCSP 请求结果的回调函数。</li></ul><p>可以解析服务器的当前证书以获取 OCSP URL 和证书 ID；获得 OCSP 响应后，将调用 <code>callback(null, resp)</code>，其中 <code>resp</code> 是一个包含 OCSP 响应的 <code>Buffer</code> 实例。<code>certificate</code> 和 <code>issuer</code> 都是主证书和颁发者证书的 <code>Buffer</code> DER 表示形式。这些可用于获取 OCSP 证书 ID 和 OCSP 端点 URL。</p><p>或者，可以调用 <code>callback(null, null)</code>，表明没有 OCSP 响应。</p><p>调用 <code>callback(err)</code> 将导致 <code>socket.destroy(err)</code> 调用。</p><p>OCSP 请求的典型流程如下：</p><p>如果证书是自签名证书，或者颁发者不在根证书列表中，则 <code>issuer</code> 可以为 <code>null</code>。（建立 TLS 连接时，可以通过 <code>ca</code> 选项提供颁发者。）</p><p>监听此事件只会影响在添加事件侦听器之后建立的连接。</p><p>可以使用像 <a href="https://www.npmjs.com/package/asn1.js" target="_blank" rel="noreferrer">asn1.js</a> 这样的 npm 模块来解析证书。</p><h3 id="event-resumesession" tabindex="-1">事件: <code>&#39;resumeSession&#39;</code> <a class="header-anchor" href="#event-resumesession" aria-label="Permalink to “事件: &#39;resumeSession&#39;”">​</a></h3><p><strong>加入于: v0.9.2</strong></p><p>当客户端请求恢复之前的 TLS 会话时，会触发 <code>&#39;resumeSession&#39;</code> 事件。监听器回调函数在被调用时会传入两个参数：</p><ul><li><code>sessionId</code> <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> TLS 会话标识符</li><li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noreferrer">&lt;Function&gt;</a> 一个回调函数，当之前的会话被恢复后调用：<code>callback([err[, sessionData]])</code><ul><li><code>err</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" target="_blank" rel="noreferrer">&lt;Error&gt;</a></li><li><code>sessionData</code> <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a></li></ul></li></ul><p>事件监听器应该使用给定的 <code>sessionId</code> 在外部存储中查找由 <a href="/zh/nodejs/api/tls#event-newsession"><code>&#39;newSession&#39;</code></a> 事件处理程序保存的 <code>sessionData</code>。 如果找到，调用 <code>callback(null, sessionData)</code> 以恢复会话。 如果未找到，则无法恢复会话。 必须在没有 <code>sessionData</code> 的情况下调用 <code>callback()</code>，以便握手可以继续并创建一个新会话。 可以调用 <code>callback(err)</code> 以终止传入的连接并销毁套接字。</p><p>监听此事件只会对添加事件监听器后建立的连接产生影响。</p><p>以下演示了恢复 TLS 会话：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> tlsSessionStore</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">server.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;newSession&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  tlsSessionStore[id.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hex&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  cb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">server.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;resumeSession&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  cb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tlsSessionStore[id.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hex&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="event-secureconnection" tabindex="-1">事件: <code>&#39;secureConnection&#39;</code> <a class="header-anchor" href="#event-secureconnection" aria-label="Permalink to “事件: &#39;secureConnection&#39;”">​</a></h3><p><strong>加入于: v0.3.2</strong></p><p>当新连接的握手过程成功完成后，会触发 <code>&#39;secureConnection&#39;</code> 事件。 监听器回调函数在被调用时会传入一个参数：</p><ul><li><code>tlsSocket</code> <a href="/zh/nodejs/api/tls#class-tlstlssocket">&lt;tls.TLSSocket&gt;</a> 已建立的 TLS 套接字。</li></ul><p><code>tlsSocket.authorized</code> 属性是一个 <code>boolean</code> 值，指示客户端是否已通过服务器提供的证书颁发机构之一进行验证。 如果 <code>tlsSocket.authorized</code> 为 <code>false</code>，则 <code>socket.authorizationError</code> 将被设置为描述授权失败的原因。 根据 TLS 服务器的设置，未经授权的连接仍可能被接受。</p><p><code>tlsSocket.alpnProtocol</code> 属性是一个字符串，包含所选的 ALPN 协议。 当 ALPN 没有选择协议，因为客户端或服务器没有发送 ALPN 扩展时，<code>tlsSocket.alpnProtocol</code> 等于 <code>false</code>。</p><p><code>tlsSocket.servername</code> 属性是一个字符串，包含通过 SNI 请求的服务器名称。</p><h3 id="event-tlsclienterror" tabindex="-1">事件: <code>&#39;tlsClientError&#39;</code> <a class="header-anchor" href="#event-tlsclienterror" aria-label="Permalink to “事件: &#39;tlsClientError&#39;”">​</a></h3><p><strong>加入版本: v6.0.0</strong></p><p>当安全连接建立之前发生错误时，会触发 <code>&#39;tlsClientError&#39;</code> 事件。监听器回调函数在调用时会传递两个参数：</p><ul><li><code>exception</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" target="_blank" rel="noreferrer">&lt;Error&gt;</a> 描述错误的 <code>Error</code> 对象</li><li><code>tlsSocket</code> <a href="/zh/nodejs/api/tls#class-tlstlssocket">&lt;tls.TLSSocket&gt;</a> 产生错误的 <code>tls.TLSSocket</code> 实例。</li></ul><h3 id="serveraddcontexthostname-context" tabindex="-1"><code>server.addContext(hostname, context)</code> <a class="header-anchor" href="#serveraddcontexthostname-context" aria-label="Permalink to “server.addContext(hostname, context)”">​</a></h3><p><strong>加入版本: v0.5.3</strong></p><ul><li><code>hostname</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 一个 SNI 主机名或通配符 (例如 <code>&#39;*&#39;</code>)</li><li><code>context</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a> | <a href="/zh/nodejs/api/tls#tlscreatesecurecontextoptions">&lt;tls.SecureContext&gt;</a> 一个包含 <a href="/zh/nodejs/api/tls#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> <code>options</code> 参数中任何可能属性的对象 (例如 <code>key</code>、<code>cert</code>、<code>ca</code> 等)，或一个使用 <a href="/zh/nodejs/api/tls#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 创建的 TLS 上下文对象。</li></ul><p><code>server.addContext()</code> 方法添加一个安全上下文，如果客户端请求的 SNI 名称与提供的 <code>hostname</code>（或通配符）匹配，则将使用该上下文。</p><p>当有多个匹配的上下文时，使用最近添加的上下文。</p><h3 id="serveraddress" tabindex="-1"><code>server.address()</code> <a class="header-anchor" href="#serveraddress" aria-label="Permalink to “server.address()”">​</a></h3><p><strong>加入版本: v0.6.0</strong></p><ul><li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a></li></ul><p>返回操作系统报告的服务器绑定地址、地址族名称和端口。 更多信息请参见 <a href="/zh/nodejs/api/net#serveraddress"><code>net.Server.address()</code></a>。</p><h3 id="serverclosecallback" tabindex="-1"><code>server.close([callback])</code> <a class="header-anchor" href="#serverclosecallback" aria-label="Permalink to “server.close([callback])”">​</a></h3><p><strong>加入版本: v0.3.2</strong></p><ul><li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noreferrer">&lt;Function&gt;</a> 一个监听器回调函数，将被注册以监听服务器实例的 <code>&#39;close&#39;</code> 事件。</li><li>返回: <a href="/zh/nodejs/api/tls#class-tlsserver">&lt;tls.Server&gt;</a></li></ul><p><code>server.close()</code> 方法停止服务器接受新的连接。</p><p>此函数以异步方式运行。 当服务器没有更多打开的连接时，将发出 <code>&#39;close&#39;</code> 事件。</p><h3 id="servergetticketkeys" tabindex="-1"><code>server.getTicketKeys()</code> <a class="header-anchor" href="#servergetticketkeys" aria-label="Permalink to “server.getTicketKeys()”">​</a></h3><p><strong>Added in: v3.0.0</strong></p><ul><li>返回: <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> 一个包含会话票证密钥的 48 字节缓冲区。</li></ul><p>返回会话票证密钥。</p><p>更多信息请参见 <a href="/zh/nodejs/api/tls#session-resumption">会话恢复</a>。</p><h3 id="serverlisten" tabindex="-1"><code>server.listen()</code> <a class="header-anchor" href="#serverlisten" aria-label="Permalink to “server.listen()”">​</a></h3><p>开始监听加密连接的服务器。 此方法与 <a href="/zh/nodejs/api/net#class-netserver"><code>net.Server</code></a> 中的 <a href="/zh/nodejs/api/net#serverlisten"><code>server.listen()</code></a> 相同。</p><h3 id="serversetsecurecontextoptions" tabindex="-1"><code>server.setSecureContext(options)</code> <a class="header-anchor" href="#serversetsecurecontextoptions" aria-label="Permalink to “server.setSecureContext(options)”">​</a></h3><p><strong>Added in: v11.0.0</strong></p><ul><li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a> 一个对象，包含来自 <a href="/zh/nodejs/api/tls#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> <code>options</code> 参数的任何可能属性（例如，<code>key</code>，<code>cert</code>，<code>ca</code> 等）。</li></ul><p><code>server.setSecureContext()</code> 方法替换现有服务器的安全上下文。 现有到服务器的连接不会中断。</p><h3 id="serversetticketkeyskeys" tabindex="-1"><code>server.setTicketKeys(keys)</code> <a class="header-anchor" href="#serversetticketkeyskeys" aria-label="Permalink to “server.setTicketKeys(keys)”">​</a></h3><p><strong>Added in: v3.0.0</strong></p><ul><li><code>keys</code> <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" target="_blank" rel="noreferrer">&lt;TypedArray&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" target="_blank" rel="noreferrer">&lt;DataView&gt;</a> 一个包含会话票证密钥的 48 字节缓冲区。</li></ul><p>设置会话票证密钥。</p><p>对票证密钥的更改仅对未来的服务器连接有效。 现有或当前待处理的服务器连接将使用先前的密钥。</p><p>更多信息请参见 <a href="/zh/nodejs/api/tls#session-resumption">会话恢复</a>。</p><h2 id="class-tlstlssocket" tabindex="-1">Class: <code>tls.TLSSocket</code> <a class="header-anchor" href="#class-tlstlssocket" aria-label="Permalink to “Class: tls.TLSSocket”">​</a></h2><p><strong>Added in: v0.11.4</strong></p><ul><li>继承自: <a href="/zh/nodejs/api/net#class-netsocket">&lt;net.Socket&gt;</a></li></ul><p>执行写入数据的透明加密和所有必需的 TLS 协商。</p><p><code>tls.TLSSocket</code> 的实例实现了双工 <a href="/zh/nodejs/api/stream#stream">Stream</a> 接口。</p><p>返回 TLS 连接元数据的方法（例如 <a href="/zh/nodejs/api/tls#tlssocketgetpeercertificatedetailed"><code>tls.TLSSocket.getPeerCertificate()</code></a>）仅在连接打开时才返回数据。</p><h3 id="new-tlstlssocketsocket-options" tabindex="-1"><code>new tls.TLSSocket(socket[, options])</code> <a class="header-anchor" href="#new-tlstlssocketsocket-options" aria-label="Permalink to “new tls.TLSSocket(socket[, options])”">​</a></h3><div class="info custom-block"><p class="custom-block-title">[历史记录]</p><table tabindex="0"><thead><tr><th>版本</th><th>变更</th></tr></thead><tbody><tr><td>v12.2.0</td><td>现在支持 <code>enableTrace</code> 选项。</td></tr><tr><td>v5.0.0</td><td>现在支持 ALPN 选项。</td></tr><tr><td>v0.11.4</td><td>添加于: v0.11.4</td></tr></tbody></table></div><ul><li><code>socket</code> <a href="/zh/nodejs/api/net#class-netsocket">&lt;net.Socket&gt;</a> | <a href="/zh/nodejs/api/stream#class-streamduplex">&lt;stream.Duplex&gt;</a> 在服务器端，任何 <code>Duplex</code> 流。 在客户端，任何 <a href="/zh/nodejs/api/net#class-netsocket"><code>net.Socket</code></a> 的实例 (为了在客户端支持通用的 <code>Duplex</code> 流，必须使用 <a href="/zh/nodejs/api/tls#tlsconnectoptions-callback"><code>tls.connect()</code></a>)。</li><li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a><ul><li><code>enableTrace</code>: 参见 <a href="/zh/nodejs/api/tls#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a></li><li><code>isServer</code>: SSL/TLS 协议是不对称的，TLSSocket 必须知道它们是作为服务器还是客户端。 如果 <code>true</code>，则 TLS 套接字将实例化为服务器。 <strong>默认值:</strong> <code>false</code>。</li><li><code>server</code> <a href="/zh/nodejs/api/net#class-netserver">&lt;net.Server&gt;</a> 一个 <a href="/zh/nodejs/api/net#class-netserver"><code>net.Server</code></a> 实例。</li><li><code>requestCert</code>: 是否通过请求证书来验证远程对等方。 客户端始终请求服务器证书。 服务器 ( <code>isServer</code> 为 true) 可以将 <code>requestCert</code> 设置为 true 以请求客户端证书。</li><li><code>rejectUnauthorized</code>: 参见 <a href="/zh/nodejs/api/tls#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a></li><li><code>ALPNProtocols</code>: 参见 <a href="/zh/nodejs/api/tls#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a></li><li><code>SNICallback</code>: 参见 <a href="/zh/nodejs/api/tls#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a></li><li><code>session</code> <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> 一个包含 TLS 会话的 <code>Buffer</code> 实例。</li><li><code>requestOCSP</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" target="_blank" rel="noreferrer">&lt;boolean&gt;</a> 如果为 <code>true</code>，则指定 OCSP 状态请求扩展将添加到客户端 hello，并且在建立安全通信之前，将在套接字上发出 <code>&#39;OCSPResponse&#39;</code> 事件</li><li><code>secureContext</code>: 使用 <a href="/zh/nodejs/api/tls#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 创建的 TLS 上下文对象。 如果 <em>未</em> 提供 <code>secureContext</code>，则将通过将整个 <code>options</code> 对象传递给 <code>tls.createSecureContext()</code> 来创建一个。</li><li>...: 如果缺少 <code>secureContext</code> 选项，则使用 <a href="/zh/nodejs/api/tls#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 选项。 否则，它们将被忽略。</li></ul></li></ul><p>从现有的 TCP 套接字构造一个新的 <code>tls.TLSSocket</code> 对象。</p><h3 id="event-keylog_1" tabindex="-1">事件: <code>&#39;keylog&#39;</code> <a class="header-anchor" href="#event-keylog_1" aria-label="Permalink to “事件: &#39;keylog&#39;”">​</a></h3><p><strong>新增于: v12.3.0, v10.20.0</strong></p><ul><li><code>line</code> <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> ASCII 文本行，采用 NSS <code>SSLKEYLOGFILE</code> 格式。</li></ul><p>当套接字生成或接收到密钥材料时，<code>keylog</code> 事件会在 <code>tls.TLSSocket</code> 上发出。可以存储此密钥材料以进行调试，因为它允许解密捕获的 TLS 流量。它可能会在握手完成之前或之后多次发出。</p><p>一个典型的用例是将接收到的行附加到一个公共文本文件中，该文件稍后被软件（如 Wireshark）用于解密流量：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> logFile</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createWriteStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/tmp/ssl-keys.log&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { flags: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tlsSocket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;keylog&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">line</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> logFile.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(line));</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="event-ocspresponse" tabindex="-1">事件: <code>&#39;OCSPResponse&#39;</code> <a class="header-anchor" href="#event-ocspresponse" aria-label="Permalink to “事件: &#39;OCSPResponse&#39;”">​</a></h3><p><strong>新增于: v0.11.13</strong></p><p>如果在创建 <code>tls.TLSSocket</code> 时设置了 <code>requestOCSP</code> 选项，并且已收到 OCSP 响应，则会发出 <code>&#39;OCSPResponse&#39;</code> 事件。调用侦听器回调时，会传递一个参数：</p><ul><li><code>response</code> <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> 服务器的 OCSP 响应</li></ul><p>通常，<code>response</code> 是服务器 CA 的数字签名对象，其中包含有关服务器证书吊销状态的信息。</p><h3 id="event-secureconnect" tabindex="-1">事件: <code>&#39;secureConnect&#39;</code> <a class="header-anchor" href="#event-secureconnect" aria-label="Permalink to “事件: &#39;secureConnect&#39;”">​</a></h3><p><strong>新增于: v0.11.4</strong></p><p>当新连接的握手过程成功完成后，会发出 <code>&#39;secureConnect&#39;</code> 事件。无论服务器的证书是否经过授权，都将调用侦听器回调。客户端有责任检查 <code>tlsSocket.authorized</code> 属性，以确定服务器证书是否由指定的 CA 之一签名。如果 <code>tlsSocket.authorized === false</code>，则可以通过检查 <code>tlsSocket.authorizationError</code> 属性来找到错误。如果使用了 ALPN，则可以检查 <code>tlsSocket.alpnProtocol</code> 属性以确定协商的协议。</p><p>当使用 <code>new tls.TLSSocket()</code> 构造函数创建 <a href="/zh/nodejs/api/tls#class-tlstlssocket">&lt;tls.TLSSocket&gt;</a> 时，不会发出 <code>&#39;secureConnect&#39;</code> 事件。</p><h3 id="event-session" tabindex="-1">事件: <code>&#39;session&#39;</code> <a class="header-anchor" href="#event-session" aria-label="Permalink to “事件: &#39;session&#39;”">​</a></h3><p><strong>加入版本: v11.10.0</strong></p><ul><li><code>session</code> <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a></li></ul><p>当新的会话或 TLS 票据可用时，客户端 <code>tls.TLSSocket</code> 上会发出 <code>&#39;session&#39;</code> 事件。 这可能发生在握手完成之前或之后，具体取决于协商的 TLS 协议版本。 该事件不会在服务器上发出，或者在未创建新会话时发出，例如，当连接恢复时。 对于某些 TLS 协议版本，该事件可能会多次发出，在这种情况下，所有会话都可以用于恢复。</p><p>在客户端上，可以将 <code>session</code> 提供给 <a href="/zh/nodejs/api/tls#tlsconnectoptions-callback"><code>tls.connect()</code></a> 的 <code>session</code> 选项以恢复连接。</p><p>有关更多信息，请参见 <a href="/zh/nodejs/api/tls#session-resumption">会话恢复</a>。</p><p>对于 TLSv1.2 及更低版本，一旦握手完成，可以调用 <a href="/zh/nodejs/api/tls#tlssocketgetsession"><code>tls.TLSSocket.getSession()</code></a>。 对于 TLSv1.3，协议仅允许基于票据的恢复，发送多个票据，并且票据直到握手完成后才发送。 因此，必须等待 <code>&#39;session&#39;</code> 事件才能获取可恢复的会话。 应用程序应使用 <code>&#39;session&#39;</code> 事件而不是 <code>getSession()</code> 以确保它们适用于所有 TLS 版本。 仅期望获取或使用一个会话的应用程序应仅侦听此事件一次：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tlsSocket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">once</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;session&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">session</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 会话可以立即使用或稍后使用。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  tls.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    session: session,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 其他连接选项...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="tlssocketaddress" tabindex="-1"><code>tlsSocket.address()</code> <a class="header-anchor" href="#tlssocketaddress" aria-label="Permalink to “tlsSocket.address()”">​</a></h3><div class="info custom-block"><p class="custom-block-title">[历史记录]</p><table tabindex="0"><thead><tr><th>版本</th><th>变更</th></tr></thead><tbody><tr><td>v18.4.0</td><td><code>family</code> 属性现在返回一个字符串而不是一个数字。</td></tr><tr><td>v18.0.0</td><td><code>family</code> 属性现在返回一个数字而不是一个字符串。</td></tr><tr><td>v0.11.4</td><td>加入版本: v0.11.4</td></tr></tbody></table></div><ul><li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a></li></ul><p>返回底层套接字的绑定 <code>address</code>、地址 <code>family</code> 名称和 <code>port</code>，由操作系统报告：<code>{ port: 12346, family: &#39;IPv4&#39;, address: &#39;127.0.0.1&#39; }</code>。</p><h3 id="tlssocketauthorizationerror" tabindex="-1"><code>tlsSocket.authorizationError</code> <a class="header-anchor" href="#tlssocketauthorizationerror" aria-label="Permalink to “tlsSocket.authorizationError”">​</a></h3><p><strong>新增于: v0.11.4</strong></p><p>返回对等证书未被验证的原因。 仅当 <code>tlsSocket.authorized === false</code> 时，此属性才会被设置。</p><h3 id="tlssocketauthorized" tabindex="-1"><code>tlsSocket.authorized</code> <a class="header-anchor" href="#tlssocketauthorized" aria-label="Permalink to “tlsSocket.authorized”">​</a></h3><p><strong>新增于: v0.11.4</strong></p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" target="_blank" rel="noreferrer">&lt;boolean&gt;</a></li></ul><p>如果对等证书由创建 <code>tls.TLSSocket</code> 实例时指定的 CA 之一签名，则此属性为 <code>true</code>，否则为 <code>false</code>。</p><h3 id="tlssocketdisablerenegotiation" tabindex="-1"><code>tlsSocket.disableRenegotiation()</code> <a class="header-anchor" href="#tlssocketdisablerenegotiation" aria-label="Permalink to “tlsSocket.disableRenegotiation()”">​</a></h3><p><strong>新增于: v8.4.0</strong></p><p>禁用此 <code>TLSSocket</code> 实例的 TLS 重新协商。 调用后，尝试重新协商将在 <code>TLSSocket</code> 上触发 <code>&#39;error&#39;</code> 事件。</p><h3 id="tlssocketenabletrace" tabindex="-1"><code>tlsSocket.enableTrace()</code> <a class="header-anchor" href="#tlssocketenabletrace" aria-label="Permalink to “tlsSocket.enableTrace()”">​</a></h3><p><strong>新增于: v12.2.0</strong></p><p>启用后，TLS 数据包跟踪信息将写入 <code>stderr</code>。 这可用于调试 TLS 连接问题。</p><p>输出格式与 <code>openssl s_client -trace</code> 或 <code>openssl s_server -trace</code> 的输出格式相同。 虽然它是由 OpenSSL 的 <code>SSL_trace()</code> 函数产生的，但该格式没有文档记录，可能会在没有通知的情况下发生变化，不应依赖它。</p><h3 id="tlssocketencrypted" tabindex="-1"><code>tlsSocket.encrypted</code> <a class="header-anchor" href="#tlssocketencrypted" aria-label="Permalink to “tlsSocket.encrypted”">​</a></h3><p><strong>新增于: v0.11.4</strong></p><p>始终返回 <code>true</code>。 这可用于区分 TLS 套接字和常规 <code>net.Socket</code> 实例。</p><h3 id="tlssocketexportkeyingmateriallength-label-context" tabindex="-1"><code>tlsSocket.exportKeyingMaterial(length, label[, context])</code> <a class="header-anchor" href="#tlssocketexportkeyingmateriallength-label-context" aria-label="Permalink to “tlsSocket.exportKeyingMaterial(length, label[, context])”">​</a></h3><p><strong>新增于: v13.10.0, v12.17.0</strong></p><ul><li><code>length</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" target="_blank" rel="noreferrer">&lt;number&gt;</a> 要从密钥材料中检索的字节数</li><li><code>label</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 应用程序特定的标签，通常这将是来自 <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#exporter-labels" target="_blank" rel="noreferrer">IANA Exporter Label Registry</a> 的值。</li><li><code>context</code> <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> 可选地提供一个上下文。</li><li>返回: <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> 所需的密钥材料字节</li></ul><p>密钥材料用于验证，以防止网络协议中的各种攻击，例如 IEEE 802.1X 的规范。</p><p>示例</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> keyingMaterial</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tlsSocket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">exportKeyingMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  128</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;client finished&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/*</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> Example return value of keyingMaterial:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> &lt;Buffer 76 26 af 99 c5 56 8e 42 09 91 ef 9f 93 cb ad 6c 7b 65 f8 53 f1 d8 d9</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    12 5a 33 b8 b5 25 df 7b 37 9f e0 e2 4f b8 67 83 a3 2f cd 5d 41 42 4c 91</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    74 ef 2c ... 78 more bytes&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">*/</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>有关更多信息，请参阅 OpenSSL <a href="https://www.openssl.org/docs/man1.1.1/man3/SSL_export_keying_material" target="_blank" rel="noreferrer"><code>SSL_export_keying_material</code></a> 文档。</p><h3 id="tlssocketgetcertificate" tabindex="-1"><code>tlsSocket.getCertificate()</code> <a class="header-anchor" href="#tlssocketgetcertificate" aria-label="Permalink to “tlsSocket.getCertificate()”">​</a></h3><p><strong>Added in: v11.2.0</strong></p><ul><li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a></li></ul><p>返回表示本地证书的对象。 返回的对象具有一些与证书字段相对应的属性。</p><p>有关证书结构的示例，请参见 <a href="/zh/nodejs/api/tls#tlssocketgetpeercertificatedetailed"><code>tls.TLSSocket.getPeerCertificate()</code></a>。</p><p>如果没有本地证书，将返回一个空对象。 如果套接字已被销毁，则将返回 <code>null</code>。</p><h3 id="tlssocketgetcipher" tabindex="-1"><code>tlsSocket.getCipher()</code> <a class="header-anchor" href="#tlssocketgetcipher" aria-label="Permalink to “tlsSocket.getCipher()”">​</a></h3><div class="info custom-block"><p class="custom-block-title">[历史]</p><table tabindex="0"><thead><tr><th>版本</th><th>变更</th></tr></thead><tbody><tr><td>v13.4.0, v12.16.0</td><td>以 <code>standardName</code> 返回 IETF 密码名称。</td></tr><tr><td>v12.0.0</td><td>返回最小密码版本，而不是固定的字符串 (<code>&#39;TLSv1/SSLv3&#39;</code>)。</td></tr><tr><td>v0.11.4</td><td>添加于: v0.11.4</td></tr></tbody></table></div><ul><li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a><ul><li><code>name</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 密码套件的 OpenSSL 名称。</li><li><code>standardName</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 密码套件的 IETF 名称。</li><li><code>version</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 此密码套件支持的最小 TLS 协议版本。 有关实际协商的协议，请参见 <a href="/zh/nodejs/api/tls#tlssocketgetprotocol"><code>tls.TLSSocket.getProtocol()</code></a>。</li></ul></li></ul><p>返回一个包含有关协商的密码套件的信息的对象。</p><p>例如，带有 AES256-SHA 密码的 TLSv1.2 协议：</p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;AES256-SHA&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;standardName&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;TLS_RSA_WITH_AES_256_CBC_SHA&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;version&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;SSLv3&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>有关更多信息，请参见 <a href="https://www.openssl.org/docs/man1.1.1/man3/SSL_CIPHER_get_name" target="_blank" rel="noreferrer">SSL_CIPHER_get_name</a>。</p><h3 id="tlssocketgetephemeralkeyinfo" tabindex="-1"><code>tlsSocket.getEphemeralKeyInfo()</code> <a class="header-anchor" href="#tlssocketgetephemeralkeyinfo" aria-label="Permalink to “tlsSocket.getEphemeralKeyInfo()”">​</a></h3><p><strong>Added in: v5.0.0</strong></p><ul><li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a></li></ul><p>返回一个对象，该对象表示客户端连接上<a href="/zh/nodejs/api/tls#perfect-forward-secrecy">完全正向保密</a>中临时密钥交换的参数的类型、名称和大小。 当密钥交换不是临时的时，它返回一个空对象。 由于这仅在客户端套接字上受支持，因此如果在服务器套接字上调用，则返回 <code>null</code>。 支持的类型为 <code>&#39;DH&#39;</code> 和 <code>&#39;ECDH&#39;</code>。 仅当类型为 <code>&#39;ECDH&#39;</code> 时，<code>name</code> 属性才可用。</p><p>例如：<code>{ type: &#39;ECDH&#39;, name: &#39;prime256v1&#39;, size: 256 }</code>。</p><h3 id="tlssocketgetfinished" tabindex="-1"><code>tlsSocket.getFinished()</code> <a class="header-anchor" href="#tlssocketgetfinished" aria-label="Permalink to “tlsSocket.getFinished()”">​</a></h3><p><strong>新增于: v9.9.0</strong></p><ul><li>返回: <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type" target="_blank" rel="noreferrer">&lt;undefined&gt;</a> 作为 SSL/TLS 握手的一部分，最近发送到套接字的 <code>Finished</code> 消息，如果尚未发送任何 <code>Finished</code> 消息，则返回 <code>undefined</code>。</li></ul><p>由于 <code>Finished</code> 消息是完整握手的消息摘要（对于 TLS 1.0 总共有 192 位，对于 SSL 3.0 更多），因此当不需要或不足以使用 SSL/TLS 提供的身份验证时，它们可以用于外部身份验证过程。</p><p>对应于 OpenSSL 中的 <code>SSL_get_finished</code> 例程，可用于实现 <a href="https://tools.ietf.org/html/rfc5929" target="_blank" rel="noreferrer">RFC 5929</a> 中的 <code>tls-unique</code> 通道绑定。</p><h3 id="tlssocketgetpeercertificatedetailed" tabindex="-1"><code>tlsSocket.getPeerCertificate([detailed])</code> <a class="header-anchor" href="#tlssocketgetpeercertificatedetailed" aria-label="Permalink to “tlsSocket.getPeerCertificate([detailed])”">​</a></h3><p><strong>新增于: v0.11.4</strong></p><ul><li><code>detailed</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" target="_blank" rel="noreferrer">&lt;boolean&gt;</a> 如果为 <code>true</code>，则包含完整的证书链，否则仅包含对等方的证书。</li><li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a> 证书对象。</li></ul><p>返回表示对等方证书的对象。 如果对等方未提供证书，则将返回一个空对象。 如果套接字已被销毁，则将返回 <code>null</code>。</p><p>如果请求了完整的证书链，则每个证书将包含一个 <code>issuerCertificate</code> 属性，其中包含表示其颁发者证书的对象。</p><h4 id="certificate-object" tabindex="-1">证书对象 <a class="header-anchor" href="#certificate-object" aria-label="Permalink to “证书对象”">​</a></h4><div class="info custom-block"><p class="custom-block-title">[历史]</p><table tabindex="0"><thead><tr><th>版本</th><th>更改</th></tr></thead><tbody><tr><td>v19.1.0, v18.13.0</td><td>添加 &quot;ca&quot; 属性。</td></tr><tr><td>v17.2.0, v16.14.0</td><td>添加 fingerprint512。</td></tr><tr><td>v11.4.0</td><td>支持椭圆曲线公钥信息。</td></tr></tbody></table></div><p>证书对象具有对应于证书字段的属性。</p><ul><li><code>ca</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" target="_blank" rel="noreferrer">&lt;boolean&gt;</a> 如果是证书颁发机构 (CA)，则为 <code>true</code>，否则为 <code>false</code>。</li><li><code>raw</code> <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> DER 编码的 X.509 证书数据。</li><li><code>subject</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a> 证书主题，以国家 (<code>C</code>)、州/省 (<code>ST</code>)、城市 (<code>L</code>)、组织 (<code>O</code>)、组织单位 (<code>OU</code>) 和通用名称 (<code>CN</code>) 描述。 通用名称通常是具有 TLS 证书的 DNS 名称。 示例：<code>{C: &#39;UK&#39;, ST: &#39;BC&#39;, L: &#39;Metro&#39;, O: &#39;Node Fans&#39;, OU: &#39;Docs&#39;, CN: &#39;example.com&#39;}</code>。</li><li><code>issuer</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a> 证书颁发者，以与 <code>subject</code> 相同的术语描述。</li><li><code>valid_from</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 证书有效的开始日期时间。</li><li><code>valid_to</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 证书有效的结束日期时间。</li><li><code>serialNumber</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 证书序列号，作为十六进制字符串。 示例：<code>&#39;B9B0D332A1AA5635&#39;</code>。</li><li><code>fingerprint</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> DER 编码证书的 SHA-1 摘要。 它作为 <code>:</code> 分隔的十六进制字符串返回。 示例：<code>&#39;2A:7A:C2:DD:...&#39;</code>。</li><li><code>fingerprint256</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> DER 编码证书的 SHA-256 摘要。 它作为 <code>:</code> 分隔的十六进制字符串返回。 示例：<code>&#39;2A:7A:C2:DD:...&#39;</code>。</li><li><code>fingerprint512</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> DER 编码证书的 SHA-512 摘要。 它作为 <code>:</code> 分隔的十六进制字符串返回。 示例：<code>&#39;2A:7A:C2:DD:...&#39;</code>。</li><li><code>ext_key_usage</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noreferrer">&lt;Array&gt;</a> (可选) 扩展密钥用法，一组 OID。</li><li><code>subjectaltname</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> (可选) 一个包含主题连接名称的字符串，是 <code>subject</code> 名称的替代方法。</li><li><code>infoAccess</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noreferrer">&lt;Array&gt;</a> (可选) 一个描述 AuthorityInfoAccess 的数组，与 OCSP 一起使用。</li><li><code>issuerCertificate</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a> (可选) 颁发者证书对象。 对于自签名证书，这可能是一个循环引用。</li></ul><p>证书可能包含有关公钥的信息，具体取决于密钥类型。</p><p>对于 RSA 密钥，可以定义以下属性：</p><ul><li><code>bits</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" target="_blank" rel="noreferrer">&lt;number&gt;</a> RSA 位大小。 示例：<code>1024</code>。</li><li><code>exponent</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> RSA 指数，以十六进制数字表示的字符串。 示例：<code>&#39;0x010001&#39;</code>。</li><li><code>modulus</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> RSA 模数，作为十六进制字符串。 示例：<code>&#39;B56CE45CB7...&#39;</code>。</li><li><code>pubkey</code> <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> 公钥。</li></ul><p>对于 EC 密钥，可以定义以下属性：</p><ul><li><code>pubkey</code> <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> 公钥。</li><li><code>bits</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" target="_blank" rel="noreferrer">&lt;number&gt;</a> 密钥大小，以位为单位。 示例：<code>256</code>。</li><li><code>asn1Curve</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> (可选) 椭圆曲线的 OID 的 ASN.1 名称。 众所周知的曲线由 OID 标识。 虽然不常见，但曲线可能由其数学属性标识，在这种情况下它将没有 OID。 示例：<code>&#39;prime256v1&#39;</code>。</li><li><code>nistCurve</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> (可选) 椭圆曲线的 NIST 名称（如果有）（并非所有众所周知的曲线都已由 NIST 分配名称）。 示例：<code>&#39;P-256&#39;</code>。</li></ul><p>证书示例：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">subject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OU</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [ </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Domain Control Validated&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;PositiveSSL Wildcard&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ],</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     CN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;*.nodejs.org&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  issuer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;GB&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     ST</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Greater Manchester&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Salford&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     O</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;COMODO CA Limited&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     CN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;COMODO RSA Domain Validation Secure Server CA&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  subjectaltname</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;DNS:*.nodejs.org, DNS:nodejs.org&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  infoAccess</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   { </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;CA Issuers - URI&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      [ </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;http://crt.comodoca.com/COMODORSADomainValidationSecureServerCA.crt&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ],</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">     &#39;OCSP - URI&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [ </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;http://ocsp.comodoca.com&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ] },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  modulus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;B56CE45CB740B09A13F64AC543B712FF9EE8E4C284B542A1708A27E82A8D151CA178153E12E6DDA15BF70FFD96CB8A88618641BDFCCA03527E665B70D779C8A349A6F88FD4EF6557180BD4C98192872BCFE3AF56E863C09DDD8BC1EC58DF9D94F914F0369102B2870BECFA1348A0838C9C49BD1C20124B442477572347047506B1FCD658A80D0C44BCC16BC5C5496CFE6E4A8428EF654CD3D8972BF6E5BFAD59C93006830B5EB1056BBB38B53D1464FA6E02BFDF2FF66CD949486F0775EC43034EC2602AEFBF1703AD221DAA2A88353C3B6A688EFE8387811F645CEED7B3FE46E1F8B9F59FAD028F349B9BC14211D5830994D055EEA3D547911E07A0ADDEB8A82B9188E58720D95CD478EEC9AF1F17BE8141BE80906F1A339445A7EB5B285F68039B0F294598A7D1C0005FC22B5271B0752F58CCDEF8C8FD856FB7AE21C80B8A2CE983AE94046E53EDE4CB89F42502D31B5360771C01C80155918637490550E3F555E2EE75CC8C636DDE3633CFEDD62E91BF0F7688273694EEEBA20C2FC9F14A2A435517BC1D7373922463409AB603295CEB0BB53787A334C9CA3CA8B30005C5A62FC0715083462E00719A8FA3ED0A9828C3871360A73F8B04A4FC1E71302844E9BB9940B77E745C9D91F226D71AFCAD4B113AAF68D92B24DDB4A2136B55A1CD1ADF39605B63CB639038ED0F4C987689866743A68769CC55847E4A06D6E2E3F1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  exponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;0x10001&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  pubkey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Buffer</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &gt;,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  valid_from: &#39;Aug 14 00:00:00 2017 GMT&#39;,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  valid_to: &#39;Nov 20 23:59:59 2019 GMT&#39;,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  fingerprint: &#39;01:02:59:D9:C3:D2:0D:08:F7:82:4E:44:A4:B4:53:C5:E2:3A:87:4D&#39;,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  fingerprint256: &#39;69:AE:1A:6A:D4:3D:C6:C1:1B:EA:C6:23:DE:BA:2A:14:62:62:93:5C:7A:EA:06:41:9B:0B:BC:87:CE:48:4E:02&#39;,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  fingerprint512: &#39;19:2B:3E:C3:B3:5B:32:E8:AE:BB:78:97:27:E4:BA:6C:39:C9:92:79:4F:31:46:39:E2:70:E5:5F:89:42:17:C9:E8:64:CA:FF:BB:72:56:73:6E:28:8A:92:7E:A3:2A:15:8B:C2:E0:45:CA:C3:BC:EA:40:52:EC:CA:A2:68:CB:32&#39;,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ext_key_usage: [ &#39;1.3.6.1.5.5.7.3.1&#39;, &#39;1.3.6.1.5.5.7.3.2&#39; ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  serialNumber: &#39;66593D57F20CBC573E433381B5FEC280&#39;,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  raw: &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Buffer</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &gt; }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h3 id="tlssocketgetpeerfinished" tabindex="-1"><code>tlsSocket.getPeerFinished()</code> <a class="header-anchor" href="#tlssocketgetpeerfinished" aria-label="Permalink to “tlsSocket.getPeerFinished()”">​</a></h3><p><strong>新增于: v9.9.0</strong></p><ul><li>返回: <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type" target="_blank" rel="noreferrer">&lt;undefined&gt;</a> 作为 SSL/TLS 握手的一部分，期望或实际从套接字接收到的最新 <code>Finished</code> 消息，如果目前没有 <code>Finished</code> 消息，则返回 <code>undefined</code>。</li></ul><p>由于 <code>Finished</code> 消息是完整握手的消息摘要（对于 TLS 1.0 总共有 192 位，对于 SSL 3.0 则更多），因此当不需要或不足以使用 SSL/TLS 提供的身份验证时，它们可用于外部身份验证过程。</p><p>对应于 OpenSSL 中的 <code>SSL_get_peer_finished</code> 例程，并且可以用于实现 <a href="https://tools.ietf.org/html/rfc5929" target="_blank" rel="noreferrer">RFC 5929</a> 中的 <code>tls-unique</code> 通道绑定。</p><h3 id="tlssocketgetpeerx509certificate" tabindex="-1"><code>tlsSocket.getPeerX509Certificate()</code> <a class="header-anchor" href="#tlssocketgetpeerx509certificate" aria-label="Permalink to “tlsSocket.getPeerX509Certificate()”">​</a></h3><p><strong>新增于: v15.9.0</strong></p><ul><li>返回: <a href="/zh/nodejs/api/crypto#class-x509certificate">&lt;X509Certificate&gt;</a></li></ul><p>返回对等证书作为 <a href="/zh/nodejs/api/crypto#class-x509certificate">&lt;X509Certificate&gt;</a> 对象。</p><p>如果没有对等证书，或者套接字已被销毁，将返回 <code>undefined</code>。</p><h3 id="tlssocketgetprotocol" tabindex="-1"><code>tlsSocket.getProtocol()</code> <a class="header-anchor" href="#tlssocketgetprotocol" aria-label="Permalink to “tlsSocket.getProtocol()”">​</a></h3><p><strong>新增于: v5.7.0</strong></p><ul><li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type" target="_blank" rel="noreferrer">&lt;null&gt;</a></li></ul><p>返回一个字符串，其中包含当前连接的协商 SSL/TLS 协议版本。 对于尚未完成握手过程的已连接套接字，将返回值 <code>&#39;unknown&#39;</code>。 对于服务器套接字或已断开连接的客户端套接字，将返回值 <code>null</code>。</p><p>协议版本包括：</p><ul><li><code>&#39;SSLv3&#39;</code></li><li><code>&#39;TLSv1&#39;</code></li><li><code>&#39;TLSv1.1&#39;</code></li><li><code>&#39;TLSv1.2&#39;</code></li><li><code>&#39;TLSv1.3&#39;</code></li></ul><p>有关更多信息，请参见 OpenSSL <a href="https://www.openssl.org/docs/man1.1.1/man3/SSL_get_version" target="_blank" rel="noreferrer"><code>SSL_get_version</code></a> 文档。</p><h3 id="tlssocketgetsession" tabindex="-1"><code>tlsSocket.getSession()</code> <a class="header-anchor" href="#tlssocketgetsession" aria-label="Permalink to “tlsSocket.getSession()”">​</a></h3><p><strong>新增于: v0.11.4</strong></p><ul><li><a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a></li></ul><p>如果未协商会话，则返回 TLS 会话数据，否则返回 <code>undefined</code>。 在客户端上，可以将数据提供给 <a href="/zh/nodejs/api/tls#tlsconnectoptions-callback"><code>tls.connect()</code></a> 的 <code>session</code> 选项以恢复连接。 在服务器上，它可能对调试有用。</p><p>有关更多信息，请参见<a href="/zh/nodejs/api/tls#session-resumption">会话恢复</a>。</p><p>注意：<code>getSession()</code> 仅适用于 TLSv1.2 及更低版本。 对于 TLSv1.3，应用程序必须使用 <a href="/zh/nodejs/api/tls#event-session"><code>&#39;session&#39;</code></a> 事件（它也适用于 TLSv1.2 及更低版本）。</p><h3 id="tlssocketgetsharedsigalgs" tabindex="-1"><code>tlsSocket.getSharedSigalgs()</code> <a class="header-anchor" href="#tlssocketgetsharedsigalgs" aria-label="Permalink to “tlsSocket.getSharedSigalgs()”">​</a></h3><p><strong>新增于: v12.11.0</strong></p><ul><li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noreferrer">&lt;Array&gt;</a> 服务端和客户端共享的签名算法列表，按偏好递减的顺序排列。</li></ul><p>更多信息请参见 <a href="https://www.openssl.org/docs/man1.1.1/man3/SSL_get_shared_sigalgs" target="_blank" rel="noreferrer">SSL_get_shared_sigalgs</a>。</p><h3 id="tlssocketgettlsticket" tabindex="-1"><code>tlsSocket.getTLSTicket()</code> <a class="header-anchor" href="#tlssocketgettlsticket" aria-label="Permalink to “tlsSocket.getTLSTicket()”">​</a></h3><p><strong>新增于: v0.11.4</strong></p><ul><li><a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a></li></ul><p>对于客户端，如果存在 TLS 会话票证，则返回该票证，否则返回 <code>undefined</code>。对于服务器，始终返回 <code>undefined</code>。</p><p>它可能对调试有用。</p><p>更多信息请参见 <a href="/zh/nodejs/api/tls#session-resumption">会话恢复</a>。</p><h3 id="tlssocketgetx509certificate" tabindex="-1"><code>tlsSocket.getX509Certificate()</code> <a class="header-anchor" href="#tlssocketgetx509certificate" aria-label="Permalink to “tlsSocket.getX509Certificate()”">​</a></h3><p><strong>新增于: v15.9.0</strong></p><ul><li>返回: <a href="/zh/nodejs/api/crypto#class-x509certificate">&lt;X509Certificate&gt;</a></li></ul><p>将本地证书作为 <a href="/zh/nodejs/api/crypto#class-x509certificate">&lt;X509Certificate&gt;</a> 对象返回。</p><p>如果没有本地证书，或者套接字已被销毁，将返回 <code>undefined</code>。</p><h3 id="tlssocketissessionreused" tabindex="-1"><code>tlsSocket.isSessionReused()</code> <a class="header-anchor" href="#tlssocketissessionreused" aria-label="Permalink to “tlsSocket.isSessionReused()”">​</a></h3><p><strong>新增于: v0.5.6</strong></p><ul><li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" target="_blank" rel="noreferrer">&lt;boolean&gt;</a> 如果会话被重用，则返回 <code>true</code>，否则返回 <code>false</code>。</li></ul><p>更多信息请参见 <a href="/zh/nodejs/api/tls#session-resumption">会话恢复</a>。</p><h3 id="tlssocketlocaladdress" tabindex="-1"><code>tlsSocket.localAddress</code> <a class="header-anchor" href="#tlssocketlocaladdress" aria-label="Permalink to “tlsSocket.localAddress”">​</a></h3><p><strong>新增于: v0.11.4</strong></p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a></li></ul><p>返回本地 IP 地址的字符串表示形式。</p><h3 id="tlssocketlocalport" tabindex="-1"><code>tlsSocket.localPort</code> <a class="header-anchor" href="#tlssocketlocalport" aria-label="Permalink to “tlsSocket.localPort”">​</a></h3><p><strong>新增于: v0.11.4</strong></p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" target="_blank" rel="noreferrer">&lt;integer&gt;</a></li></ul><p>返回本地端口的数字表示形式。</p><h3 id="tlssocketremoteaddress" tabindex="-1"><code>tlsSocket.remoteAddress</code> <a class="header-anchor" href="#tlssocketremoteaddress" aria-label="Permalink to “tlsSocket.remoteAddress”">​</a></h3><p><strong>新增于: v0.11.4</strong></p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a></li></ul><p>返回远程 IP 地址的字符串表示形式。 例如，<code>&#39;74.125.127.100&#39;</code> 或 <code>&#39;2001:4860:a005::68&#39;</code>。</p><h3 id="tlssocketremotefamily" tabindex="-1"><code>tlsSocket.remoteFamily</code> <a class="header-anchor" href="#tlssocketremotefamily" aria-label="Permalink to “tlsSocket.remoteFamily”">​</a></h3><p><strong>加入于: v0.11.4</strong></p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a></li></ul><p>返回远程 IP 族的字符串表示形式。 <code>&#39;IPv4&#39;</code> 或 <code>&#39;IPv6&#39;</code>。</p><h3 id="tlssocketremoteport" tabindex="-1"><code>tlsSocket.remotePort</code> <a class="header-anchor" href="#tlssocketremoteport" aria-label="Permalink to “tlsSocket.remotePort”">​</a></h3><p><strong>加入于: v0.11.4</strong></p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" target="_blank" rel="noreferrer">&lt;integer&gt;</a></li></ul><p>返回远程端口的数字表示形式。 例如，<code>443</code>。</p><h3 id="tlssocketrenegotiateoptions-callback" tabindex="-1"><code>tlsSocket.renegotiate(options, callback)</code> <a class="header-anchor" href="#tlssocketrenegotiateoptions-callback" aria-label="Permalink to “tlsSocket.renegotiate(options, callback)”">​</a></h3><div class="info custom-block"><p class="custom-block-title">[历史]</p><table tabindex="0"><thead><tr><th style="text-align:left;">版本</th><th style="text-align:left;">变更</th></tr></thead><tbody><tr><td style="text-align:left;">v18.0.0</td><td style="text-align:left;">将无效的回调传给 <code>callback</code> 参数现在会抛出 <code>ERR_INVALID_ARG_TYPE</code>，而不是 <code>ERR_INVALID_CALLBACK</code>。</td></tr><tr><td style="text-align:left;">v0.11.8</td><td style="text-align:left;">加入于: v0.11.8</td></tr></tbody></table></div><ul><li><p><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a></p><ul><li><code>rejectUnauthorized</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" target="_blank" rel="noreferrer">&lt;boolean&gt;</a> 如果不是 <code>false</code>，则服务器证书会针对提供的 CA 列表进行验证。 如果验证失败，则会发出 <code>&#39;error&#39;</code> 事件；<code>err.code</code> 包含 OpenSSL 错误代码。 <strong>默认值:</strong> <code>true</code>。</li><li><code>requestCert</code></li></ul></li><li><p><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noreferrer">&lt;Function&gt;</a> 如果 <code>renegotiate()</code> 返回 <code>true</code>，则回调函数会附加到 <code>&#39;secure&#39;</code> 事件一次。 如果 <code>renegotiate()</code> 返回 <code>false</code>，则 <code>callback</code> 将在下一个 tick 中被调用，并带有一个错误，除非 <code>tlsSocket</code> 已被销毁，在这种情况下，根本不会调用 <code>callback</code>。</p></li><li><p>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" target="_blank" rel="noreferrer">&lt;boolean&gt;</a> 如果发起重新协商则为 <code>true</code>，否则为 <code>false</code>。</p></li></ul><p><code>tlsSocket.renegotiate()</code> 方法启动 TLS 重新协商过程。 完成后，<code>callback</code> 函数将传递一个参数，该参数要么是 <code>Error</code>（如果请求失败），要么是 <code>null</code>。</p><p>此方法可用于在建立安全连接后请求对等方的证书。</p><p>当作为服务器运行时，套接字将在 <code>handshakeTimeout</code> 超时后被销毁并出现错误。</p><p>对于 TLSv1.3，无法启动重新协商，该协议不支持。</p><h3 id="tlssocketsetkeycertcontext" tabindex="-1"><code>tlsSocket.setKeyCert(context)</code> <a class="header-anchor" href="#tlssocketsetkeycertcontext" aria-label="Permalink to “tlsSocket.setKeyCert(context)”">​</a></h3><p><strong>新增于: v22.5.0, v20.17.0</strong></p><ul><li><code>context</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a> | <a href="/zh/nodejs/api/tls#tlscreatesecurecontextoptions">&lt;tls.SecureContext&gt;</a> 一个对象，包含来自 <a href="/zh/nodejs/api/tls#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> <code>options</code> 的至少 <code>key</code> 和 <code>cert</code> 属性，或者是一个使用 <a href="/zh/nodejs/api/tls#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 创建的 TLS 上下文对象本身。</li></ul><p><code>tlsSocket.setKeyCert()</code> 方法设置用于套接字的私钥和证书。 如果你希望从 TLS 服务器的 <code>ALPNCallback</code> 中选择服务器证书，这主要很有用。</p><h3 id="tlssocketsetmaxsendfragmentsize" tabindex="-1"><code>tlsSocket.setMaxSendFragment(size)</code> <a class="header-anchor" href="#tlssocketsetmaxsendfragmentsize" aria-label="Permalink to “tlsSocket.setMaxSendFragment(size)”">​</a></h3><p><strong>新增于: v0.11.11</strong></p><ul><li><code>size</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" target="_blank" rel="noreferrer">&lt;number&gt;</a> 最大 TLS 片段大小。 最大值为 <code>16384</code>。 <strong>默认:</strong> <code>16384</code>。</li><li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" target="_blank" rel="noreferrer">&lt;boolean&gt;</a></li></ul><p><code>tlsSocket.setMaxSendFragment()</code> 方法设置最大 TLS 片段大小。 如果设置限制成功，则返回 <code>true</code>； 否则返回 <code>false</code>。</p><p>较小的片段大小会减少客户端的缓冲延迟：较大的片段由 TLS 层缓冲，直到收到整个片段并验证其完整性； 大片段可能会跨越多个往返行程，并且由于数据包丢失或重新排序，其处理可能会延迟。 但是，较小的片段会增加额外的 TLS 帧字节和 CPU 开销，这可能会降低整体服务器吞吐量。</p><h2 id="tlscheckserveridentityhostname-cert" tabindex="-1"><code>tls.checkServerIdentity(hostname, cert)</code> <a class="header-anchor" href="#tlscheckserveridentityhostname-cert" aria-label="Permalink to “tls.checkServerIdentity(hostname, cert)”">​</a></h2><div class="info custom-block"><p class="custom-block-title">[历史]</p><table tabindex="0"><thead><tr><th>版本</th><th>变更</th></tr></thead><tbody><tr><td>v17.3.1, v16.13.2, v14.18.3, v12.22.9</td><td>为了响应 CVE-2021-44531，已禁用对 <code>uniformResourceIdentifier</code> 主题备用名称的支持。</td></tr><tr><td>v0.8.4</td><td>新增于: v0.8.4</td></tr></tbody></table></div><ul><li><code>hostname</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 要验证证书的主机名或 IP 地址。</li><li><code>cert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a> 代表对等证书的<a href="/zh/nodejs/api/tls#certificate-object">证书对象</a>。</li><li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" target="_blank" rel="noreferrer">&lt;Error&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type" target="_blank" rel="noreferrer">&lt;undefined&gt;</a></li></ul><p>验证证书 <code>cert</code> 是否颁发给 <code>hostname</code>。</p><p>返回 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" target="_blank" rel="noreferrer">&lt;Error&gt;</a> 对象，如果失败，则用 <code>reason</code>、<code>host</code> 和 <code>cert</code> 填充它。 成功时，返回 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type" target="_blank" rel="noreferrer">&lt;undefined&gt;</a>。</p><p>此函数旨在与传递给 <a href="/zh/nodejs/api/tls#tlsconnectoptions-callback"><code>tls.connect()</code></a> 的 <code>checkServerIdentity</code> 选项结合使用，因此它对<a href="/zh/nodejs/api/tls#certificate-object">证书对象</a>进行操作。 对于其他目的，请考虑改用 <a href="/zh/nodejs/api/crypto#x509checkhostname-options"><code>x509.checkHost()</code></a>。</p><p>可以通过提供作为传递给 <code>tls.connect()</code> 的 <code>options.checkServerIdentity</code> 选项的替代函数来覆盖此函数。 覆盖函数当然可以调用 <code>tls.checkServerIdentity()</code>，以通过额外的验证来增强完成的检查。</p><p>仅当证书通过所有其他检查（例如由受信任的 CA 颁发 (<code>options.ca</code>)）时，才会调用此函数。</p><p>如果存在匹配的 <code>uniformResourceIdentifier</code> 主题备用名称，则早期版本的 Node.js 会错误地接受给定 <code>hostname</code> 的证书（请参阅 <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44531" target="_blank" rel="noreferrer">CVE-2021-44531</a>）。 希望接受 <code>uniformResourceIdentifier</code> 主题备用名称的应用程序可以使用自定义 <code>options.checkServerIdentity</code> 函数来实现所需的行为。</p><h2 id="tlsconnectoptions-callback" tabindex="-1"><code>tls.connect(options[, callback])</code> <a class="header-anchor" href="#tlsconnectoptions-callback" aria-label="Permalink to “tls.connect(options[, callback])”">​</a></h2><div class="info custom-block"><p class="custom-block-title">[历史记录]</p><table tabindex="0"><thead><tr><th>版本</th><th>变更</th></tr></thead><tbody><tr><td>v15.1.0, v14.18.0</td><td>添加了 <code>onread</code> 选项。</td></tr><tr><td>v14.1.0, v13.14.0</td><td>现在接受 <code>highWaterMark</code> 选项。</td></tr><tr><td>v13.6.0, v12.16.0</td><td>现在支持 <code>pskCallback</code> 选项。</td></tr><tr><td>v12.9.0</td><td>支持 <code>allowHalfOpen</code> 选项。</td></tr><tr><td>v12.4.0</td><td>现在支持 <code>hints</code> 选项。</td></tr><tr><td>v12.2.0</td><td>现在支持 <code>enableTrace</code> 选项。</td></tr><tr><td>v11.8.0, v10.16.0</td><td>现在支持 <code>timeout</code> 选项。</td></tr><tr><td>v8.0.0</td><td>现在支持 <code>lookup</code> 选项。</td></tr><tr><td>v8.0.0</td><td><code>ALPNProtocols</code> 选项现在可以是 <code>TypedArray</code> 或 <code>DataView</code>。</td></tr><tr><td>v5.0.0</td><td>现在支持 ALPN 选项。</td></tr><tr><td>v5.3.0, v4.7.0</td><td>现在支持 <code>secureContext</code> 选项。</td></tr><tr><td>v0.11.3</td><td>添加于: v0.11.3</td></tr></tbody></table></div><ul><li><p><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a></p><ul><li><code>enableTrace</code>: 参见 <a href="/zh/nodejs/api/tls#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a></li><li><code>host</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 客户端应连接的主机。<strong>默认值:</strong> <code>&#39;localhost&#39;</code>。</li><li><code>port</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" target="_blank" rel="noreferrer">&lt;number&gt;</a> 客户端应连接的端口。</li><li><code>path</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 创建到路径的 Unix 套接字连接。 如果指定了此选项，则忽略 <code>host</code> 和 <code>port</code>。</li><li><code>socket</code> <a href="/zh/nodejs/api/stream#class-streamduplex">&lt;stream.Duplex&gt;</a> 在给定的套接字上建立安全连接，而不是创建新的套接字。 通常，这是 <a href="/zh/nodejs/api/net#class-netsocket"><code>net.Socket</code></a> 的实例，但允许任何 <code>Duplex</code> 流。 如果指定了此选项，则忽略 <code>path</code>、<code>host</code> 和 <code>port</code>，但证书验证除外。 通常，套接字在传递给 <code>tls.connect()</code> 时已经连接，但可以稍后连接。 <code>socket</code> 的连接/断开/销毁是用户的责任； 调用 <code>tls.connect()</code> 不会导致调用 <code>net.connect()</code>。</li><li><code>allowHalfOpen</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" target="_blank" rel="noreferrer">&lt;boolean&gt;</a> 如果设置为 <code>false</code>，则当可读端结束时，套接字将自动结束可写端。 如果设置了 <code>socket</code> 选项，则此选项无效。 有关详细信息，请参阅 <a href="/zh/nodejs/api/net#class-netsocket"><code>net.Socket</code></a> 的 <code>allowHalfOpen</code> 选项。 <strong>默认值:</strong> <code>false</code>。</li><li><code>rejectUnauthorized</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" target="_blank" rel="noreferrer">&lt;boolean&gt;</a> 如果不是 <code>false</code>，则根据提供的 CA 列表验证服务器证书。 如果验证失败，则会发出 <code>&#39;error&#39;</code> 事件； <code>err.code</code> 包含 OpenSSL 错误代码。 <strong>默认值:</strong> <code>true</code>。</li><li><code>pskCallback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noreferrer">&lt;Function&gt;</a> 对于 TLS-PSK 协商，参见 <a href="/zh/nodejs/api/tls#pre-shared-keys">预共享密钥</a>。</li><li><code>ALPNProtocols</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string[]&gt;</a> | <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer[]&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" target="_blank" rel="noreferrer">&lt;TypedArray[]&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" target="_blank" rel="noreferrer">&lt;DataView[]&gt;</a> | <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" target="_blank" rel="noreferrer">&lt;TypedArray&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" target="_blank" rel="noreferrer">&lt;DataView&gt;</a> 字符串、<code>Buffer</code>、<code>TypedArray</code> 或 <code>DataView</code> 的数组，或者包含支持的 ALPN 协议的单个 <code>Buffer</code>、<code>TypedArray</code> 或 <code>DataView</code>。 <code>Buffer</code> 应该具有 <code>[len][name][len][name]...</code> 格式，例如 <code>&#39;\\x08http/1.1\\x08http/1.0&#39;</code>，其中 <code>len</code> 字节是下一个协议名称的长度。 传递数组通常要简单得多，例如 <code>[&#39;http/1.1&#39;, &#39;http/1.0&#39;]</code>。 列表中较早的协议比列表中的较晚的协议具有更高的优先级。</li><li><code>servername</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 用于 SNI（服务器名称指示）TLS 扩展的服务器名称。 它是要连接到的主机的名称，并且必须是主机名，而不是 IP 地址。 多宿主服务器可以使用它来选择要呈现给客户端的正确证书，参见 <a href="/zh/nodejs/api/tls#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a> 的 <code>SNICallback</code> 选项。</li><li><code>checkServerIdentity(servername, cert)</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noreferrer">&lt;Function&gt;</a> 一个回调函数，用于在检查服务器的主机名（或显式设置时提供的 <code>servername</code>）与证书时（代替内置的 <code>tls.checkServerIdentity()</code> 函数）。 如果验证失败，则应返回一个 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" target="_blank" rel="noreferrer">&lt;Error&gt;</a>。 如果 <code>servername</code> 和 <code>cert</code> 经过验证，则该方法应返回 <code>undefined</code>。</li><li><code>session</code> <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> 一个 <code>Buffer</code> 实例，包含 TLS 会话。</li><li><code>minDHSize</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" target="_blank" rel="noreferrer">&lt;number&gt;</a> 接受 TLS 连接的 DH 参数的最小大小（以位为单位）。 当服务器提供的 DH 参数的大小小于 <code>minDHSize</code> 时，TLS 连接将被销毁并抛出错误。 <strong>默认值:</strong> <code>1024</code>。</li><li><code>highWaterMark</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" target="_blank" rel="noreferrer">&lt;number&gt;</a> 与可读流 <code>highWaterMark</code> 参数一致。 <strong>默认值:</strong> <code>16 * 1024</code>。</li><li><code>secureContext</code>: 使用 <a href="/zh/nodejs/api/tls#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 创建的 TLS 上下文对象。 如果 <em>未</em> 提供 <code>secureContext</code>，则将通过将整个 <code>options</code> 对象传递给 <code>tls.createSecureContext()</code> 来创建一个。</li><li><code>onread</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a> 如果缺少 <code>socket</code> 选项，则传入的数据存储在单个 <code>buffer</code> 中，并在数据到达套接字时传递给提供的 <code>callback</code>，否则将忽略该选项。 有关详细信息，请参阅 <a href="/zh/nodejs/api/net#class-netsocket"><code>net.Socket</code></a> 的 <code>onread</code> 选项。</li><li>...: 如果缺少 <code>secureContext</code> 选项，则使用 <a href="/zh/nodejs/api/tls#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 选项，否则忽略它们。</li><li>...: 任何尚未列出的 <a href="/zh/nodejs/api/net#socketconnectoptions-connectlistener"><code>socket.connect()</code></a> 选项。</li></ul></li><li><p><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noreferrer">&lt;Function&gt;</a></p></li><li><p>返回: <a href="/zh/nodejs/api/tls#class-tlstlssocket">&lt;tls.TLSSocket&gt;</a></p></li></ul><p>如果指定了 <code>callback</code> 函数，它将被添加为 <a href="/zh/nodejs/api/tls#event-secureconnect"><code>&#39;secureConnect&#39;</code></a> 事件的监听器。</p><p><code>tls.connect()</code> 返回一个 <a href="/zh/nodejs/api/tls#class-tlstlssocket"><code>tls.TLSSocket</code></a> 对象。</p><p>与 <code>https</code> API 不同，默认情况下 <code>tls.connect()</code> 不启用 SNI（服务器名称指示）扩展，这可能会导致某些服务器返回不正确的证书或完全拒绝连接。 要启用 SNI，除了 <code>host</code> 之外，还要设置 <code>servername</code> 选项。</p><p>以下示例说明了 <a href="/zh/nodejs/api/tls#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a> 中的 echo 服务器示例的客户端：</p><div class="vp-code-group"><div class="tabs"><input type="radio" name="group-2354" id="tab-2355" checked><label data-title="ESM" for="tab-2355">ESM</label><input type="radio" name="group-2354" id="tab-2356"><label data-title="CJS" for="tab-2356">CJS</label></div><div class="blocks"><div class="language-js active line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 假定一个 echo 服务器正在端口 8000 上监听。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { connect } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;node:tls&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { readFileSync } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;node:fs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { stdin } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;node:process&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 仅当服务器需要客户端证书身份验证时才需要。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  key: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;client-key.pem&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  cert: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;client-cert.pem&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 仅当服务器使用自签名证书时才需要。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ca: [ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;server-cert.pem&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) ],</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 仅当服务器的证书不适用于“localhost”时才需要。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  checkServerIdentity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> socket</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, options, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;client connected&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              socket.authorized </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;authorized&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;unauthorized&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  stdin.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pipe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(socket);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  stdin.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resume</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setEncoding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;utf8&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;data&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;end&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;server ends connection&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 假定一个 echo 服务器正在端口 8000 上监听。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;node:tls&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;node:fs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 仅当服务器需要客户端证书身份验证时才需要。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  key: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;client-key.pem&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  cert: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;client-cert.pem&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 仅当服务器使用自签名证书时才需要。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ca: [ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;server-cert.pem&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) ],</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 仅当服务器的证书不适用于“localhost”时才需要。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  checkServerIdentity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> socket</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, options, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;client connected&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              socket.authorized </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;authorized&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;unauthorized&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  process.stdin.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pipe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(socket);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  process.stdin.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resume</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setEncoding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;utf8&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;data&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;end&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;server ends connection&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div></div></div><p>要为此示例生成证书和密钥，请运行：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">openssl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> req</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -x509</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -newkey</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rsa:2048</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -nodes</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -sha256</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -subj</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/CN=localhost&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -keyout</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> client-key.pem</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -out</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> client-cert.pem</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>然后，要为此示例生成 <code>server-cert.pem</code> 证书，请运行：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">openssl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pkcs12</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -certpbe</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> AES-256-CBC</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -export</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -out</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> server-cert.pem</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -inkey</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> client-key.pem</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -in</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> client-cert.pem</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="tlsconnectpath-options-callback" tabindex="-1"><code>tls.connect(path[, options][, callback])</code> <a class="header-anchor" href="#tlsconnectpath-options-callback" aria-label="Permalink to “tls.connect(path[, options][, callback])”">​</a></h2><p><strong>Added in: v0.11.3</strong></p><ul><li><code>path</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> <code>options.path</code> 的默认值。</li><li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a> 参见 <a href="/zh/nodejs/api/tls#tlsconnectoptions-callback"><code>tls.connect()</code></a>。</li><li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noreferrer">&lt;Function&gt;</a> 参见 <a href="/zh/nodejs/api/tls#tlsconnectoptions-callback"><code>tls.connect()</code></a>。</li><li>返回: <a href="/zh/nodejs/api/tls#class-tlstlssocket">&lt;tls.TLSSocket&gt;</a></li></ul><p>与 <a href="/zh/nodejs/api/tls#tlsconnectoptions-callback"><code>tls.connect()</code></a> 相同，除了 <code>path</code> 可以作为参数而不是选项提供。</p><p>如果指定了 path 选项，它将优先于 path 参数。</p><h2 id="tlsconnectport-host-options-callback" tabindex="-1"><code>tls.connect(port[, host][, options][, callback])</code> <a class="header-anchor" href="#tlsconnectport-host-options-callback" aria-label="Permalink to “tls.connect(port[, host][, options][, callback])”">​</a></h2><p><strong>Added in: v0.11.3</strong></p><ul><li><code>port</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" target="_blank" rel="noreferrer">&lt;number&gt;</a> <code>options.port</code> 的默认值。</li><li><code>host</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> <code>options.host</code> 的默认值。</li><li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a> 参见 <a href="/zh/nodejs/api/tls#tlsconnectoptions-callback"><code>tls.connect()</code></a>。</li><li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noreferrer">&lt;Function&gt;</a> 参见 <a href="/zh/nodejs/api/tls#tlsconnectoptions-callback"><code>tls.connect()</code></a>。</li><li>返回: <a href="/zh/nodejs/api/tls#class-tlstlssocket">&lt;tls.TLSSocket&gt;</a></li></ul><p>与 <a href="/zh/nodejs/api/tls#tlsconnectoptions-callback"><code>tls.connect()</code></a> 相同，除了 <code>port</code> 和 <code>host</code> 可以作为参数而不是选项提供。</p><p>如果指定了 port 或 host 选项，它将优先于任何 port 或 host 参数。</p><h2 id="tlscreatesecurecontextoptions" tabindex="-1"><code>tls.createSecureContext([options])</code> <a class="header-anchor" href="#tlscreatesecurecontextoptions" aria-label="Permalink to “tls.createSecureContext([options])”">​</a></h2><div class="info custom-block"><p class="custom-block-title">[历史]</p><table tabindex="0"><thead><tr><th>版本</th><th>变更</th></tr></thead><tbody><tr><td>v22.9.0, v20.18.0</td><td>添加了 <code>allowPartialTrustChain</code> 选项。</td></tr><tr><td>v22.4.0, v20.16.0</td><td><code>clientCertEngine</code>、<code>privateKeyEngine</code> 和 <code>privateKeyIdentifier</code> 选项依赖于 OpenSSL 中的自定义引擎支持，该支持在 OpenSSL 3 中已弃用。</td></tr><tr><td>v19.8.0, v18.16.0</td><td>现在可以将 <code>dhparam</code> 选项设置为 <code>&#39;auto&#39;</code> 以启用具有适当已知参数的 DHE。</td></tr><tr><td>v12.12.0</td><td>添加了 <code>privateKeyIdentifier</code> 和 <code>privateKeyEngine</code> 选项以从 OpenSSL 引擎获取私钥。</td></tr><tr><td>v12.11.0</td><td>添加了 <code>sigalgs</code> 选项以覆盖支持的签名算法。</td></tr><tr><td>v12.0.0</td><td>添加了 TLSv1.3 支持。</td></tr><tr><td>v11.5.0</td><td><code>ca:</code> 选项现在支持 <code>BEGIN TRUSTED CERTIFICATE</code>。</td></tr><tr><td>v11.4.0, v10.16.0</td><td><code>minVersion</code> 和 <code>maxVersion</code> 可用于限制允许的 TLS 协议版本。</td></tr><tr><td>v10.0.0</td><td>由于 OpenSSL 中的更改，<code>ecdhCurve</code> 不能再设置为 <code>false</code>。</td></tr><tr><td>v9.3.0</td><td><code>options</code> 参数现在可以包括 <code>clientCertEngine</code>。</td></tr><tr><td>v9.0.0</td><td><code>ecdhCurve</code> 选项现在可以是多个以 <code>&#39;:&#39;</code> 分隔的曲线名称或 <code>&#39;auto&#39;</code>。</td></tr><tr><td>v7.3.0</td><td>如果 <code>key</code> 选项是一个数组，则单个条目不再需要 <code>passphrase</code> 属性。 <code>Array</code> 条目现在也可以只是 <code>string</code> 或 <code>Buffer</code>。</td></tr><tr><td>v5.2.0</td><td><code>ca</code> 选项现在可以是包含多个 CA 证书的单个字符串。</td></tr><tr><td>v0.11.13</td><td>添加于: v0.11.13</td></tr></tbody></table></div><ul><li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a><ul><li><code>allowPartialTrustChain</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" target="_blank" rel="noreferrer">&lt;boolean&gt;</a> 将信任 CA 证书列表中的中间（非自签名）证书视为可信。</li><li><code>ca</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string[]&gt;</a> | <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> | <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer[]&gt;</a> 可选地覆盖受信任的 CA 证书。 默认是信任 Mozilla 策划的众所周知的 CA。 当使用此选项显式指定 CA 时，Mozilla 的 CA 将被完全替换。 该值可以是字符串或 <code>Buffer</code>，也可以是字符串和/或 <code>Buffer</code> 的 <code>Array</code>。 任何字符串或 <code>Buffer</code> 都可以包含多个 PEM CA 串联在一起。 对等方的证书必须可链接到服务器信任的 CA，才能验证连接。 当使用不可链接到众所周知的 CA 的证书时，证书的 CA 必须显式指定为可信，否则连接将无法验证。 如果对等方使用的证书与默认 CA 中的一个不匹配或链接到默认 CA，请使用 <code>ca</code> 选项提供对等方的证书可以匹配或链接到的 CA 证书。 对于自签名证书，该证书是其自身的 CA，并且必须提供。 对于 PEM 编码的证书，支持的类型为“TRUSTED CERTIFICATE”、“X509 CERTIFICATE”和“CERTIFICATE”。 另请参见 <a href="/zh/nodejs/api/tls#tlsrootcertificates"><code>tls.rootCertificates</code></a>。</li><li><code>cert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string[]&gt;</a> | <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> | <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer[]&gt;</a> PEM 格式的证书链。 每个私钥应提供一个证书链。 每个证书链应由提供的私钥的 PEM 格式证书组成 <code>key</code>，后跟 PEM 格式的中间证书（如果有），按顺序排列，不包括根 CA（根 CA 必须预先为对等方所知，请参阅 <code>ca</code>）。 当提供多个证书链时，它们不必与其私钥在 <code>key</code> 中的顺序相同。 如果未提供中间证书，对等方将无法验证证书，并且握手将失败。</li><li><code>sigalgs</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 支持的签名算法的冒号分隔列表。 该列表可以包含摘要算法（<code>SHA256</code>、<code>MD5</code> 等）、公钥算法（<code>RSA-PSS</code>、<code>ECDSA</code> 等）、两者组合（例如“RSA+SHA384”）或 TLS v1.3 方案名称（例如 <code>rsa_pss_pss_sha512</code>）。 有关更多信息，请参阅 <a href="https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set1_sigalgs_list" target="_blank" rel="noreferrer">OpenSSL 手册页</a>。</li><li><code>ciphers</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 密码套件规范，替换默认值。 有关更多信息，请参阅<a href="/zh/nodejs/api/tls#modifying-the-default-tls-cipher-suite">修改默认 TLS 密码套件</a>。 允许的密码可以通过 <a href="/zh/nodejs/api/tls#tlsgetciphers"><code>tls.getCiphers()</code></a> 获取。 密码名称必须大写，以便 OpenSSL 接受它们。</li><li><code>clientCertEngine</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 可以提供客户端证书的 OpenSSL 引擎的名称。 <strong>已弃用。</strong></li><li><code>crl</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string[]&gt;</a> | <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> | <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer[]&gt;</a> PEM 格式的 CRL（证书撤销列表）。</li><li><code>dhparam</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> | <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> <code>&#39;auto&#39;</code> 或自定义 Diffie-Hellman 参数，非 ECDHE <a href="/zh/nodejs/api/tls#perfect-forward-secrecy">完全正向保密</a>所必需。 如果省略或无效，则会静默丢弃参数，并且 DHE 密码将不可用。 基于 <a href="https://en.wikipedia.org/wiki/Elliptic_curve_Diffie%E2%80%93Hellman" target="_blank" rel="noreferrer">ECDHE</a> 的<a href="/zh/nodejs/api/tls#perfect-forward-secrecy">完全正向保密</a>仍然可用。</li><li><code>ecdhCurve</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 一个字符串，用于描述命名曲线或以冒号分隔的曲线 NID 或名称列表，例如 <code>P-521:P-384:P-256</code>，用于 ECDH 密钥协议。 设置为 <code>auto</code> 以自动选择曲线。 使用 <a href="/zh/nodejs/api/crypto#cryptogetcurves"><code>crypto.getCurves()</code></a> 获取可用曲线名称的列表。 在最近的版本中，<code>openssl ecparam -list_curves</code> 还会显示每个可用椭圆曲线的名称和描述。 <strong>默认值:</strong> <a href="/zh/nodejs/api/tls#tlsdefault-ecdh-curve"><code>tls.DEFAULT_ECDH_CURVE</code></a>。</li><li><code>honorCipherOrder</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" target="_blank" rel="noreferrer">&lt;boolean&gt;</a> 尝试使用服务器的密码套件首选项而不是客户端的首选项。 当为 <code>true</code> 时，会导致在 <code>secureOptions</code> 中设置 <code>SSL_OP_CIPHER_SERVER_PREFERENCE</code>，有关更多信息，请参见 <a href="/zh/nodejs/api/crypto#openssl-options">OpenSSL 选项</a>。</li><li><code>key</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string[]&gt;</a> | <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> | <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer[]&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object[]&gt;</a> PEM 格式的私钥。 PEM 允许私钥被加密的选项。 加密的密钥将使用 <code>options.passphrase</code> 解密。 可以提供使用不同算法的多个密钥，可以作为未加密的密钥字符串或缓冲区的数组，也可以作为 <code>{pem: \\&lt;string|buffer\\&gt;[, passphrase: \\&lt;string\\&gt;]}</code> 形式的对象的数组。 对象形式只能出现在数组中。 <code>object.passphrase</code> 是可选的。 如果提供了 <code>object.passphrase</code>，加密的密钥将使用它解密，否则使用 <code>options.passphrase</code>。</li><li><code>privateKeyEngine</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 从中获取私钥的 OpenSSL 引擎的名称。 应该与 <code>privateKeyIdentifier</code> 一起使用。 <strong>已弃用。</strong></li><li><code>privateKeyIdentifier</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 由 OpenSSL 引擎管理的私钥的标识符。 应该与 <code>privateKeyEngine</code> 一起使用。 不应与 <code>key</code> 一起设置，因为这两个选项以不同的方式定义私钥。 <strong>已弃用。</strong></li><li><code>maxVersion</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 可选地设置允许的最大 TLS 版本。 值为 <code>&#39;TLSv1.3&#39;</code>、<code>&#39;TLSv1.2&#39;</code>、<code>&#39;TLSv1.1&#39;</code> 或 <code>&#39;TLSv1&#39;</code> 之一。 不能与 <code>secureProtocol</code> 选项一起指定； 使用其中一个。 <strong>默认值:</strong> <a href="/zh/nodejs/api/tls#tlsdefault-max-version"><code>tls.DEFAULT_MAX_VERSION</code></a>。</li><li><code>minVersion</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 可选地设置允许的最小 TLS 版本。 值为 <code>&#39;TLSv1.3&#39;</code>、<code>&#39;TLSv1.2&#39;</code>、<code>&#39;TLSv1.1&#39;</code> 或 <code>&#39;TLSv1&#39;</code> 之一。 不能与 <code>secureProtocol</code> 选项一起指定； 使用其中一个。 避免设置为小于 TLSv1.2，但互操作性可能需要这样做。 低于 TLSv1.2 的版本可能需要降级 <a href="/zh/nodejs/api/tls#openssl-security-level">OpenSSL 安全级别</a>。 <strong>默认值:</strong> <a href="/zh/nodejs/api/tls#tlsdefault-min-version"><code>tls.DEFAULT_MIN_VERSION</code></a>。</li><li><code>passphrase</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 用于单个私钥和/或 PFX 的共享密码。</li><li><code>pfx</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string[]&gt;</a> | <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> | <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer[]&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object[]&gt;</a> PFX 或 PKCS12 编码的私钥和证书链。 <code>pfx</code> 是单独提供 <code>key</code> 和 <code>cert</code> 的替代方法。 PFX 通常是加密的，如果是，则将使用 <code>passphrase</code> 解密它。 可以提供多个 PFX，可以作为未加密的 PFX 缓冲区的数组，也可以作为 <code>{buf: \\&lt;string|buffer\\&gt;[, passphrase: \\&lt;string\\&gt;]}</code> 形式的对象的数组。 对象形式只能出现在数组中。 <code>object.passphrase</code> 是可选的。 如果提供了 <code>object.passphrase</code>，加密的 PFX 将使用它解密，否则使用 <code>options.passphrase</code>。</li><li><code>secureOptions</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" target="_blank" rel="noreferrer">&lt;number&gt;</a> 可选地影响 OpenSSL 协议行为，这通常不是必需的。 应该小心使用！ 该值是来自 <a href="/zh/nodejs/api/crypto#openssl-options">OpenSSL 选项</a> 的 <code>SSL_OP_*</code> 选项的数字位掩码。</li><li><code>secureProtocol</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 用于选择要使用的 TLS 协议版本的传统机制，它不支持独立控制最小和最大版本，并且不支持将协议限制为 TLSv1.3。 请改用 <code>minVersion</code> 和 <code>maxVersion</code>。 可能的值列为 <a href="https://www.openssl.org/docs/man1.1.1/man7/ssl#Dealing-with-Protocol-Methods" target="_blank" rel="noreferrer">SSL_METHODS</a>，使用函数名称作为字符串。 例如，使用 <code>&#39;TLSv1_1_method&#39;</code> 强制使用 TLS 版本 1.1，或使用 <code>&#39;TLS_method&#39;</code> 允许任何 TLS 协议版本，最高可达 TLSv1.3。 不建议使用低于 1.2 的 TLS 版本，但互操作性可能需要这样做。 <strong>默认值:</strong> 无，请参阅 <code>minVersion</code>。</li><li><code>sessionIdContext</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 服务器使用的不透明标识符，以确保会话状态不在应用程序之间共享。 客户端未使用。</li><li><code>ticketKeys</code>: <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> 48 字节的密码学上强的伪随机数据。 有关更多信息，请参阅<a href="/zh/nodejs/api/tls#session-resumption">会话恢复</a>。</li><li><code>sessionTimeout</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" target="_blank" rel="noreferrer">&lt;number&gt;</a> 服务器创建的 TLS 会话不再可恢复的秒数。 有关更多信息，请参阅<a href="/zh/nodejs/api/tls#session-resumption">会话恢复</a>。 <strong>默认值:</strong> <code>300</code>。</li></ul></li></ul><p><a href="/zh/nodejs/api/tls#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a> 将 <code>honorCipherOrder</code> 选项的默认值设置为 <code>true</code>，其他创建安全上下文的 API 将其保留为未设置。</p><p><a href="/zh/nodejs/api/tls#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a> 使用从 <code>process.argv</code> 生成的 128 位截断的 SHA1 哈希值作为 <code>sessionIdContext</code> 选项的默认值，其他创建安全上下文的 API 没有默认值。</p><p><code>tls.createSecureContext()</code> 方法创建一个 <code>SecureContext</code> 对象。 它可以作为几个 <code>tls</code> API 的参数使用，例如 <a href="/zh/nodejs/api/tls#serveraddcontexthostname-context"><code>server.addContext()</code></a>，但没有公共方法。 <a href="/zh/nodejs/api/tls#class-tlsserver"><code>tls.Server</code></a> 构造函数和 <a href="/zh/nodejs/api/tls#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a> 方法不支持 <code>secureContext</code> 选项。</p><p>对于使用证书的密码，密钥是<em>必需的</em>。 可以使用 <code>key</code> 或 <code>pfx</code> 来提供它。</p><p>如果未给出 <code>ca</code> 选项，则 Node.js 默认使用 <a href="https://hg.mozilla.org/mozilla-central/raw-file/tip/security/nss/lib/ckfw/builtins/certdata.txt" target="_blank" rel="noreferrer">Mozilla 公开信任的 CA 列表</a>。</p><p>不鼓励使用自定义 DHE 参数，而建议使用新的 <code>dhparam: &#39;auto&#39;</code> 选项。 当设置为 <code>&#39;auto&#39;</code> 时，将自动选择足够强度的已知 DHE 参数。 否则，如果必要，可以使用 <code>openssl dhparam</code> 创建自定义参数。 密钥长度必须大于或等于 1024 位，否则将引发错误。 虽然允许 1024 位，但为了更强的安全性，请使用 2048 位或更大。</p><h2 id="tlscreatesecurepaircontext-isserver-requestcert-rejectunauthorized-options" tabindex="-1"><code>tls.createSecurePair([context][, isServer][, requestCert][, rejectUnauthorized][, options])</code> <a class="header-anchor" href="#tlscreatesecurepaircontext-isserver-requestcert-rejectunauthorized-options" aria-label="Permalink to “tls.createSecurePair([context][, isServer][, requestCert][, rejectUnauthorized][, options])”">​</a></h2><div class="info custom-block"><p class="custom-block-title">[历史]</p><table tabindex="0"><thead><tr><th>版本</th><th>变更</th></tr></thead><tbody><tr><td>v5.0.0</td><td>现在支持 ALPN 选项。</td></tr><tr><td>v0.11.3</td><td>已弃用，自：v0.11.3</td></tr><tr><td>v0.3.2</td><td>添加于：v0.3.2</td></tr></tbody></table></div><div class="danger custom-block"><p class="custom-block-title">[稳定度：0 - 已弃用]</p><p><a href="/zh/nodejs/api/documentation#stability-index">稳定度：0</a> <a href="/zh/nodejs/api/documentation#stability-index">稳定度：0</a> - 已弃用：请改用 <a href="/zh/nodejs/api/tls#class-tlstlssocket"><code>tls.TLSSocket</code></a>。</p></div><ul><li><code>context</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a> 一个由 <code>tls.createSecureContext()</code> 返回的安全上下文对象</li><li><code>isServer</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" target="_blank" rel="noreferrer">&lt;boolean&gt;</a> <code>true</code> 表示此 TLS 连接应作为服务器打开。</li><li><code>requestCert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" target="_blank" rel="noreferrer">&lt;boolean&gt;</a> <code>true</code> 表示服务器是否应向连接的客户端请求证书。 仅在 <code>isServer</code> 为 <code>true</code> 时适用。</li><li><code>rejectUnauthorized</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" target="_blank" rel="noreferrer">&lt;boolean&gt;</a> 如果不是 <code>false</code>，服务器会自动拒绝具有无效证书的客户端。 仅在 <code>isServer</code> 为 <code>true</code> 时适用。</li><li><code>options</code><ul><li><code>enableTrace</code>: 参见 <a href="/zh/nodejs/api/tls#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a></li><li><code>secureContext</code>: 来自 <a href="/zh/nodejs/api/tls#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 的 TLS 上下文对象</li><li><code>isServer</code>: 如果为 <code>true</code>，则 TLS 套接字将在服务器模式下实例化。 <strong>默认值：</strong> <code>false</code>。</li><li><code>server</code> <a href="/zh/nodejs/api/net#class-netserver">&lt;net.Server&gt;</a> 一个 <a href="/zh/nodejs/api/net#class-netserver"><code>net.Server</code></a> 实例</li><li><code>requestCert</code>: 参见 <a href="/zh/nodejs/api/tls#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a></li><li><code>rejectUnauthorized</code>: 参见 <a href="/zh/nodejs/api/tls#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a></li><li><code>ALPNProtocols</code>: 参见 <a href="/zh/nodejs/api/tls#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a></li><li><code>SNICallback</code>: 参见 <a href="/zh/nodejs/api/tls#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a></li><li><code>session</code> <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> 包含 TLS 会话的 <code>Buffer</code> 实例。</li><li><code>requestOCSP</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" target="_blank" rel="noreferrer">&lt;boolean&gt;</a> 如果为 <code>true</code>，则指定 OCSP 状态请求扩展将被添加到客户端 hello，并且在建立安全通信之前，将在套接字上发出一个 <code>&#39;OCSPResponse&#39;</code> 事件。</li></ul></li></ul><p>创建一个新的安全对对象，其中包含两个流，一个流读取和写入加密数据，另一个流读取和写入明文数据。 通常，加密流通过管道连接到传入/传出的加密数据流，而明文流用作初始加密流的替代。</p><p><code>tls.createSecurePair()</code> 返回一个具有 <code>cleartext</code> 和 <code>encrypted</code> 流属性的 <code>tls.SecurePair</code> 对象。</p><p>使用 <code>cleartext</code> 具有与 <a href="/zh/nodejs/api/tls#class-tlstlssocket"><code>tls.TLSSocket</code></a> 相同的 API。</p><p><code>tls.createSecurePair()</code> 方法现在已被弃用，推荐使用 <code>tls.TLSSocket()</code>。 例如，代码：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pair </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tls.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createSecurePair</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pair.encrypted.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pipe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(socket);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pipe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pair.encrypted);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>可以替换为：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">secureSocket </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tls.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TLSSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(socket, options);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>其中 <code>secureSocket</code> 具有与 <code>pair.cleartext</code> 相同的 API。</p><h2 id="tlscreateserveroptions-secureconnectionlistener" tabindex="-1"><code>tls.createServer([options][, secureConnectionListener])</code> <a class="header-anchor" href="#tlscreateserveroptions-secureconnectionlistener" aria-label="Permalink to “tls.createServer([options][, secureConnectionListener])”">​</a></h2><div class="info custom-block"><p class="custom-block-title">[历史]</p><table tabindex="0"><thead><tr><th>版本</th><th>变更</th></tr></thead><tbody><tr><td>v22.4.0, v20.16.0</td><td><code>clientCertEngine</code> 选项依赖于 OpenSSL 中的自定义引擎支持，该支持在 OpenSSL 3 中已弃用。</td></tr><tr><td>v19.0.0</td><td>如果设置了 <code>ALPNProtocols</code>，则发送没有受支持协议的 ALPN 扩展的传入连接将以致命的 <code>no_application_protocol</code> 警报终止。</td></tr><tr><td>v20.4.0, v18.19.0</td><td><code>options</code> 参数现在可以包含 <code>ALPNCallback</code>。</td></tr><tr><td>v12.3.0</td><td><code>options</code> 参数现在支持 <code>net.createServer()</code> 选项。</td></tr><tr><td>v9.3.0</td><td><code>options</code> 参数现在可以包含 <code>clientCertEngine</code>。</td></tr><tr><td>v8.0.0</td><td><code>ALPNProtocols</code> 选项现在可以是 <code>TypedArray</code> 或 <code>DataView</code>。</td></tr><tr><td>v5.0.0</td><td>现在支持 ALPN 选项。</td></tr><tr><td>v0.3.2</td><td>添加于: v0.3.2</td></tr></tbody></table></div><ul><li><p><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a></p><ul><li><code>ALPNProtocols</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string[]&gt;</a> | <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer[]&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" target="_blank" rel="noreferrer">&lt;TypedArray[]&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" target="_blank" rel="noreferrer">&lt;DataView[]&gt;</a> | <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" target="_blank" rel="noreferrer">&lt;TypedArray&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" target="_blank" rel="noreferrer">&lt;DataView&gt;</a> 字符串、<code>Buffer</code>、<code>TypedArray</code> 或 <code>DataView</code> 的数组，或者包含受支持的 ALPN 协议的单个 <code>Buffer</code>、<code>TypedArray</code> 或 <code>DataView</code>。 <code>Buffer</code> 应采用 <code>[len][name][len][name]...</code> 格式，例如 <code>0x05hello0x05world</code>，其中第一个字节是下一个协议名称的长度。 传递数组通常更简单，例如 <code>[&#39;hello&#39;, &#39;world&#39;]</code>。（协议应按其优先级排序。）</li><li><code>ALPNCallback</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noreferrer">&lt;Function&gt;</a> 如果设置，当客户端使用 ALPN 扩展打开连接时，将调用此函数。 将向回调传递一个参数：一个包含 <code>servername</code> 和 <code>protocols</code> 字段的对象，分别包含来自 SNI 扩展（如果有）的服务器名称和 ALPN 协议名称字符串的数组。 回调必须返回 <code>protocols</code> 中列出的字符串之一，该字符串将作为选定的 ALPN 协议返回给客户端，或者返回 <code>undefined</code>，以致命警报拒绝连接。 如果返回的字符串与客户端的 ALPN 协议之一不匹配，则会引发错误。 此选项不能与 <code>ALPNProtocols</code> 选项一起使用，并且设置两个选项都会引发错误。</li><li><code>clientCertEngine</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 可以提供客户端证书的 OpenSSL 引擎的名称。 <strong>已弃用。</strong></li><li><code>enableTrace</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" target="_blank" rel="noreferrer">&lt;boolean&gt;</a> 如果为 <code>true</code>，则将在新连接上调用 <a href="/zh/nodejs/api/tls#tlssocketenabletrace"><code>tls.TLSSocket.enableTrace()</code></a>。 可以在建立安全连接后启用跟踪，但必须使用此选项来跟踪安全连接设置。 <strong>默认值:</strong> <code>false</code>。</li><li><code>handshakeTimeout</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" target="_blank" rel="noreferrer">&lt;number&gt;</a> 如果 SSL/TLS 握手未在指定的毫秒数内完成，则中止连接。 每当握手超时时，都会在 <code>tls.Server</code> 对象上发出 <code>&#39;tlsClientError&#39;</code>。 <strong>默认值:</strong> <code>120000</code>（120 秒）。</li><li><code>rejectUnauthorized</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" target="_blank" rel="noreferrer">&lt;boolean&gt;</a> 如果不为 <code>false</code>，服务器将拒绝任何未经提供的 CA 列表授权的连接。 此选项仅在 <code>requestCert</code> 为 <code>true</code> 时才有效。 <strong>默认值:</strong> <code>true</code>。</li><li><code>requestCert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" target="_blank" rel="noreferrer">&lt;boolean&gt;</a> 如果为 <code>true</code>，服务器将请求连接的客户端提供证书，并尝试验证该证书。 <strong>默认值:</strong> <code>false</code>。</li><li><code>sessionTimeout</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" target="_blank" rel="noreferrer">&lt;number&gt;</a> 服务器创建的 TLS 会话在多少秒后不再可恢复。 有关更多信息，请参见<a href="/zh/nodejs/api/tls#session-resumption">会话恢复</a>。 <strong>默认值:</strong> <code>300</code>。</li><li><code>SNICallback(servername, callback)</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noreferrer">&lt;Function&gt;</a> 如果客户端支持 SNI TLS 扩展，将调用该函数。 调用时将传递两个参数：<code>servername</code> 和 <code>callback</code>。 <code>callback</code> 是一个错误优先的回调，它接受两个可选参数：<code>error</code> 和 <code>ctx</code>。 <code>ctx</code>（如果提供）是 <code>SecureContext</code> 实例。 <a href="/zh/nodejs/api/tls#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 可用于获取正确的 <code>SecureContext</code>。 如果使用 falsy <code>ctx</code> 参数调用 <code>callback</code>，则将使用服务器的默认安全上下文。 如果未提供 <code>SNICallback</code>，则将使用带有高级 API 的默认回调（见下文）。</li><li><code>ticketKeys</code>: <a href="/zh/nodejs/api/buffer#class-buffer">&lt;Buffer&gt;</a> 48 字节的密码学上强的伪随机数据。 有关更多信息，请参见<a href="/zh/nodejs/api/tls#session-resumption">会话恢复</a>。</li><li><code>pskCallback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noreferrer">&lt;Function&gt;</a> 对于 TLS-PSK 协商，请参见<a href="/zh/nodejs/api/tls#pre-shared-keys">预共享密钥</a>。</li><li><code>pskIdentityHint</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 可选提示，发送给客户端以帮助在 TLS-PSK 协商期间选择身份。 在 TLS 1.3 中将被忽略。 如果无法设置 pskIdentityHint，将发出代码为 <code>&#39;ERR_TLS_PSK_SET_IDENTITY_HINT_FAILED&#39;</code> 的 <code>&#39;tlsClientError&#39;</code>。</li><li>...: 可以提供任何 <a href="/zh/nodejs/api/tls#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 选项。 对于服务器，通常需要身份选项（<code>pfx</code>、<code>key</code>/<code>cert</code> 或 <code>pskCallback</code>）。</li><li>...: 可以提供任何 <a href="/zh/nodejs/api/net#netcreateserveroptions-connectionlistener"><code>net.createServer()</code></a> 选项。</li></ul></li><li><p><code>secureConnectionListener</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noreferrer">&lt;Function&gt;</a></p></li><li><p>返回: <a href="/zh/nodejs/api/tls#class-tlsserver">&lt;tls.Server&gt;</a></p></li></ul><p>创建一个新的 <a href="/zh/nodejs/api/tls#class-tlsserver"><code>tls.Server</code></a>。 如果提供了 <code>secureConnectionListener</code>，则会自动将其设置为 <a href="/zh/nodejs/api/tls#event-secureconnection"><code>&#39;secureConnection&#39;</code></a> 事件的侦听器。</p><p><code>ticketKeys</code> 选项在 <code>node:cluster</code> 模块工作进程之间自动共享。</p><p>以下说明了一个简单的回显服务器：</p><div class="vp-code-group"><div class="tabs"><input type="radio" name="group-3035" id="tab-3036" checked><label data-title="ESM" for="tab-3036">ESM</label><input type="radio" name="group-3035" id="tab-3037"><label data-title="CJS" for="tab-3037">CJS</label></div><div class="blocks"><div class="language-js active line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { createServer } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;node:tls&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { readFileSync } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;node:fs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  key: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;server-key.pem&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  cert: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;server-cert.pem&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 仅在使用客户端证书认证时才需要。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  requestCert: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 仅当客户端使用自签名证书时才需要。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ca: [ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;client-cert.pem&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> server</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(options, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">socket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;server connected&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              socket.authorized </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;authorized&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;unauthorized&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;welcome!</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setEncoding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;utf8&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pipe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(socket);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">server.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;server bound&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">createServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;node:tls&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;node:fs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  key: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;server-key.pem&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  cert: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;server-cert.pem&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 仅在使用客户端证书认证时才需要。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  requestCert: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 仅当客户端使用自签名证书时才需要。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ca: [ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;client-cert.pem&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> server</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(options, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">socket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;server connected&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              socket.authorized </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;authorized&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;unauthorized&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;welcome!</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setEncoding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;utf8&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pipe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(socket);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">server.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;server bound&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div></div></div><p>要为此示例生成证书和密钥，请运行：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">openssl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> req</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -x509</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -newkey</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rsa:2048</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -nodes</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -sha256</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -subj</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/CN=localhost&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -keyout</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> server-key.pem</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -out</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> server-cert.pem</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>然后，要为此示例生成 <code>client-cert.pem</code> 证书，请运行：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">openssl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pkcs12</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -certpbe</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> AES-256-CBC</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -export</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -out</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> client-cert.pem</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -inkey</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> server-key.pem</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -in</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> server-cert.pem</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>可以使用 <a href="/zh/nodejs/api/tls#tlsconnectoptions-callback"><code>tls.connect()</code></a> 中的示例客户端连接到服务器来对其进行测试。</p><h2 id="tlsgetciphers" tabindex="-1"><code>tls.getCiphers()</code> <a class="header-anchor" href="#tlsgetciphers" aria-label="Permalink to “tls.getCiphers()”">​</a></h2><p><strong>新增于: v0.10.2</strong></p><ul><li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string[]&gt;</a></li></ul><p>返回一个包含支持的 TLS 密码套件名称的数组。 由于历史原因，这些名称是小写的，但必须大写才能在 <a href="/zh/nodejs/api/tls#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 的 <code>ciphers</code> 选项中使用。</p><p>并非所有支持的密码套件默认都启用。 参见 <a href="/zh/nodejs/api/tls#modifying-the-default-tls-cipher-suite">修改默认 TLS 密码套件</a>。</p><p>以 <code>&#39;tls_&#39;</code> 开头的密码套件名称用于 TLSv1.3，所有其他密码套件名称用于 TLSv1.2 及更低版本。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tls.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getCiphers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [&#39;aes128-gcm-sha256&#39;, &#39;aes128-sha&#39;, ...]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="tlsrootcertificates" tabindex="-1"><code>tls.rootCertificates</code> <a class="header-anchor" href="#tlsrootcertificates" aria-label="Permalink to “tls.rootCertificates”">​</a></h2><p><strong>新增于: v12.3.0</strong></p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string[]&gt;</a></li></ul><p>一个不可变的字符串数组，表示来自捆绑的 Mozilla CA 存储的根证书（以 PEM 格式），由当前的 Node.js 版本提供。</p><p>Node.js 提供的捆绑 CA 存储是 Mozilla CA 存储的快照，该快照在发布时是固定的。 它在所有受支持的平台上都是相同的。</p><h2 id="tlsdefault_ecdh_curve" tabindex="-1"><code>tls.DEFAULT_ECDH_CURVE</code> <a class="header-anchor" href="#tlsdefault_ecdh_curve" aria-label="Permalink to “tls.DEFAULT_ECDH_CURVE”">​</a></h2><div class="info custom-block"><p class="custom-block-title">[历史]</p><table tabindex="0"><thead><tr><th>版本</th><th>更改</th></tr></thead><tbody><tr><td>v10.0.0</td><td>默认值更改为 <code>&#39;auto&#39;</code>。</td></tr><tr><td>v0.11.13</td><td>新增于: v0.11.13</td></tr></tbody></table></div><p>在 tls 服务器中用于 ECDH 密钥协商的默认曲线名称。 默认值为 <code>&#39;auto&#39;</code>。 更多信息参见 <a href="/zh/nodejs/api/tls#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a>。</p><h2 id="tlsdefault_max_version" tabindex="-1"><code>tls.DEFAULT_MAX_VERSION</code> <a class="header-anchor" href="#tlsdefault_max_version" aria-label="Permalink to “tls.DEFAULT_MAX_VERSION”">​</a></h2><p><strong>新增于: v11.4.0</strong></p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> <a href="/zh/nodejs/api/tls#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 的 <code>maxVersion</code> 选项的默认值。 它可以被赋值为任何支持的 TLS 协议版本，<code>&#39;TLSv1.3&#39;</code>、<code>&#39;TLSv1.2&#39;</code>、<code>&#39;TLSv1.1&#39;</code> 或 <code>&#39;TLSv1&#39;</code>。 <strong>默认值:</strong> <code>&#39;TLSv1.3&#39;</code>，除非使用 CLI 选项更改。 使用 <code>--tls-max-v1.2</code> 将默认值设置为 <code>&#39;TLSv1.2&#39;</code>。 使用 <code>--tls-max-v1.3</code> 将默认值设置为 <code>&#39;TLSv1.3&#39;</code>。 如果提供了多个选项，则使用最高的上限。</li></ul><h2 id="tlsdefault_min_version" tabindex="-1"><code>tls.DEFAULT_MIN_VERSION</code> <a class="header-anchor" href="#tlsdefault_min_version" aria-label="Permalink to “tls.DEFAULT_MIN_VERSION”">​</a></h2><p><strong>新增于: v11.4.0</strong></p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> <a href="/zh/nodejs/api/tls#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 的 <code>minVersion</code> 选项的默认值。 它可以被赋值为任何支持的 TLS 协议版本，<code>&#39;TLSv1.3&#39;</code>、<code>&#39;TLSv1.2&#39;</code>、<code>&#39;TLSv1.1&#39;</code> 或 <code>&#39;TLSv1&#39;</code>。 TLSv1.2 之前的版本可能需要降低 <a href="/zh/nodejs/api/tls#openssl-security-level">OpenSSL 安全级别</a>。 <strong>默认值:</strong> <code>&#39;TLSv1.2&#39;</code>，除非使用 CLI 选项更改。 使用 <code>--tls-min-v1.0</code> 将默认值设置为 <code>&#39;TLSv1&#39;</code>。 使用 <code>--tls-min-v1.1</code> 将默认值设置为 <code>&#39;TLSv1.1&#39;</code>。 使用 <code>--tls-min-v1.3</code> 将默认值设置为 <code>&#39;TLSv1.3&#39;</code>。 如果提供了多个选项，则使用最低的最小值。</li></ul><h2 id="tlsdefault_ciphers" tabindex="-1"><code>tls.DEFAULT_CIPHERS</code> <a class="header-anchor" href="#tlsdefault_ciphers" aria-label="Permalink to “tls.DEFAULT_CIPHERS”">​</a></h2><p><strong>新增于: v19.8.0, v18.16.0</strong></p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> <a href="/zh/nodejs/api/tls#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 的 <code>ciphers</code> 选项的默认值。 它可以被赋值为任何支持的 OpenSSL 密码。 默认为 <code>crypto.constants.defaultCoreCipherList</code> 的内容，除非使用 CLI 选项 <code>--tls-default-ciphers</code> 更改。</li></ul>`,475)])}var s=e(a,[[`render`,o]]);export{i as __pageData,s as default};