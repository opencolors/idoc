import{__plugin_vue_export_helper_default as e,createElementBlock as t,createStaticVNode as n,openBlock as r}from"./chunks/plugin-vue_export-helper.Bts1mPc7.js";const i=JSON.parse(`{"title":"Soporte de TypeScript en Node.js","description":"Aprende a usar TypeScript con Node.js, incluyendo la instalación, configuración y las mejores prácticas para integrar TypeScript en tus proyectos de Node.js.","frontmatter":{"title":"Soporte de TypeScript en Node.js","description":"Aprende a usar TypeScript con Node.js, incluyendo la instalación, configuración y las mejores prácticas para integrar TypeScript en tus proyectos de Node.js.","head":[["meta",{"name":"og:title","content":"Soporte de TypeScript en Node.js | Node.js - iDoc.dev"}],["meta",{"name":"og:description","content":"Aprende a usar TypeScript con Node.js, incluyendo la instalación, configuración y las mejores prácticas para integrar TypeScript en tus proyectos de Node.js."}],["meta",{"name":"twitter:title","content":"Soporte de TypeScript en Node.js | Node.js - iDoc.dev"}],["meta",{"name":"twitter:description","content":"Aprende a usar TypeScript con Node.js, incluyendo la instalación, configuración y las mejores prácticas para integrar TypeScript en tus proyectos de Node.js."}],["link",{"rel":"canonical","href":"https://idoc.dev/es/nodejs/api/typescript"}],["meta",{"property":"og:url","content":"https://idoc.dev/es/nodejs/api/typescript"}]]},"headers":[],"relativePath":"es/nodejs/api/typescript.md","filePath":"es/nodejs/api/typescript.md","lastUpdated":1749464498000}`),a={name:`es/nodejs/api/typescript.md`};function o(e,i,a,o,s,c){return r(),t(`div`,null,i[0]||=[n(`<h1 id="modules-typescript" tabindex="-1">Módulos: TypeScript <a class="header-anchor" href="#modules-typescript" aria-label="Permalink to “Módulos: TypeScript”">​</a></h1><div class="info custom-block"><p class="custom-block-title">[Historial]</p><table tabindex="0"><thead><tr><th>Versión</th><th>Cambios</th></tr></thead><tbody><tr><td>v22.7.0</td><td>Se añadió el flag <code>--experimental-transform-types</code>.</td></tr></tbody></table></div><div class="warning custom-block"><p class="custom-block-title">[Estable: 1 - Experimental]</p><p><a href="/es/nodejs/api/documentation#stability-index">Estable: 1</a> <a href="/es/nodejs/api/documentation#stability-index">Estabilidad: 1</a>.1 - Desarrollo activo</p></div><h2 id="enabling" tabindex="-1">Activación <a class="header-anchor" href="#enabling" aria-label="Permalink to “Activación”">​</a></h2><p>Hay dos maneras de habilitar el soporte de TypeScript en tiempo de ejecución en Node.js:</p><h2 id="full-typescript-support" tabindex="-1">Soporte completo de TypeScript <a class="header-anchor" href="#full-typescript-support" aria-label="Permalink to “Soporte completo de TypeScript”">​</a></h2><p>Para usar TypeScript con soporte completo para todas las características de TypeScript, incluyendo <code>tsconfig.json</code>, puedes usar un paquete de terceros. Estas instrucciones usan <a href="https://tsx.is/" target="_blank" rel="noreferrer"><code>tsx</code></a> como ejemplo, pero hay muchas otras librerías similares disponibles.</p><h2 id="type-stripping" tabindex="-1">Eliminación de tipos <a class="header-anchor" href="#type-stripping" aria-label="Permalink to “Eliminación de tipos”">​</a></h2><p><strong>Añadido en: v22.6.0</strong></p><div class="warning custom-block"><p class="custom-block-title">[Estable: 1 - Experimental]</p><p><a href="/es/nodejs/api/documentation#stability-index">Estable: 1</a> <a href="/es/nodejs/api/documentation#stability-index">Estabilidad: 1</a>.1 - Desarrollo activo</p></div><p>El flag <a href="/es/nodejs/api/cli#experimental-strip-types"><code>--experimental-strip-types</code></a> permite a Node.js ejecutar archivos TypeScript. Por defecto, Node.js ejecutará solo los archivos que no contengan características de TypeScript que requieran transformación, como enums o namespaces. Node.js reemplazará las anotaciones de tipo inline con espacios en blanco, y no se realizará ninguna verificación de tipo. Para habilitar la transformación de tales características, usa el flag <a href="/es/nodejs/api/cli#experimental-transform-types"><code>--experimental-transform-types</code></a>. Las características de TypeScript que dependen de configuraciones dentro de <code>tsconfig.json</code>, como paths o convertir sintaxis JavaScript más nueva a estándares más antiguos, no son compatibles intencionalmente. Para obtener soporte completo de TypeScript, consulta <a href="/es/nodejs/api/typescript#full-typescript-support">Soporte completo de TypeScript</a>.</p><p>La característica de eliminación de tipos está diseñada para ser ligera. Al no admitir intencionalmente sintaxis que requieren generación de código JavaScript, y al reemplazar los tipos inline con espacios en blanco, Node.js puede ejecutar código TypeScript sin la necesidad de source maps.</p><p>La eliminación de tipos funciona con la mayoría de las versiones de TypeScript, pero recomendamos la versión 5.7 o más reciente con la siguiente configuración de <code>tsconfig.json</code>:</p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;compilerOptions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     &quot;target&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;esnext&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     &quot;module&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;nodenext&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     &quot;allowImportingTsExtensions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     &quot;rewriteRelativeImportExtensions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     &quot;verbatimModuleSyntax&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="determining-module-system" tabindex="-1">Determinación del sistema de módulos <a class="header-anchor" href="#determining-module-system" aria-label="Permalink to “Determinación del sistema de módulos”">​</a></h3><p>Node.js admite tanto la sintaxis de <a href="/es/nodejs/api/modules">CommonJS</a> como la de <a href="/es/nodejs/api/esm">Módulos ES</a> en los archivos de TypeScript. Node.js no convertirá de un sistema de módulos a otro; si quieres que tu código se ejecute como un módulo ES, debes usar la sintaxis <code>import</code> y <code>export</code>, y si quieres que tu código se ejecute como CommonJS debes usar <code>require</code> y <code>module.exports</code>.</p><ul><li>Los archivos <code>.ts</code> tendrán su sistema de módulos determinado <a href="/es/nodejs/api/packages#determining-module-system">de la misma manera que los archivos <code>.js</code>.</a> Para usar la sintaxis <code>import</code> y <code>export</code>, añade <code>&quot;type&quot;: &quot;module&quot;</code> al <code>package.json</code> padre más cercano.</li><li>Los archivos <code>.mts</code> siempre se ejecutarán como módulos ES, de forma similar a los archivos <code>.mjs</code>.</li><li>Los archivos <code>.cts</code> siempre se ejecutarán como módulos CommonJS, de forma similar a los archivos <code>.cjs</code>.</li><li>Los archivos <code>.tsx</code> no son compatibles.</li></ul><p>Al igual que en los archivos JavaScript, <a href="/es/nodejs/api/esm#mandatory-file-extensions">las extensiones de archivo son obligatorias</a> en las sentencias <code>import</code> y en las expresiones <code>import()</code>: <code>import &#39;./file.ts&#39;</code>, no <code>import &#39;./file&#39;</code>. Debido a la compatibilidad con versiones anteriores, las extensiones de archivo también son obligatorias en las llamadas <code>require()</code>: <code>require(&#39;./file.ts&#39;)</code>, no <code>require(&#39;./file&#39;)</code>, de forma similar a como la extensión <code>.cjs</code> es obligatoria en las llamadas <code>require</code> en los archivos CommonJS.</p><p>La opción <code>tsconfig.json</code> <code>allowImportingTsExtensions</code> permitirá al compilador de TypeScript <code>tsc</code> comprobar el tipo de los archivos con especificadores <code>import</code> que incluyan la extensión <code>.ts</code>.</p><h3 id="typescript-features" tabindex="-1">Características de TypeScript <a class="header-anchor" href="#typescript-features" aria-label="Permalink to “Características de TypeScript”">​</a></h3><p>Dado que Node.js sólo está eliminando los tipos en línea, cualquier característica de TypeScript que implique <em>reemplazar</em> la sintaxis de TypeScript con una nueva sintaxis de JavaScript generará un error, a menos que se pase el flag <a href="/es/nodejs/api/cli#experimental-transform-types"><code>--experimental-transform-types</code></a>.</p><p>Las características más destacadas que requieren transformación son:</p><ul><li><code>Enum</code></li><li><code>namespaces</code></li><li><code>legacy module</code></li><li>propiedades de los parámetros</li></ul><p>Dado que los decoradores son actualmente una <a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="noreferrer">propuesta de la etapa 3 de TC39</a> y pronto serán compatibles con el motor de JavaScript, no se transforman y darán como resultado un error de análisis sintáctico. Esta es una limitación temporal y se resolverá en el futuro.</p><p>Además, Node.js no lee los archivos <code>tsconfig.json</code> y no admite las características que dependen de la configuración dentro de <code>tsconfig.json</code>, como las rutas o la conversión de la sintaxis JavaScript más reciente en estándares más antiguos.</p><h3 id="importing-types-without-type-keyword" tabindex="-1">Importando tipos sin la palabra clave <code>type</code> <a class="header-anchor" href="#importing-types-without-type-keyword" aria-label="Permalink to “Importando tipos sin la palabra clave type”">​</a></h3><p>Debido a la naturaleza de la eliminación de tipos, la palabra clave <code>type</code> es necesaria para eliminar correctamente las importaciones de tipos. Sin la palabra clave <code>type</code>, Node.js tratará la importación como una importación de valor, lo que resultará en un error en tiempo de ejecución. La opción de tsconfig <a href="https://www.typescriptlang.org/tsconfig/#verbatimModuleSyntax" target="_blank" rel="noreferrer"><code>verbatimModuleSyntax</code></a> se puede utilizar para que coincida con este comportamiento.</p><p>Este ejemplo funcionará correctamente:</p><div class="language-ts line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Type1, Type2 } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./module.ts&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { fn, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> FnParams } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./fn.ts&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Esto resultará en un error en tiempo de ejecución:</p><div class="language-ts line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Type1, Type2 } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./module.ts&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { fn, FnParams } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./fn.ts&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="non-file-forms-of-input" tabindex="-1">Formas de entrada que no son archivos <a class="header-anchor" href="#non-file-forms-of-input" aria-label="Permalink to “Formas de entrada que no son archivos”">​</a></h3><p>La eliminación de tipos se puede habilitar para <code>--eval</code>. El sistema de módulos estará determinado por <code>--input-type</code>, como lo está para JavaScript.</p><p>La sintaxis de TypeScript no es compatible con REPL, la entrada STDIN, <code>--print</code>, <code>--check</code> e <code>inspect</code>.</p><h3 id="source-maps" tabindex="-1">Mapas de origen (Source maps) <a class="header-anchor" href="#source-maps" aria-label="Permalink to “Mapas de origen (Source maps)”">​</a></h3><p>Dado que los tipos en línea se reemplazan por espacios en blanco, los mapas de origen son innecesarios para los números de línea correctos en los seguimientos de pila; y Node.js no los genera. Cuando <a href="/es/nodejs/api/cli#experimental-transform-types"><code>--experimental-transform-types</code></a> está habilitado, los mapas de origen se habilitan de forma predeterminada.</p><h3 id="type-stripping-in-dependencies" tabindex="-1">Eliminación de tipos en dependencias <a class="header-anchor" href="#type-stripping-in-dependencies" aria-label="Permalink to “Eliminación de tipos en dependencias”">​</a></h3><p>Para desalentar a los autores de paquetes a publicar paquetes escritos en TypeScript, Node.js, de forma predeterminada, se negará a manejar archivos TypeScript dentro de carpetas bajo una ruta <code>node_modules</code>.</p><h3 id="paths-aliases" tabindex="-1">Alias de rutas <a class="header-anchor" href="#paths-aliases" aria-label="Permalink to “Alias de rutas”">​</a></h3><p><a href="https://www.typescriptlang.org/tsconfig/#paths" target="_blank" rel="noreferrer"><code>tsconfig</code> &quot;paths&quot;</a> no se transformarán y, por lo tanto, producirán un error. La característica más cercana disponible son las <a href="/es/nodejs/api/packages#subpath-imports">importaciones de subrutas</a> con la limitación de que deben comenzar con <code>#</code>.</p>`,40)])}var s=e(a,[[`render`,o]]);export{i as __pageData,s as default};