import{__plugin_vue_export_helper_default as e,createElementBlock as t,createStaticVNode as n,openBlock as r}from"./chunks/plugin-vue_export-helper.Bts1mPc7.js";const i=JSON.parse(`{"title":"Node.jsにおけるTypeScriptサポート","description":"Node.jsでTypeScriptを使用する方法について学びます。インストール、設定、およびNode.jsプロジェクトにTypeScriptを統合するためのベストプラクティスを含みます。","frontmatter":{"title":"Node.jsにおけるTypeScriptサポート","description":"Node.jsでTypeScriptを使用する方法について学びます。インストール、設定、およびNode.jsプロジェクトにTypeScriptを統合するためのベストプラクティスを含みます。","head":[["meta",{"name":"og:title","content":"Node.jsにおけるTypeScriptサポート | Node.js - iDoc.dev"}],["meta",{"name":"og:description","content":"Node.jsでTypeScriptを使用する方法について学びます。インストール、設定、およびNode.jsプロジェクトにTypeScriptを統合するためのベストプラクティスを含みます。"}],["meta",{"name":"twitter:title","content":"Node.jsにおけるTypeScriptサポート | Node.js - iDoc.dev"}],["meta",{"name":"twitter:description","content":"Node.jsでTypeScriptを使用する方法について学びます。インストール、設定、およびNode.jsプロジェクトにTypeScriptを統合するためのベストプラクティスを含みます。"}],["link",{"rel":"canonical","href":"https://idoc.dev/ja/nodejs/api/typescript"}],["meta",{"property":"og:url","content":"https://idoc.dev/ja/nodejs/api/typescript"}]]},"headers":[],"relativePath":"ja/nodejs/api/typescript.md","filePath":"ja/nodejs/api/typescript.md","lastUpdated":null}`),a={name:`ja/nodejs/api/typescript.md`};function o(e,i,a,o,s,c){return r(),t(`div`,null,i[0]||=[n(`<h1 id="modules-typescript" tabindex="-1">モジュール: TypeScript <a class="header-anchor" href="#modules-typescript" aria-label="Permalink to “モジュール: TypeScript”">​</a></h1><div class="info custom-block"><p class="custom-block-title">[履歴]</p><table tabindex="0"><thead><tr><th>バージョン</th><th>変更点</th></tr></thead><tbody><tr><td>v22.7.0</td><td><code>--experimental-transform-types</code> フラグを追加。</td></tr></tbody></table></div><div class="warning custom-block"><p class="custom-block-title">[安定版: 1 - 試験的]</p><p><a href="/ja/nodejs/api/documentation#stability-index">安定版: 1</a> <a href="/ja/nodejs/api/documentation#stability-index">安定性: 1</a>.1 - 活発な開発</p></div><h2 id="enabling" tabindex="-1">有効化 <a class="header-anchor" href="#enabling" aria-label="Permalink to “有効化”">​</a></h2><p>Node.js でランタイム TypeScript サポートを有効にするには、次の 2 つの方法があります。</p><h2 id="full-typescript-support" tabindex="-1">完全な TypeScript サポート <a class="header-anchor" href="#full-typescript-support" aria-label="Permalink to “完全な TypeScript サポート”">​</a></h2><p><code>tsconfig.json</code> を含むすべての TypeScript 機能を完全にサポートして TypeScript を使用するには、サードパーティのパッケージを使用できます。以下の手順では、<a href="https://tsx.is/" target="_blank" rel="noreferrer"><code>tsx</code></a> を例として使用しますが、他にも多くの同様のライブラリがあります。</p><h2 id="type-stripping" tabindex="-1">型の削除 <a class="header-anchor" href="#type-stripping" aria-label="Permalink to “型の削除”">​</a></h2><p><strong>v22.6.0 で追加</strong></p><div class="warning custom-block"><p class="custom-block-title">[安定版: 1 - 試験的]</p><p><a href="/ja/nodejs/api/documentation#stability-index">安定版: 1</a> <a href="/ja/nodejs/api/documentation#stability-index">安定性: 1</a>.1 - 活発な開発</p></div><p>フラグ <a href="/ja/nodejs/api/cli#experimental-strip-types"><code>--experimental-strip-types</code></a> を使用すると、Node.js で TypeScript ファイルを実行できます。 デフォルトでは、Node.js は、enums や namespaces など、変換を必要とする TypeScript 機能を含まないファイルのみを実行します。 Node.js はインライン型注釈を空白に置き換え、型チェックは実行されません。 このような機能の変換を有効にするには、フラグ <a href="/ja/nodejs/api/cli#experimental-transform-types"><code>--experimental-transform-types</code></a> を使用します。 paths や新しい JavaScript 構文を古い標準に変換するなど、<code>tsconfig.json</code> 内の設定に依存する TypeScript 機能は、意図的にサポートされていません。 完全な TypeScript サポートを利用するには、<a href="/ja/nodejs/api/typescript#full-typescript-support">完全な TypeScript サポート</a> を参照してください。</p><p>型削除機能は、軽量になるように設計されています。 JavaScript コード生成を必要とする構文を意図的にサポートせず、インライン型を空白に置き換えることで、Node.js はソースマップを必要とせずに TypeScript コードを実行できます。</p><p>型削除は TypeScript のほとんどのバージョンで動作しますが、次の <code>tsconfig.json</code> 設定でバージョン 5.7 以降を使用することをお勧めします。</p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;compilerOptions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     &quot;target&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;esnext&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     &quot;module&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;nodenext&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     &quot;allowImportingTsExtensions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     &quot;rewriteRelativeImportExtensions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     &quot;verbatimModuleSyntax&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="determining-module-system" tabindex="-1">モジュールシステムの決定 <a class="header-anchor" href="#determining-module-system" aria-label="Permalink to “モジュールシステムの決定”">​</a></h3><p>Node.js は、TypeScript ファイルで <a href="/ja/nodejs/api/modules">CommonJS</a> と <a href="/ja/nodejs/api/esm">ES Modules</a> の両方の構文をサポートしています。Node.js はモジュールシステムを相互に変換しません。コードを ES モジュールとして実行する場合は <code>import</code> と <code>export</code> 構文を使用する必要があり、コードを CommonJS として実行する場合は <code>require</code> と <code>module.exports</code> を使用する必要があります。</p><ul><li><code>.ts</code> ファイルのモジュールシステムは、<a href="/ja/nodejs/api/packages#determining-module-system"><code>.js</code> ファイルと同じ方法で決定されます。</a> <code>import</code> と <code>export</code> 構文を使用するには、最も近い親の <code>package.json</code> に <code>&quot;type&quot;: &quot;module&quot;</code> を追加します。</li><li><code>.mts</code> ファイルは、<code>.mjs</code> ファイルと同様に、常に ES モジュールとして実行されます。</li><li><code>.cts</code> ファイルは、<code>.cjs</code> ファイルと同様に、常に CommonJS モジュールとして実行されます。</li><li><code>.tsx</code> ファイルはサポートされていません。</li></ul><p>JavaScript ファイルと同様に、<code>import</code> ステートメントと <code>import()</code> 式では<a href="/ja/nodejs/api/esm#mandatory-file-extensions">ファイル拡張子が必須です。</a> <code>import &#39;./file.ts&#39;</code> のように、<code>import &#39;./file&#39;</code> ではありません。後方互換性のため、<code>require()</code> 呼び出しでもファイル拡張子は必須です。<code>require(&#39;./file.ts&#39;)</code> のように、<code>require(&#39;./file&#39;)</code> ではありません。これは CommonJS ファイルでの <code>require</code> 呼び出しで <code>.cjs</code> 拡張子が必須であるのと同様です。</p><p><code>tsconfig.json</code> オプションの <code>allowImportingTsExtensions</code> を使用すると、TypeScript コンパイラー <code>tsc</code> は、<code>.ts</code> 拡張子を含む <code>import</code> 指定子を持つファイルの型チェックを実行できます。</p><h3 id="typescript-features" tabindex="-1">TypeScript の機能 <a class="header-anchor" href="#typescript-features" aria-label="Permalink to “TypeScript の機能”">​</a></h3><p>Node.js はインライン型のみを削除するため、TypeScript 構文を新しい JavaScript 構文で<em>置き換える</em> TypeScript の機能はすべて、<a href="/ja/nodejs/api/cli#experimental-transform-types"><code>--experimental-transform-types</code></a> フラグが渡されない限りエラーになります。</p><p>変換が必要な最も顕著な機能は次のとおりです。</p><ul><li><code>Enum</code></li><li><code>namespaces</code></li><li><code>legacy module</code></li><li>パラメータプロパティ</li></ul><p>デコレータは現在 <a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="noreferrer">TC39 Stage 3 提案</a> であり、まもなく JavaScript エンジンでサポートされる予定であるため、変換されず、パーサーエラーが発生します。これは一時的な制限であり、将来解決される予定です。</p><p>さらに、Node.js は <code>tsconfig.json</code> ファイルを読み取らず、paths や新しい JavaScript 構文を古い標準に変換するなど、<code>tsconfig.json</code> 内の設定に依存する機能はサポートしていません。</p><h3 id="importing-types-without-type-keyword" tabindex="-1"><code>type</code> キーワードなしの型のインポート <a class="header-anchor" href="#importing-types-without-type-keyword" aria-label="Permalink to “type キーワードなしの型のインポート”">​</a></h3><p>型ストリッピングの性質上、型のインポートを正しくストリッピングするには、<code>type</code> キーワードが必要です。 <code>type</code> キーワードがない場合、Node.js はインポートを値のインポートとして扱い、ランタイムエラーが発生します。 tsconfig オプションの <a href="https://www.typescriptlang.org/tsconfig/#verbatimModuleSyntax" target="_blank" rel="noreferrer"><code>verbatimModuleSyntax</code></a> を使用して、この動作に一致させることができます。</p><p>この例は正しく動作します:</p><div class="language-ts line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Type1, Type2 } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./module.ts&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { fn, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> FnParams } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./fn.ts&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>これはランタイムエラーになります:</p><div class="language-ts line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Type1, Type2 } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./module.ts&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { fn, FnParams } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./fn.ts&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="non-file-forms-of-input" tabindex="-1">ファイル形式以外の入力 <a class="header-anchor" href="#non-file-forms-of-input" aria-label="Permalink to “ファイル形式以外の入力”">​</a></h3><p>型ストリッピングは <code>--eval</code> で有効にできます。 モジュールシステムは <code>--input-type</code> によって決定され、JavaScript の場合と同様です。</p><p>TypeScript 構文は、REPL、STDIN 入力、<code>--print</code>、<code>--check</code>、および <code>inspect</code> ではサポートされていません。</p><h3 id="source-maps" tabindex="-1">ソースマップ <a class="header-anchor" href="#source-maps" aria-label="Permalink to “ソースマップ”">​</a></h3><p>インライン型は空白に置き換えられるため、スタックトレースで正しい行番号を表示するためにソースマップは必要ありません。Node.js はそれらを生成しません。 <a href="/ja/nodejs/api/cli#experimental-transform-types"><code>--experimental-transform-types</code></a> が有効な場合、ソースマップはデフォルトで有効になります。</p><h3 id="type-stripping-in-dependencies" tabindex="-1">依存関係における型ストリッピング <a class="header-anchor" href="#type-stripping-in-dependencies" aria-label="Permalink to “依存関係における型ストリッピング”">​</a></h3><p>パッケージの作成者が TypeScript で書かれたパッケージを公開することを推奨しないため、Node.js はデフォルトで <code>node_modules</code> パス以下のフォルダ内の TypeScript ファイルの処理を拒否します。</p><h3 id="paths-aliases" tabindex="-1">パスエイリアス <a class="header-anchor" href="#paths-aliases" aria-label="Permalink to “パスエイリアス”">​</a></h3><p><a href="https://www.typescriptlang.org/tsconfig/#paths" target="_blank" rel="noreferrer"><code>tsconfig</code> &quot;paths&quot;</a> は変換されないため、エラーが発生します。 利用可能な最も近い機能は <a href="/ja/nodejs/api/packages#subpath-imports">サブパスインポート</a> ですが、<code>#</code> で始める必要があるという制限があります。</p>`,40)])}var s=e(a,[[`render`,o]]);export{i as __pageData,s as default};