import{__plugin_vue_export_helper_default as e,createElementBlock as t,createStaticVNode as n,openBlock as r}from"./chunks/plugin-vue_export-helper.Bts1mPc7.js";const i=JSON.parse(`{"title":"Node.js에서의 TypeScript 지원","description":"Node.js에서 TypeScript를 사용하는 방법을 배우세요. 설치, 설정 및 Node.js 프로젝트에 TypeScript를 통합하는 최적의 방법을 포함합니다.","frontmatter":{"title":"Node.js에서의 TypeScript 지원","description":"Node.js에서 TypeScript를 사용하는 방법을 배우세요. 설치, 설정 및 Node.js 프로젝트에 TypeScript를 통합하는 최적의 방법을 포함합니다.","head":[["meta",{"name":"og:title","content":"Node.js에서의 TypeScript 지원 | Node.js - iDoc.dev"}],["meta",{"name":"og:description","content":"Node.js에서 TypeScript를 사용하는 방법을 배우세요. 설치, 설정 및 Node.js 프로젝트에 TypeScript를 통합하는 최적의 방법을 포함합니다."}],["meta",{"name":"twitter:title","content":"Node.js에서의 TypeScript 지원 | Node.js - iDoc.dev"}],["meta",{"name":"twitter:description","content":"Node.js에서 TypeScript를 사용하는 방법을 배우세요. 설치, 설정 및 Node.js 프로젝트에 TypeScript를 통합하는 최적의 방법을 포함합니다."}],["link",{"rel":"canonical","href":"https://idoc.dev/ko/nodejs/api/typescript"}],["meta",{"property":"og:url","content":"https://idoc.dev/ko/nodejs/api/typescript"}]]},"headers":[],"relativePath":"ko/nodejs/api/typescript.md","filePath":"ko/nodejs/api/typescript.md","lastUpdated":1749464498000}`),a={name:`ko/nodejs/api/typescript.md`};function o(e,i,a,o,s,c){return r(),t(`div`,null,i[0]||=[n(`<h1 id="modules-typescript" tabindex="-1">모듈: TypeScript <a class="header-anchor" href="#modules-typescript" aria-label="Permalink to “모듈: TypeScript”">​</a></h1><div class="info custom-block"><p class="custom-block-title">[기록]</p><table tabindex="0"><thead><tr><th>버전</th><th>변경 사항</th></tr></thead><tbody><tr><td>v22.7.0</td><td><code>--experimental-transform-types</code> 플래그 추가.</td></tr></tbody></table></div><div class="warning custom-block"><p class="custom-block-title">[안정성: 1 - 실험적]</p><p><a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a> <a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a>.1 - 활발한 개발</p></div><h2 id="enabling" tabindex="-1">활성화 <a class="header-anchor" href="#enabling" aria-label="Permalink to “활성화”">​</a></h2><p>Node.js에서 런타임 TypeScript 지원을 활성화하는 방법은 두 가지가 있습니다.</p><h2 id="full-typescript-support" tabindex="-1">전체 TypeScript 지원 <a class="header-anchor" href="#full-typescript-support" aria-label="Permalink to “전체 TypeScript 지원”">​</a></h2><p><code>tsconfig.json</code>을 포함한 모든 TypeScript 기능을 완벽하게 지원하는 TypeScript를 사용하려면 타사 패키지를 사용할 수 있습니다. 이 지침에서는 <a href="https://tsx.is/" target="_blank" rel="noreferrer"><code>tsx</code></a>를 예로 사용하지만 다른 유사한 라이브러리도 많이 있습니다.</p><h2 id="type-stripping" tabindex="-1">타입 제거 <a class="header-anchor" href="#type-stripping" aria-label="Permalink to “타입 제거”">​</a></h2><p><strong>v22.6.0에 추가됨</strong></p><div class="warning custom-block"><p class="custom-block-title">[안정성: 1 - 실험적]</p><p><a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a> <a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a>.1 - 활발한 개발</p></div><p>플래그 <a href="/ko/nodejs/api/cli#experimental-strip-types"><code>--experimental-strip-types</code></a>를 사용하면 Node.js가 TypeScript 파일을 실행할 수 있습니다. 기본적으로 Node.js는 열거형 또는 네임스페이스와 같이 변환이 필요한 TypeScript 기능이 없는 파일만 실행합니다. Node.js는 인라인 타입 어노테이션을 공백으로 바꾸고 타입 검사는 수행되지 않습니다. 이러한 기능의 변환을 활성화하려면 플래그 <a href="/ko/nodejs/api/cli#experimental-transform-types"><code>--experimental-transform-types</code></a>를 사용하십시오. paths 또는 최신 JavaScript 구문을 이전 표준으로 변환하는 것과 같이 <code>tsconfig.json</code> 내의 설정에 따라 달라지는 TypeScript 기능은 의도적으로 지원되지 않습니다. 전체 TypeScript 지원을 받으려면 <a href="/ko/nodejs/api/typescript#full-typescript-support">전체 TypeScript 지원</a>을 참조하십시오.</p><p>타입 제거 기능은 경량으로 설계되었습니다. JavaScript 코드 생성이 필요한 구문을 의도적으로 지원하지 않고 인라인 타입을 공백으로 대체함으로써 Node.js는 소스 맵 없이 TypeScript 코드를 실행할 수 있습니다.</p><p>타입 제거는 대부분의 TypeScript 버전에서 작동하지만 다음 <code>tsconfig.json</code> 설정과 함께 버전 5.7 이상을 사용하는 것이 좋습니다.</p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;compilerOptions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     &quot;target&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;esnext&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     &quot;module&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;nodenext&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     &quot;allowImportingTsExtensions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     &quot;rewriteRelativeImportExtensions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     &quot;verbatimModuleSyntax&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="determining-module-system" tabindex="-1">모듈 시스템 결정 <a class="header-anchor" href="#determining-module-system" aria-label="Permalink to “모듈 시스템 결정”">​</a></h3><p>Node.js는 TypeScript 파일에서 <a href="/ko/nodejs/api/modules">CommonJS</a>와 <a href="/ko/nodejs/api/esm">ES Modules</a> 구문을 모두 지원합니다. Node.js는 한 모듈 시스템에서 다른 모듈 시스템으로 변환하지 않습니다. 코드를 ES 모듈로 실행하려면 <code>import</code> 및 <code>export</code> 구문을 사용해야 하고, 코드를 CommonJS로 실행하려면 <code>require</code> 및 <code>module.exports</code>를 사용해야 합니다.</p><ul><li><code>.ts</code> 파일은 <a href="/ko/nodejs/api/packages#determining-module-system"><code>.js</code> 파일과 동일한 방식으로 모듈 시스템이 결정됩니다.</a> <code>import</code> 및 <code>export</code> 구문을 사용하려면 가장 가까운 상위 <code>package.json</code>에 <code>&quot;type&quot;: &quot;module&quot;</code>을 추가하세요.</li><li><code>.mts</code> 파일은 <code>.mjs</code> 파일과 유사하게 항상 ES 모듈로 실행됩니다.</li><li><code>.cts</code> 파일은 <code>.cjs</code> 파일과 유사하게 항상 CommonJS 모듈로 실행됩니다.</li><li><code>.tsx</code> 파일은 지원되지 않습니다.</li></ul><p>JavaScript 파일과 마찬가지로 <code>import</code> 문과 <code>import()</code> 식에서 <a href="/ko/nodejs/api/esm#mandatory-file-extensions">파일 확장자는 필수입니다.</a> 예를 들어 <code>import &#39;./file&#39;</code>이 아닌 <code>import &#39;./file.ts&#39;</code>를 사용해야 합니다. 이전 버전과의 호환성 때문에 파일 확장자는 <code>require()</code> 호출에서도 필수입니다. 예를 들어 <code>.cjs</code> 확장자가 CommonJS 파일의 <code>require</code> 호출에서 필수인 것과 유사하게 <code>require(&#39;./file&#39;)</code>이 아닌 <code>require(&#39;./file.ts&#39;)</code>를 사용해야 합니다.</p><p><code>tsconfig.json</code> 옵션 <code>allowImportingTsExtensions</code>를 사용하면 TypeScript 컴파일러 <code>tsc</code>가 <code>.ts</code> 확장자를 포함하는 <code>import</code> 지정자를 사용하여 파일을 유형 검사할 수 있습니다.</p><h3 id="typescript-features" tabindex="-1">TypeScript 기능 <a class="header-anchor" href="#typescript-features" aria-label="Permalink to “TypeScript 기능”">​</a></h3><p>Node.js는 인라인 유형만 제거하므로 TypeScript 구문을 새 JavaScript 구문으로 <em>대체</em>하는 TypeScript 기능은 <a href="/ko/nodejs/api/cli#experimental-transform-types"><code>--experimental-transform-types</code></a> 플래그가 전달되지 않으면 오류가 발생합니다.</p><p>변환이 필요한 가장 눈에 띄는 기능은 다음과 같습니다.</p><ul><li><code>Enum</code></li><li><code>namespaces</code></li><li><code>legacy module</code></li><li>파라미터 속성</li></ul><p>데코레이터는 현재 <a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="noreferrer">TC39 Stage 3 제안</a>이며 곧 JavaScript 엔진에서 지원될 예정이므로 변환되지 않고 파서 오류가 발생합니다. 이것은 일시적인 제한 사항이며 앞으로 해결될 것입니다.</p><p>또한 Node.js는 <code>tsconfig.json</code> 파일을 읽지 않으며 경로 또는 최신 JavaScript 구문을 이전 표준으로 변환하는 것과 같이 <code>tsconfig.json</code> 내의 설정에 의존하는 기능을 지원하지 않습니다.</p><h3 id="importing-types-without-type-keyword" tabindex="-1"><code>type</code> 키워드 없이 타입 가져오기 <a class="header-anchor" href="#importing-types-without-type-keyword" aria-label="Permalink to “type 키워드 없이 타입 가져오기”">​</a></h3><p>타입 제거의 특성상, 타입 가져오기를 올바르게 제거하려면 <code>type</code> 키워드가 필요합니다. <code>type</code> 키워드가 없으면 Node.js는 가져오기를 값 가져오기로 처리하여 런타임 오류가 발생합니다. tsconfig 옵션인 <a href="https://www.typescriptlang.org/tsconfig/#verbatimModuleSyntax" target="_blank" rel="noreferrer"><code>verbatimModuleSyntax</code></a>를 사용하여 이 동작을 일치시킬 수 있습니다.</p><p>다음 예제는 올바르게 작동합니다.</p><div class="language-ts line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Type1, Type2 } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./module.ts&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { fn, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> FnParams } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./fn.ts&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>다음은 런타임 오류를 발생시킵니다.</p><div class="language-ts line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Type1, Type2 } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./module.ts&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { fn, FnParams } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./fn.ts&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="non-file-forms-of-input" tabindex="-1">파일 형태가 아닌 입력 <a class="header-anchor" href="#non-file-forms-of-input" aria-label="Permalink to “파일 형태가 아닌 입력”">​</a></h3><p><code>--eval</code>에 대해 타입 제거를 활성화할 수 있습니다. 모듈 시스템은 JavaScript와 마찬가지로 <code>--input-type</code>에 의해 결정됩니다.</p><p>TypeScript 구문은 REPL, STDIN 입력, <code>--print</code>, <code>--check</code> 및 <code>inspect</code>에서 지원되지 않습니다.</p><h3 id="source-maps" tabindex="-1">소스 맵 <a class="header-anchor" href="#source-maps" aria-label="Permalink to “소스 맵”">​</a></h3><p>인라인 타입은 공백으로 대체되므로 스택 추적에서 올바른 줄 번호를 위해 소스 맵이 필요하지 않습니다. Node.js는 소스 맵을 생성하지 않습니다. <a href="/ko/nodejs/api/cli#experimental-transform-types"><code>--experimental-transform-types</code></a>가 활성화되면 소스 맵이 기본적으로 활성화됩니다.</p><h3 id="type-stripping-in-dependencies" tabindex="-1">종속성의 타입 제거 <a class="header-anchor" href="#type-stripping-in-dependencies" aria-label="Permalink to “종속성의 타입 제거”">​</a></h3><p>패키지 작성자가 TypeScript로 작성된 패키지를 게시하는 것을 막기 위해 Node.js는 기본적으로 <code>node_modules</code> 경로 아래 폴더 내의 TypeScript 파일을 처리하지 않습니다.</p><h3 id="paths-aliases" tabindex="-1">경로 별칭 <a class="header-anchor" href="#paths-aliases" aria-label="Permalink to “경로 별칭”">​</a></h3><p><a href="https://www.typescriptlang.org/tsconfig/#paths" target="_blank" rel="noreferrer"><code>tsconfig</code> &quot;paths&quot;</a>는 변환되지 않으므로 오류가 발생합니다. 사용 가능한 가장 가까운 기능은 <code>#</code>로 시작해야 한다는 제한이 있는 <a href="/ko/nodejs/api/packages#subpath-imports">서브패스 가져오기</a>입니다.</p>`,40)])}var s=e(a,[[`render`,o]]);export{i as __pageData,s as default};