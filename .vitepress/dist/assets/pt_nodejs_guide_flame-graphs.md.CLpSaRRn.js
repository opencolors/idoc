import{__plugin_vue_export_helper_default as e,createElementBlock as t,createStaticVNode as n,openBlock as r}from"./chunks/plugin-vue_export-helper.Bts1mPc7.js";const i=JSON.parse(`{"title":"Gráficos de chamas para otimização de desempenho do Node.js","description":"Saiba como criar gráficos de chamas para visualizar o tempo de CPU gasto em funções e otimizar o desempenho do Node.js.","frontmatter":{"title":"Gráficos de chamas para otimização de desempenho do Node.js","description":"Saiba como criar gráficos de chamas para visualizar o tempo de CPU gasto em funções e otimizar o desempenho do Node.js.","head":[["meta",{"name":"og:title","content":"Gráficos de chamas para otimização de desempenho do Node.js | Node.js - iDoc.dev"}],["meta",{"name":"og:description","content":"Saiba como criar gráficos de chamas para visualizar o tempo de CPU gasto em funções e otimizar o desempenho do Node.js."}],["meta",{"name":"twitter:title","content":"Gráficos de chamas para otimização de desempenho do Node.js | Node.js - iDoc.dev"}],["meta",{"name":"twitter:description","content":"Saiba como criar gráficos de chamas para visualizar o tempo de CPU gasto em funções e otimizar o desempenho do Node.js."}],["link",{"rel":"canonical","href":"https://idoc.dev/pt/nodejs/guide/flame-graphs"}],["meta",{"property":"og:url","content":"https://idoc.dev/pt/nodejs/guide/flame-graphs"}]]},"headers":[],"relativePath":"pt/nodejs/guide/flame-graphs.md","filePath":"pt/nodejs/guide/flame-graphs.md","lastUpdated":1749464498000}`),a={name:`pt/nodejs/guide/flame-graphs.md`};function o(e,i,a,o,s,c){return r(),t(`div`,null,i[0]||=[n(`<h1 id="graficos-de-chamas" tabindex="-1">Gráficos de Chamas <a class="header-anchor" href="#graficos-de-chamas" aria-label="Permalink to “Gráficos de Chamas”">​</a></h1><h2 id="para-que-serve-um-grafico-de-chamas" tabindex="-1">Para que serve um gráfico de chamas? <a class="header-anchor" href="#para-que-serve-um-grafico-de-chamas" aria-label="Permalink to “Para que serve um gráfico de chamas?”">​</a></h2><p>Gráficos de chamas são uma forma de visualizar o tempo de CPU gasto em funções. Eles podem ajudá-lo a identificar onde você gasta muito tempo fazendo operações síncronas.</p><h2 id="como-criar-um-grafico-de-chamas" tabindex="-1">Como criar um gráfico de chamas <a class="header-anchor" href="#como-criar-um-grafico-de-chamas" aria-label="Permalink to “Como criar um gráfico de chamas”">​</a></h2><p>Você pode ter ouvido que criar um gráfico de chamas para Node.js é difícil, mas isso não é verdade (mais). VMs Solaris não são mais necessárias para gráficos de chamas!</p><p>Gráficos de chamas são gerados a partir da saída do <code>perf</code>, que não é uma ferramenta específica do Node. Embora seja a maneira mais poderosa de visualizar o tempo de CPU gasto, pode ter problemas com a forma como o código JavaScript é otimizado no Node.js 8 e superior. Consulte a seção <a href="#perf-output-issues">problemas de saída do perf</a> abaixo.</p><h3 id="use-uma-ferramenta-pre-embalada" tabindex="-1">Use uma ferramenta pré-embalada <a class="header-anchor" href="#use-uma-ferramenta-pre-embalada" aria-label="Permalink to “Use uma ferramenta pré-embalada”">​</a></h3><p>Se você quiser uma única etapa que produza um gráfico de chamas localmente, tente <a href="https://www.npmjs.com/package/0x" target="_blank" rel="noreferrer">0x</a></p><p>Para diagnosticar implantações de produção, leia estas notas: <a href="https://github.com/davidmarkclements/0x/blob/master/docs/production-servers.md" target="_blank" rel="noreferrer">0x servidores de produção</a>.</p><h3 id="crie-um-grafico-de-chamas-com-ferramentas-perf-do-sistema" tabindex="-1">Crie um gráfico de chamas com ferramentas perf do sistema <a class="header-anchor" href="#crie-um-grafico-de-chamas-com-ferramentas-perf-do-sistema" aria-label="Permalink to “Crie um gráfico de chamas com ferramentas perf do sistema”">​</a></h3><p>O objetivo deste guia é mostrar as etapas envolvidas na criação de um gráfico de chamas e mantê-lo no controle de cada etapa.</p><p>Se você quiser entender melhor cada etapa, dê uma olhada nas seções que seguem, onde entraremos em mais detalhes.</p><p>Agora vamos trabalhar.</p><ol><li>Instale o <code>perf</code> (geralmente disponível através do pacote linux-tools-common se ainda não estiver instalado)</li><li>Tente executar o <code>perf</code> - ele pode reclamar sobre módulos do kernel ausentes, instale-os também</li><li>Execute o node com o perf habilitado (consulte <a href="#perf-output-issues">problemas de saída do perf</a> para dicas específicas para versões do Node.js)</li></ol><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">perf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> record</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cycles:u</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --perf-basic-prof</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app.js</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ol start="4"><li>Ignore os avisos, a menos que digam que você não pode executar o perf devido a pacotes ausentes; você pode receber alguns avisos sobre não ser capaz de acessar amostras de módulos do kernel que você não está buscando de qualquer maneira.</li><li>Execute <code>perf script &gt; perfs.out</code> para gerar o arquivo de dados que você visualizará em um momento. É útil aplicar alguma limpeza para um gráfico mais legível</li><li>Instale o stackvis se ainda não estiver instalado <code>npm i -g stackvis</code></li><li>Execute <code>stackvis perf &lt; perfs.out &gt; flamegraph.htm</code></li></ol><p>Agora abra o arquivo de gráfico de chamas em seu navegador favorito e observe-o queimar. É codificado por cores para que você possa se concentrar primeiro nas barras laranja mais saturadas. É provável que representem funções pesadas de CPU.</p><p>Vale a pena mencionar - se você clicar em um elemento de um gráfico de chamas, um zoom de seus arredores será exibido acima do gráfico.</p><h3 id="usando-perf-para-amostrar-um-processo-em-execucao" tabindex="-1">Usando <code>perf</code> para amostrar um processo em execução <a class="header-anchor" href="#usando-perf-para-amostrar-um-processo-em-execucao" aria-label="Permalink to “Usando perf para amostrar um processo em execução”">​</a></h3><p>Isso é ótimo para gravar dados do gráfico de chamas de um processo já em execução que você não deseja interromper. Imagine um processo de produção com um problema difícil de reproduzir.</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">perf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> record</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -F99</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pgrep</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node\`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> --</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sleep</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Para que serve esse <code>sleep 3</code>? Ele está lá para manter o perf em execução - apesar da opção <code>-p</code> apontar para um pid diferente, o comando precisa ser executado em um processo e terminar com ele. O perf é executado durante a vida útil do comando que você passa para ele, quer você esteja ou não realmente fazendo o profiling desse comando. <code>sleep 3</code> garante que o perf seja executado por 3 segundos.</p><p>Por que <code>-F</code> (frequência de profiling) está definido como 99? É um padrão razoável. Você pode ajustar se quiser. <code>-F99</code> diz ao perf para coletar 99 amostras por segundo, para mais precisão aumente o valor. Valores mais baixos devem produzir menos saída com resultados menos precisos. A precisão que você precisa depende de quanto tempo suas funções intensivas em CPU realmente são executadas. Se você está procurando o motivo de uma desaceleração notável, 99 quadros por segundo devem ser mais do que suficientes.</p><p>Depois de obter o registro perf de 3 segundos, prossiga com a geração do gráfico de chamas com as duas últimas etapas acima.</p><h3 id="filtrando-funcoes-internas-do-node-js" tabindex="-1">Filtrando funções internas do Node.js <a class="header-anchor" href="#filtrando-funcoes-internas-do-node-js" aria-label="Permalink to “Filtrando funções internas do Node.js”">​</a></h3><p>Normalmente, você só quer observar o desempenho de suas chamadas, então filtrar as funções internas do Node.js e do V8 pode tornar o gráfico muito mais fácil de ler. Você pode limpar seu arquivo perf com:</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sed</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -i</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -r</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/(_libc_start|LazyCompile) |v8::internal::BuiltIn|Stub|LoadIC:\\\\[\\\\[&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/^$/d&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    perf.data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> perf.out</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Se você ler seu gráfico de chamas e parecer estranho, como se algo estivesse faltando na função chave que ocupa a maior parte do tempo, tente gerar seu gráfico de chamas sem os filtros - talvez você tenha um caso raro de um problema com o próprio Node.js.</p><h3 id="opcoes-de-profiling-do-node-js" tabindex="-1">Opções de profiling do Node.js <a class="header-anchor" href="#opcoes-de-profiling-do-node-js" aria-label="Permalink to “Opções de profiling do Node.js”">​</a></h3><p><code>--perf-basic-prof-only-functions</code> e <code>--perf-basic-prof</code> são as duas que são úteis para depurar seu código JavaScript. Outras opções são usadas para fazer o profiling do próprio Node.js, o que está fora do escopo deste guia.</p><p><code>--perf-basic-prof-only-functions</code> produz menos saída, então é a opção com a menor sobrecarga.</p><h3 id="por-que-eu-preciso-deles" tabindex="-1">Por que eu preciso deles? <a class="header-anchor" href="#por-que-eu-preciso-deles" aria-label="Permalink to “Por que eu preciso deles?”">​</a></h3><p>Bem, sem essas opções, você ainda terá um flame graph, mas com a maioria das barras rotuladas como <code>v8::Function::Call</code>.</p><h2 id="problemas-com-a-saida-do-perf" tabindex="-1">Problemas com a saída do <code>Perf</code> <a class="header-anchor" href="#problemas-com-a-saida-do-perf" aria-label="Permalink to “Problemas com a saída do Perf”">​</a></h2><h3 id="mudancas-no-pipeline-do-v8-no-node-js-8-x" tabindex="-1">Mudanças no pipeline do V8 no Node.js 8.x <a class="header-anchor" href="#mudancas-no-pipeline-do-v8-no-node-js-8-x" aria-label="Permalink to “Mudanças no pipeline do V8 no Node.js 8.x”">​</a></h3><p>O Node.js 8.x e superior vem com novas otimizações no pipeline de compilação JavaScript no mecanismo V8, o que torna os nomes/referências de funções inacessíveis para o perf às vezes. (É chamado de Turbofan)</p><p>O resultado é que você pode não obter os nomes das suas funções corretamente no flame graph.</p><p>Você notará <code>ByteCodeHandler:</code> onde esperaria nomes de funções.</p><p>O 0x tem algumas mitigações para isso integradas.</p><p>Para detalhes, veja:</p><ul><li><a href="https://github.com/nodejs/benchmarking/issues/168" target="_blank" rel="noreferrer">https://github.com/nodejs/benchmarking/issues/168</a></li><li><a href="https://github.com/nodejs/diagnostics/issues/148#issuecomment-369348961" target="_blank" rel="noreferrer">https://github.com/nodejs/diagnostics/issues/148#issuecomment-369348961</a></li></ul><h3 id="node-js-10" tabindex="-1">Node.js 10+ <a class="header-anchor" href="#node-js-10" aria-label="Permalink to “Node.js 10+”">​</a></h3><p>O Node.js 10.x resolve o problema com o Turbofan usando a flag <code>--interpreted-frames-native-stack</code>.</p><p>Execute <code>node --interpreted-frames-native-stack --perf-basic-prof-only-functions</code> para obter nomes de funções no flame graph, independentemente de qual pipeline o V8 usou para compilar seu JavaScript.</p><h3 id="rotulos-quebrados-no-flame-graph" tabindex="-1">Rótulos quebrados no flame graph <a class="header-anchor" href="#rotulos-quebrados-no-flame-graph" aria-label="Permalink to “Rótulos quebrados no flame graph”">​</a></h3><p>Se você estiver vendo rótulos parecendo com isso</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">node</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_ZN2v88internal11interpreter17BytecodeGenerator15VisitStatementsEPMS0_8Zone</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>isso significa que o Linux perf que você está usando não foi compilado com suporte a demangle, veja <a href="https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1396654" target="_blank" rel="noreferrer">https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1396654</a> por exemplo</p><h2 id="exemplos" tabindex="-1">Exemplos <a class="header-anchor" href="#exemplos" aria-label="Permalink to “Exemplos”">​</a></h2><p>Pratique capturar flame graphs você mesmo com um <a href="https://github.com/naugtur/node-example-flamegraph" target="_blank" rel="noreferrer">exercício de flame graph</a>!</p>`,50)])}var s=e(a,[[`render`,o]]);export{i as __pageData,s as default};