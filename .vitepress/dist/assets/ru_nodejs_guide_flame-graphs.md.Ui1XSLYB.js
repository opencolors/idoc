import{__plugin_vue_export_helper_default as e,createElementBlock as t,createStaticVNode as n,openBlock as r}from"./chunks/plugin-vue_export-helper.Bts1mPc7.js";const i=JSON.parse(`{"title":"Графики пламени для оптимизации производительности Node.js","description":"Узнайте, как создавать графики пламени для визуализации времени CPU, затраченного на функции, и оптимизировать производительность Node.js.","frontmatter":{"title":"Графики пламени для оптимизации производительности Node.js","description":"Узнайте, как создавать графики пламени для визуализации времени CPU, затраченного на функции, и оптимизировать производительность Node.js.","head":[["meta",{"name":"og:title","content":"Графики пламени для оптимизации производительности Node.js | Node.js - iDoc.dev"}],["meta",{"name":"og:description","content":"Узнайте, как создавать графики пламени для визуализации времени CPU, затраченного на функции, и оптимизировать производительность Node.js."}],["meta",{"name":"twitter:title","content":"Графики пламени для оптимизации производительности Node.js | Node.js - iDoc.dev"}],["meta",{"name":"twitter:description","content":"Узнайте, как создавать графики пламени для визуализации времени CPU, затраченного на функции, и оптимизировать производительность Node.js."}],["link",{"rel":"canonical","href":"https://idoc.dev/ru/nodejs/guide/flame-graphs"}],["meta",{"property":"og:url","content":"https://idoc.dev/ru/nodejs/guide/flame-graphs"}]]},"headers":[],"relativePath":"ru/nodejs/guide/flame-graphs.md","filePath":"ru/nodejs/guide/flame-graphs.md","lastUpdated":1749464498000}`),a={name:`ru/nodejs/guide/flame-graphs.md`};function o(e,i,a,o,s,c){return r(),t(`div`,null,i[0]||=[n(`<h1 id="огненные-графики-flame-graphs" tabindex="-1">Огненные графики (Flame Graphs) <a class="header-anchor" href="#огненные-графики-flame-graphs" aria-label="Permalink to “Огненные графики (Flame Graphs)”">​</a></h1><h2 id="для-чего-полезен-огненныи-график" tabindex="-1">Для чего полезен огненный график? <a class="header-anchor" href="#для-чего-полезен-огненныи-график" aria-label="Permalink to “Для чего полезен огненный график?”">​</a></h2><p>Огненные графики - это способ визуализации времени процессора, потраченного на функции. Они могут помочь вам определить, где вы тратите слишком много времени на синхронные операции.</p><h2 id="как-создать-огненныи-график" tabindex="-1">Как создать огненный график <a class="header-anchor" href="#как-создать-огненныи-график" aria-label="Permalink to “Как создать огненный график”">​</a></h2><p>Возможно, вы слышали, что создать огненный график для Node.js сложно, но это не так (больше). Виртуальные машины Solaris больше не нужны для огненных графиков!</p><p>Огненные графики генерируются из вывода <code>perf</code>, который не является специфичным для node инструментом. Хотя это самый мощный способ визуализации времени процессора, он может иметь проблемы с тем, как код JavaScript оптимизируется в Node.js 8 и выше. См. раздел <a href="#perf-output-issues">проблемы вывода perf</a> ниже.</p><h3 id="использовать-готовыи-инструмент" tabindex="-1">Использовать готовый инструмент <a class="header-anchor" href="#использовать-готовыи-инструмент" aria-label="Permalink to “Использовать готовый инструмент”">​</a></h3><p>Если вам нужен один шаг для создания огненного графика локально, попробуйте <a href="https://www.npmjs.com/package/0x" target="_blank" rel="noreferrer">0x</a></p><p>Для диагностики производственных развертываний прочитайте эти заметки: <a href="https://github.com/davidmarkclements/0x/blob/master/docs/production-servers.md" target="_blank" rel="noreferrer">0x production servers</a>.</p><h3 id="создать-огненныи-график-с-помощью-системных-инструментов-perf" tabindex="-1">Создать огненный график с помощью системных инструментов perf <a class="header-anchor" href="#создать-огненныи-график-с-помощью-системных-инструментов-perf" aria-label="Permalink to “Создать огненный график с помощью системных инструментов perf”">​</a></h3><p>Цель этого руководства - показать шаги, необходимые для создания огненного графика, и сохранить контроль над каждым шагом.</p><p>Если вы хотите лучше понять каждый шаг, ознакомьтесь с последующими разделами, где мы углубимся в детали.</p><p>Теперь приступим к работе.</p><ol><li>Установите <code>perf</code> (обычно доступен через пакет linux-tools-common, если еще не установлен)</li><li>Попробуйте запустить <code>perf</code> - он может жаловаться на отсутствие модулей ядра, установите их тоже</li><li>Запустите node с включенным perf (см. <a href="#perf-output-issues">проблемы вывода perf</a> для советов, специфичных для версий Node.js)</li></ol><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">perf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> record</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cycles:u</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --perf-basic-prof</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app.js</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ol start="4"><li>Игнорируйте предупреждения, если они не говорят о том, что вы не можете запустить perf из-за отсутствующих пакетов; вы можете получить некоторые предупреждения о невозможности доступа к образцам модулей ядра, которые вам все равно не нужны.</li><li>Запустите <code>perf script &gt; perfs.out</code>, чтобы сгенерировать файл данных, который вы визуализируете в данный момент. Полезно применить некоторую очистку для более читаемого графика</li><li>Установите stackvis, если он еще не установлен <code>npm i -g stackvis</code></li><li>Запустите <code>stackvis perf &lt; perfs.out &gt; flamegraph.htm</code></li></ol><p>Теперь откройте файл огненного графика в своем любимом браузере и смотрите, как он горит. Он имеет цветовую кодировку, поэтому вы можете сначала сосредоточиться на самых насыщенных оранжевых полосах. Скорее всего, они представляют собой функции, интенсивно использующие ЦП.</p><p>Стоит упомянуть - если вы нажмете на элемент огненного графика, над графиком будет отображено увеличенное изображение его окружения.</p><h3 id="использование-perf-для-профилирования-работающего-процесса" tabindex="-1">Использование <code>perf</code> для профилирования работающего процесса <a class="header-anchor" href="#использование-perf-для-профилирования-работающего-процесса" aria-label="Permalink to “Использование perf для профилирования работающего процесса”">​</a></h3><p>Это отлично подходит для записи данных flame graph из уже работающего процесса, который вы не хотите прерывать. Представьте себе производственный процесс с трудновоспроизводимой проблемой.</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">perf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> record</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -F99</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pgrep</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node\`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> --</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sleep</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Для чего нужен <code>sleep 3</code>? Он нужен для того, чтобы perf продолжал работать - несмотря на то, что опция <code>-p</code> указывает на другой pid, команда должна быть выполнена в процессе и завершиться вместе с ним. perf работает в течение всего времени выполнения команды, которую вы ей передаете, независимо от того, профилируете вы эту команду или нет. <code>sleep 3</code> гарантирует, что perf будет работать в течение 3 секунд.</p><p>Почему <code>-F</code> (частота профилирования) установлена на 99? Это разумное значение по умолчанию. Вы можете настроить его, если хотите. <code>-F99</code> указывает perf делать 99 выборок в секунду, для большей точности увеличьте значение. Более низкие значения должны давать меньше выходных данных с менее точными результатами. Необходимая вам точность зависит от того, как долго на самом деле работают ваши ресурсоемкие функции. Если вы ищете причину заметного замедления, 99 кадров в секунду должно быть более чем достаточно.</p><p>После того, как вы получите 3-секундную запись perf, переходите к созданию flame graph с помощью двух последних шагов, описанных выше.</p><h3 id="фильтрация-внутренних-функции-node-js" tabindex="-1">Фильтрация внутренних функций Node.js <a class="header-anchor" href="#фильтрация-внутренних-функции-node-js" aria-label="Permalink to “Фильтрация внутренних функций Node.js”">​</a></h3><p>Обычно вы просто хотите посмотреть на производительность ваших вызовов, поэтому фильтрация внутренних функций Node.js и V8 может сделать граф намного проще для чтения. Вы можете очистить свой perf-файл с помощью:</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sed</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -i</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -r</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/(_libc_start|LazyCompile) |v8::internal::BuiltIn|Stub|LoadIC:\\\\[\\\\[&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/^$/d&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    perf.data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> perf.out</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Если вы читаете свой flame graph и он кажется странным, как будто что-то отсутствует в ключевой функции, занимающей большую часть времени, попробуйте сгенерировать свой flame graph без фильтров - возможно, вы столкнулись с редким случаем проблемы с самой Node.js.</p><h3 id="параметры-профилирования-node-js" tabindex="-1">Параметры профилирования Node.js <a class="header-anchor" href="#параметры-профилирования-node-js" aria-label="Permalink to “Параметры профилирования Node.js”">​</a></h3><p><code>--perf-basic-prof-only-functions</code> и <code>--perf-basic-prof</code> - это два параметра, которые полезны для отладки вашего JavaScript-кода. Другие параметры используются для профилирования самой Node.js, что выходит за рамки данного руководства.</p><p><code>--perf-basic-prof-only-functions</code> выдает меньше выходных данных, поэтому это вариант с наименьшими накладными расходами.</p><h3 id="зачем-они-вообще-нужны" tabindex="-1">Зачем они вообще нужны? <a class="header-anchor" href="#зачем-они-вообще-нужны" aria-label="Permalink to “Зачем они вообще нужны?”">​</a></h3><p>Что ж, без этих опций вы все равно получите flame graph, но с большинством полос, помеченных как <code>v8::Function::Call</code>.</p><h2 id="проблемы-с-выводом-perf" tabindex="-1">Проблемы с выводом <code>Perf</code> <a class="header-anchor" href="#проблемы-с-выводом-perf" aria-label="Permalink to “Проблемы с выводом Perf”">​</a></h2><h3 id="изменения-конвеиера-v8-в-node-js-8-x" tabindex="-1">Изменения конвейера V8 в Node.js 8.x <a class="header-anchor" href="#изменения-конвеиера-v8-в-node-js-8-x" aria-label="Permalink to “Изменения конвейера V8 в Node.js 8.x”">​</a></h3><p>Node.js 8.x и выше поставляется с новыми оптимизациями конвейера компиляции JavaScript в движке V8, из-за которых имена/ссылки функций иногда становятся недоступными для perf. (Это называется Turbofan)</p><p>В результате вы можете не получить правильные имена функций в flame graph.</p><p>Вы заметите <code>ByteCodeHandler:</code>, где ожидали увидеть имена функций.</p><p>В 0x встроены некоторые средства для смягчения этой проблемы.</p><p>Подробности см.:</p><ul><li><a href="https://github.com/nodejs/benchmarking/issues/168" target="_blank" rel="noreferrer">https://github.com/nodejs/benchmarking/issues/168</a></li><li><a href="https://github.com/nodejs/diagnostics/issues/148#issuecomment-369348961" target="_blank" rel="noreferrer">https://github.com/nodejs/diagnostics/issues/148#issuecomment-369348961</a></li></ul><h3 id="node-js-10" tabindex="-1">Node.js 10+ <a class="header-anchor" href="#node-js-10" aria-label="Permalink to “Node.js 10+”">​</a></h3><p>Node.js 10.x решает проблему с Turbofan с помощью флага <code>--interpreted-frames-native-stack</code>.</p><p>Запустите <code>node --interpreted-frames-native-stack --perf-basic-prof-only-functions</code>, чтобы получить имена функций в flame graph независимо от того, какой конвейер V8 использовался для компиляции вашего JavaScript.</p><h3 id="сломанные-метки-в-flame-graph" tabindex="-1">Сломанные метки в flame graph <a class="header-anchor" href="#сломанные-метки-в-flame-graph" aria-label="Permalink to “Сломанные метки в flame graph”">​</a></h3><p>Если вы видите метки, выглядящие так:</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">node</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_ZN2v88internal11interpreter17BytecodeGenerator15VisitStatementsEPMS0_8Zone</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>это означает, что Linux perf, который вы используете, был скомпилирован без поддержки demangle, см., например, <a href="https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1396654" target="_blank" rel="noreferrer">https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1396654</a></p><h2 id="примеры" tabindex="-1">Примеры <a class="header-anchor" href="#примеры" aria-label="Permalink to “Примеры”">​</a></h2><p>Попрактикуйтесь в захвате flame graph самостоятельно с помощью <a href="https://github.com/naugtur/node-example-flamegraph" target="_blank" rel="noreferrer">упражнения по созданию flame graph</a>!</p>`,50)])}var s=e(a,[[`render`,o]]);export{i as __pageData,s as default};