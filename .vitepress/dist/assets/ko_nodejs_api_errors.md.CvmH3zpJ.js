import{__plugin_vue_export_helper_default as e,createElementBlock as t,createStaticVNode as n,openBlock as r}from"./chunks/plugin-vue_export-helper.Bts1mPc7.js";const i=JSON.parse(`{"title":"Node.js 문서 - 오류","description":"이 Node.js 문서의 섹션에서는 오류 클래스, 오류 코드 및 Node.js 애플리케이션에서 오류를 처리하는 방법에 대해 자세히 설명합니다.","frontmatter":{"title":"Node.js 문서 - 오류","description":"이 Node.js 문서의 섹션에서는 오류 클래스, 오류 코드 및 Node.js 애플리케이션에서 오류를 처리하는 방법에 대해 자세히 설명합니다.","head":[["meta",{"name":"og:title","content":"Node.js 문서 - 오류 | Node.js - iDoc.dev"}],["meta",{"name":"og:description","content":"이 Node.js 문서의 섹션에서는 오류 클래스, 오류 코드 및 Node.js 애플리케이션에서 오류를 처리하는 방법에 대해 자세히 설명합니다."}],["meta",{"name":"twitter:title","content":"Node.js 문서 - 오류 | Node.js - iDoc.dev"}],["meta",{"name":"twitter:description","content":"이 Node.js 문서의 섹션에서는 오류 클래스, 오류 코드 및 Node.js 애플리케이션에서 오류를 처리하는 방법에 대해 자세히 설명합니다."}],["link",{"rel":"canonical","href":"https://idoc.dev/ko/nodejs/api/errors"}],["meta",{"property":"og:url","content":"https://idoc.dev/ko/nodejs/api/errors"}]]},"headers":[],"relativePath":"ko/nodejs/api/errors.md","filePath":"ko/nodejs/api/errors.md","lastUpdated":null}`),a={name:`ko/nodejs/api/errors.md`};function o(e,i,a,o,s,c){return r(),t(`div`,null,i[0]||=[n(`<h1 id="errors" tabindex="-1">오류 <a class="header-anchor" href="#errors" aria-label="Permalink to “오류”">​</a></h1><p>Node.js에서 실행되는 애플리케이션은 일반적으로 네 가지 범주의 오류를 경험합니다.</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError" target="_blank" rel="noreferrer">&lt;EvalError&gt;</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError" target="_blank" rel="noreferrer">&lt;SyntaxError&gt;</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError" target="_blank" rel="noreferrer">&lt;RangeError&gt;</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError" target="_blank" rel="noreferrer">&lt;ReferenceError&gt;</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError" target="_blank" rel="noreferrer">&lt;TypeError&gt;</a> 및 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError" target="_blank" rel="noreferrer">&lt;URIError&gt;</a>와 같은 표준 JavaScript 오류.</li><li>존재하지 않는 파일을 열거나 닫힌 소켓을 통해 데이터를 보내려고 시도하는 것과 같은 기본 운영 체제 제약 조건으로 인해 발생하는 시스템 오류.</li><li>애플리케이션 코드로 인해 발생하는 사용자 지정 오류.</li><li><code>AssertionError</code>는 Node.js가 발생해서는 안 되는 예외적인 논리 위반을 감지할 때 발생할 수 있는 특수한 종류의 오류입니다. 이러한 오류는 일반적으로 <code>node:assert</code> 모듈에서 발생합니다.</li></ul><p>Node.js에서 발생하는 모든 JavaScript 및 시스템 오류는 표준 JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" target="_blank" rel="noreferrer">&lt;Error&gt;</a> 클래스에서 상속되거나 해당 클래스의 인스턴스이며 해당 클래스에서 사용할 수 있는 속성을 <em>최소한</em> 제공합니다.</p><h2 id="error-propagation-and-interception" tabindex="-1">오류 전파 및 인터셉트 <a class="header-anchor" href="#error-propagation-and-interception" aria-label="Permalink to “오류 전파 및 인터셉트”">​</a></h2><p>Node.js는 애플리케이션이 실행되는 동안 발생하는 오류를 전파하고 처리하는 여러 메커니즘을 지원합니다. 이러한 오류가 보고되고 처리되는 방식은 <code>Error</code>의 유형과 호출되는 API 스타일에 따라 완전히 달라집니다.</p><p>모든 JavaScript 오류는 표준 JavaScript <code>throw</code> 메커니즘을 사용하여 오류를 <em>즉시</em> 생성하고 발생시키는 예외로 처리됩니다. 이러한 오류는 JavaScript 언어에서 제공하는 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch" target="_blank" rel="noreferrer"><code>try…catch</code> 구성</a>을 사용하여 처리됩니다.</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// z가 정의되지 않았기 때문에 ReferenceError와 함께 발생합니다.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> m</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> z;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (err) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 여기에서 오류를 처리합니다.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>JavaScript <code>throw</code> 메커니즘을 사용하면 <em>처리해야</em> 하는 예외가 발생하거나 Node.js 프로세스가 즉시 종료됩니다.</p><p>몇 가지 예외를 제외하고 <em>동기</em> API(<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noreferrer">&lt;Promise&gt;</a>를 반환하거나 <a href="/ko/nodejs/api/fs#fsreadfilesyncpath-options"><code>fs.readFileSync</code></a>와 같이 <code>callback</code> 함수를 허용하지 않는 모든 차단 메서드)는 <code>throw</code>를 사용하여 오류를 보고합니다.</p><p><em>비동기 API</em> 내에서 발생하는 오류는 여러 가지 방법으로 보고될 수 있습니다.</p><ul><li>일부 비동기 메서드는 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noreferrer">&lt;Promise&gt;</a>를 반환합니다. 거부될 수 있다는 점을 항상 고려해야 합니다. 처리되지 않은 Promise 거부에 프로세스가 어떻게 반응하는지에 대한 자세한 내용은 <a href="/ko/nodejs/api/cli#unhandled-rejectionsmode"><code>--unhandled-rejections</code></a> 플래그를 참조하십시오.</li><li><code>callback</code> 함수를 허용하는 대부분의 비동기 메서드는 해당 함수의 첫 번째 인수로 전달되는 <code>Error</code> 객체를 허용합니다. 해당 첫 번째 인수가 <code>null</code>이 아니고 <code>Error</code>의 인스턴스인 경우 처리해야 하는 오류가 발생한 것입니다.</li><li>비동기 메서드가 <a href="/ko/nodejs/api/events#class-eventemitter"><code>EventEmitter</code></a>인 객체에서 호출되면 오류가 해당 객체의 <code>&#39;error&#39;</code> 이벤트로 라우팅될 수 있습니다.</li><li>Node.js API의 일반적인 비동기 메서드 중 일부는 여전히 <code>throw</code> 메커니즘을 사용하여 <code>try…catch</code>를 사용하여 처리해야 하는 예외를 발생시킬 수 있습니다. 이러한 메서드의 포괄적인 목록은 없습니다. 필요한 적절한 오류 처리 메커니즘을 확인하려면 각 메서드의 문서를 참조하십시오.</li></ul><p><code>&#39;error&#39;</code> 이벤트 메커니즘의 사용은 <a href="/ko/nodejs/api/stream">스트림 기반</a> 및 <a href="/ko/nodejs/api/events#class-eventemitter">이벤트 이미터 기반</a> API에 가장 일반적이며, 이러한 API는 시간 경과에 따른 일련의 비동기 작업(성공 또는 실패할 수 있는 단일 작업과 반대)을 나타냅니다.</p><p><em>모든</em> <a href="/ko/nodejs/api/events#class-eventemitter"><code>EventEmitter</code></a> 객체의 경우 <code>&#39;error&#39;</code> 이벤트 처리기가 제공되지 않으면 오류가 발생하여 Node.js 프로세스가 처리되지 않은 예외를 보고하고 충돌합니다. 단, <a href="/ko/nodejs/api/process#event-uncaughtexception"><code>&#39;uncaughtException&#39;</code></a> 이벤트에 대한 처리기가 등록되었거나 더 이상 사용되지 않는 <a href="/ko/nodejs/api/domain"><code>node:domain</code></a> 모듈이 사용된 경우는 예외입니다.</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> EventEmitter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;node:events&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ee</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EventEmitter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setImmediate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // &#39;error&#39; 이벤트 처리기가 추가되지 않았기 때문에 이 프로세스가 충돌합니다.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ee.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;error&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;This will crash&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>이러한 방식으로 생성된 오류는 호출 코드가 이미 종료된 <em>후에</em> 발생하므로 <code>try…catch</code>를 사용하여 가로챌 수 <em>없습니다</em>.</p><p>개발자는 각 메서드의 문서를 참조하여 해당 메서드에서 발생하는 오류가 정확히 어떻게 전파되는지 확인해야 합니다.</p><h2 id="class-error" tabindex="-1">클래스: <code>Error</code> <a class="header-anchor" href="#class-error" aria-label="Permalink to “클래스: Error”">​</a></h2><p>일반적인 JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" target="_blank" rel="noreferrer">&lt;Error&gt;</a> 객체로, 오류가 발생한 특정 상황을 나타내지 않습니다. <code>Error</code> 객체는 <code>Error</code>가 인스턴스화된 코드의 지점을 자세히 설명하는 &quot;스택 추적&quot;을 캡처하고 오류에 대한 텍스트 설명을 제공할 수 있습니다.</p><p>모든 시스템 및 JavaScript 오류를 포함하여 Node.js에서 생성된 모든 오류는 <code>Error</code> 클래스의 인스턴스이거나 상속됩니다.</p><h3 id="new-errormessage-options" tabindex="-1"><code>new Error(message[, options])</code> <a class="header-anchor" href="#new-errormessage-options" aria-label="Permalink to “new Error(message[, options])”">​</a></h3><ul><li><code>message</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a></li><li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a><ul><li><code>cause</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" target="_blank" rel="noreferrer">&lt;any&gt;</a> 새로 생성된 오류를 발생시킨 오류입니다.</li></ul></li></ul><p>새로운 <code>Error</code> 객체를 생성하고 <code>error.message</code> 속성을 제공된 텍스트 메시지로 설정합니다. 객체가 <code>message</code>로 전달되면 텍스트 메시지는 <code>String(message)</code>를 호출하여 생성됩니다. <code>cause</code> 옵션이 제공되면 <code>error.cause</code> 속성에 할당됩니다. <code>error.stack</code> 속성은 <code>new Error()</code>가 호출된 코드의 지점을 나타냅니다. 스택 추적은 <a href="https://v8.dev/docs/stack-trace-api" target="_blank" rel="noreferrer">V8의 스택 추적 API</a>에 따라 다릅니다. 스택 추적은 (a) <em>동기 코드 실행</em>의 시작 또는 (b) <code>Error.stackTraceLimit</code> 속성에 의해 제공되는 프레임 수 중 더 작은 값까지만 확장됩니다.</p><h3 id="errorcapturestacktracetargetobject-constructoropt" tabindex="-1"><code>Error.captureStackTrace(targetObject[, constructorOpt])</code> <a class="header-anchor" href="#errorcapturestacktracetargetobject-constructoropt" aria-label="Permalink to “Error.captureStackTrace(targetObject[, constructorOpt])”">​</a></h3><ul><li><code>targetObject</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a></li><li><code>constructorOpt</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noreferrer">&lt;Function&gt;</a></li></ul><p><code>targetObject</code>에 <code>.stack</code> 속성을 생성합니다. 이 속성에 접근하면 <code>Error.captureStackTrace()</code>가 호출된 코드의 위치를 나타내는 문자열을 반환합니다.</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Error.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">captureStackTrace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myObject);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myObject.stack;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// \`new Error().stack\`과 유사합니다.</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>추적의 첫 번째 줄은 <code>\${myObject.name}: \${myObject.message}</code>로 시작합니다.</p><p>선택적 <code>constructorOpt</code> 인수는 함수를 허용합니다. 주어진 경우 <code>constructorOpt</code>를 포함하여 <code>constructorOpt</code> 위의 모든 프레임이 생성된 스택 추적에서 생략됩니다.</p><p><code>constructorOpt</code> 인수는 오류 생성의 구현 세부 정보를 사용자로부터 숨기는 데 유용합니다. 예를 들면 다음과 같습니다.</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 스택 추적을 두 번 계산하는 것을 피하기 위해 스택 추적 없이 오류를 생성합니다.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">stackTraceLimit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Error;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Error.stackTraceLimit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> error</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Error.stackTraceLimit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stackTraceLimit;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 함수 b 위의 스택 추적을 캡처합니다.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Error.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">captureStackTrace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(error, b); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 함수 c와 b 모두 스택 추적에 포함되지 않습니다.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  throw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> error;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h3 id="errorstacktracelimit" tabindex="-1"><code>Error.stackTraceLimit</code> <a class="header-anchor" href="#errorstacktracelimit" aria-label="Permalink to “Error.stackTraceLimit”">​</a></h3><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" target="_blank" rel="noreferrer">&lt;number&gt;</a></li></ul><p><code>Error.stackTraceLimit</code> 속성은 스택 추적에 의해 수집되는 스택 프레임 수를 지정합니다(<code>new Error().stack</code> 또는 <code>Error.captureStackTrace(obj)</code>로 생성된 경우).</p><p>기본값은 <code>10</code>이지만 유효한 JavaScript 숫자로 설정할 수 있습니다. 변경 사항은 값이 변경 <em>된 후</em> 캡처된 모든 스택 추적에 영향을 미칩니다.</p><p>숫자가 아닌 값으로 설정하거나 음수로 설정하면 스택 추적이 프레임을 캡처하지 않습니다.</p><h3 id="errorcause" tabindex="-1"><code>error.cause</code> <a class="header-anchor" href="#errorcause" aria-label="Permalink to “error.cause”">​</a></h3><p><strong>다음 버전에서 추가됨: v16.9.0</strong></p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" target="_blank" rel="noreferrer">&lt;any&gt;</a></li></ul><p>있는 경우 <code>error.cause</code> 속성은 <code>Error</code>의 기본 원인입니다. 오류를 catch하고 원래 오류에 계속 액세스하기 위해 다른 메시지나 코드로 새 오류를 throw할 때 사용됩니다.</p><p><code>error.cause</code> 속성은 일반적으로 <code>new Error(message, { cause })</code>를 호출하여 설정됩니다. <code>cause</code> 옵션이 제공되지 않으면 생성자에 의해 설정되지 않습니다.</p><p>이 속성을 사용하면 오류를 연결할 수 있습니다. <code>Error</code> 객체를 직렬화할 때 <a href="/ko/nodejs/api/util#utilinspectobject-options"><code>util.inspect()</code></a>는 <code>error.cause</code>가 설정된 경우 재귀적으로 직렬화합니다.</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cause</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;The remote HTTP server responded with a 500 status&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> symptom</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;The message failed to send&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { cause });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symptom);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Prints:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//   Error: The message failed to send</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//       at REPL2:1:17</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//       at Script.runInThisContext (node:vm:130:12)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//       ... 7 lines matching cause stack trace ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//       at [_line] [as _line] (node:internal/readline/interface:886:18) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//     [cause]: Error: The remote HTTP server responded with a 500 status</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//         at REPL1:1:15</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//         at Script.runInThisContext (node:vm:130:12)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//         at REPLServer.defaultEval (node:repl:574:29)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//         at bound (node:domain:426:15)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//         at REPLServer.runBound [as eval] (node:domain:437:12)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//         at REPLServer.onLine (node:repl:902:10)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//         at REPLServer.emit (node:events:549:35)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//         at REPLServer.emit (node:domain:482:12)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//         at [_onLine] [as _onLine] (node:internal/readline/interface:425:12)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//         at [_line] [as _line] (node:internal/readline/interface:886:18)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h3 id="errorcode" tabindex="-1"><code>error.code</code> <a class="header-anchor" href="#errorcode" aria-label="Permalink to “error.code”">​</a></h3><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a></li></ul><p><code>error.code</code> 속성은 오류 종류를 식별하는 문자열 레이블입니다. <code>error.code</code>는 오류를 식별하는 가장 안정적인 방법입니다. Node.js의 주요 버전 간에만 변경됩니다. 반대로 <code>error.message</code> 문자열은 Node.js의 모든 버전 간에 변경될 수 있습니다. 특정 코드에 대한 자세한 내용은 <a href="/ko/nodejs/api/errors#nodejs-error-codes">Node.js 오류 코드</a>를 참조하세요.</p><h3 id="errormessage" tabindex="-1"><code>error.message</code> <a class="header-anchor" href="#errormessage" aria-label="Permalink to “error.message”">​</a></h3><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a></li></ul><p><code>error.message</code> 속성은 <code>new Error(message)</code>를 호출하여 설정된 오류에 대한 문자열 설명입니다. 생성자에 전달된 <code>message</code>는 <code>Error</code>의 스택 추적의 첫 번째 줄에도 나타나지만 <code>Error</code> 객체가 생성된 후 이 속성을 변경하면 스택 추적의 첫 번째 줄이 변경되지 <em>않을 수 있습니다</em> (예: 이 속성이 변경되기 전에 <code>error.stack</code>을 읽는 경우).</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> err</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;메시지&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(err.message);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 출력: 메시지</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="errorstack" tabindex="-1"><code>error.stack</code> <a class="header-anchor" href="#errorstack" aria-label="Permalink to “error.stack”">​</a></h3><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a></li></ul><p><code>error.stack</code> 속성은 <code>Error</code>가 인스턴스화된 코드의 지점을 설명하는 문자열입니다.</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Error:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 계속</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 일이</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 발생합니다!</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   at</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /home/gbusey/file.js:525:2</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   at</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Frobnicator.refrobulate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (/home/gbusey/business-logic.js:424:21)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   at</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Actor.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">anonymou</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (/home/gbusey/actors.js:400:8)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   at</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> increaseSynergy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (/home/gbusey/actors.js:701:6)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>첫 번째 줄은 <code>\\&lt;오류 클래스 이름\\&gt;: \\&lt;오류 메시지\\&gt;</code>로 형식이 지정되고, 그 뒤에 일련의 스택 프레임(&quot;at &quot;으로 시작하는 각 줄)이 이어집니다. 각 프레임은 오류가 생성된 코드를 이끈 호출 사이트를 설명합니다. V8은 각 함수에 대한 이름(변수 이름, 함수 이름 또는 객체 메서드 이름별)을 표시하려고 시도하지만 적절한 이름을 찾을 수 없는 경우가 있습니다. V8이 함수의 이름을 결정할 수 없는 경우 해당 프레임에 대한 위치 정보만 표시됩니다. 그렇지 않으면 결정된 함수 이름이 괄호 안에 위치 정보와 함께 표시됩니다.</p><p>프레임은 JavaScript 함수에 대해서만 생성됩니다. 예를 들어, 실행이 C++ 애드온 함수인 <code>cheetahify</code>를 통해 동기적으로 전달되고 이 함수 자체가 JavaScript 함수를 호출하는 경우 <code>cheetahify</code> 호출을 나타내는 프레임은 스택 추적에 존재하지 않습니다.</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cheetahify</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./native-binding.node&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> makeFaster</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // \`cheetahify()\`는 speedy를 *동기적으로* 호출합니다.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  cheetahify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> speedy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;어 이런!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">makeFaster</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// throw됩니다.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//   /home/gbusey/file.js:6</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//       throw new Error(&#39;어 이런!&#39;);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//           ^</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//   Error: 어 이런!</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//       at speedy (/home/gbusey/file.js:6:11)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//       at makeFaster (/home/gbusey/file.js:5:3)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//       at Object.&lt;anonymous&gt; (/home/gbusey/file.js:10:1)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//       at Module._compile (module.js:456:26)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//       at Object.Module._extensions..js (module.js:474:10)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//       at Module.load (module.js:356:32)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//       at Function.Module._load (module.js:312:12)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//       at Function.Module.runMain (module.js:497:10)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//       at startup (node.js:119:16)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//       at node.js:906:3</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>위치 정보는 다음 중 하나입니다.</p><ul><li>프레임이 V8 내부의 호출을 나타내는 경우 <code>native</code> (예: <code>[].forEach</code>).</li><li>프레임이 Node.js 내부의 호출을 나타내는 경우 <code>plain-filename.js:line:column</code>.</li><li>프레임이 사용자 프로그램(CommonJS 모듈 시스템 사용) 또는 해당 종속성의 호출을 나타내는 경우 <code>/absolute/path/to/file.js:line:column</code>.</li><li>프레임이 사용자 프로그램(ES 모듈 시스템 사용) 또는 해당 종속성의 호출을 나타내는 경우 <code>\\&lt;transport-protocol\\&gt;:///url/to/module/file.mjs:line:column</code>.</li></ul><p>스택 추적을 나타내는 문자열은 <code>error.stack</code> 속성에 <strong>액세스</strong>할 때 지연 생성됩니다.</p><p>스택 추적에서 캡처한 프레임 수는 <code>Error.stackTraceLimit</code> 또는 현재 이벤트 루프 틱에서 사용할 수 있는 프레임 수 중 더 작은 값으로 제한됩니다.</p><h2 id="class-assertionerror" tabindex="-1">클래스: <code>AssertionError</code> <a class="header-anchor" href="#class-assertionerror" aria-label="Permalink to “클래스: AssertionError”">​</a></h2><ul><li>확장: <a href="/ko/nodejs/api/errors#class-error">&lt;errors.Error&gt;</a></li></ul><p>어설션 실패를 나타냅니다. 자세한 내용은 <a href="/ko/nodejs/api/assert#class-assertassertionerror"><code>클래스: assert.AssertionError</code></a>를 참조하십시오.</p><h2 id="class-rangeerror" tabindex="-1">클래스: <code>RangeError</code> <a class="header-anchor" href="#class-rangeerror" aria-label="Permalink to “클래스: RangeError”">​</a></h2><ul><li>확장: <a href="/ko/nodejs/api/errors#class-error">&lt;errors.Error&gt;</a></li></ul><p>제공된 인수가 함수에 허용되는 값의 집합 또는 범위 내에 있지 않음을 나타냅니다. 이는 숫자 범위이거나 지정된 함수 매개변수에 대한 옵션 집합 외부인지 여부입니다.</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;node:net&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;RangeError: &quot;port&quot; 옵션은 &gt;= 0 및 &lt; 65536이어야 합니다: -1&quot; 오류 발생</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Node.js는 인수 유효성 검사의 한 형태로 <code>RangeError</code> 인스턴스를 <em>즉시</em> 생성하고 발생시킵니다.</p><h2 id="class-referenceerror" tabindex="-1">클래스: <code>ReferenceError</code> <a class="header-anchor" href="#class-referenceerror" aria-label="Permalink to “클래스: ReferenceError”">​</a></h2><ul><li>확장: <a href="/ko/nodejs/api/errors#class-error">&lt;errors.Error&gt;</a></li></ul><p>정의되지 않은 변수에 접근하려는 시도가 있음을 나타냅니다. 이러한 오류는 일반적으로 코드의 오타 또는 다른 방법으로 손상된 프로그램을 나타냅니다.</p><p>클라이언트 코드가 이러한 오류를 생성하고 전파할 수 있지만 실제로는 V8만 그렇게 합니다.</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">doesNotExist;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ReferenceError 발생, doesNotExist는 이 프로그램의 변수가 아닙니다.</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>애플리케이션이 코드를 동적으로 생성하고 실행하지 않는 한 <code>ReferenceError</code> 인스턴스는 코드 또는 종속성의 버그를 나타냅니다.</p><h2 id="class-syntaxerror" tabindex="-1">클래스: <code>SyntaxError</code> <a class="header-anchor" href="#class-syntaxerror" aria-label="Permalink to “클래스: SyntaxError”">​</a></h2><ul><li>확장: <a href="/ko/nodejs/api/errors#class-error">&lt;errors.Error&gt;</a></li></ul><p>프로그램이 유효한 JavaScript가 아님을 나타냅니다. 이러한 오류는 코드 평가의 결과로만 생성되고 전파될 수 있습니다. 코드 평가는 <code>eval</code>, <code>Function</code>, <code>require</code> 또는 <a href="/ko/nodejs/api/vm">vm</a>의 결과로 발생할 수 있습니다. 이러한 오류는 거의 항상 손상된 프로그램을 나타냅니다.</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;node:vm&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">runInThisContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;binary ! isNotOk&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (err) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // &#39;err&#39;는 SyntaxError가 됩니다.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>SyntaxError</code> 인스턴스는 이를 생성한 컨텍스트에서 복구할 수 없습니다. 다른 컨텍스트에서만 catch할 수 있습니다.</p><h2 id="class-systemerror" tabindex="-1">클래스: <code>SystemError</code> <a class="header-anchor" href="#class-systemerror" aria-label="Permalink to “클래스: SystemError”">​</a></h2><ul><li>확장: <a href="/ko/nodejs/api/errors#class-error">&lt;errors.Error&gt;</a></li></ul><p>Node.js는 런타임 환경 내에서 예외가 발생할 때 시스템 오류를 생성합니다. 이는 일반적으로 애플리케이션이 운영 체제 제약 조건을 위반할 때 발생합니다. 예를 들어 애플리케이션이 존재하지 않는 파일을 읽으려고 하면 시스템 오류가 발생합니다.</p><ul><li><code>address</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 존재하는 경우 네트워크 연결에 실패한 주소</li><li><code>code</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 문자열 오류 코드</li><li><code>dest</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 존재하는 경우 파일 시스템 오류를 보고할 때의 파일 경로 대상</li><li><code>errno</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" target="_blank" rel="noreferrer">&lt;number&gt;</a> 시스템에서 제공하는 오류 번호</li><li><code>info</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a> 존재하는 경우 오류 조건에 대한 추가 세부 정보</li><li><code>message</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 시스템에서 제공하는 사람이 읽을 수 있는 오류 설명</li><li><code>path</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 존재하는 경우 파일 시스템 오류를 보고할 때의 파일 경로</li><li><code>port</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" target="_blank" rel="noreferrer">&lt;number&gt;</a> 존재하는 경우 사용할 수 없는 네트워크 연결 포트</li><li><code>syscall</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> 오류를 트리거한 시스템 호출의 이름</li></ul><h3 id="erroraddress" tabindex="-1"><code>error.address</code> <a class="header-anchor" href="#erroraddress" aria-label="Permalink to “error.address”">​</a></h3><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a></li></ul><p>있는 경우, <code>error.address</code>는 네트워크 연결에 실패한 주소를 설명하는 문자열입니다.</p><h3 id="errorcode_1" tabindex="-1"><code>error.code</code> <a class="header-anchor" href="#errorcode_1" aria-label="Permalink to “error.code”">​</a></h3><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a></li></ul><p><code>error.code</code> 속성은 오류 코드를 나타내는 문자열입니다.</p><h3 id="errordest" tabindex="-1"><code>error.dest</code> <a class="header-anchor" href="#errordest" aria-label="Permalink to “error.dest”">​</a></h3><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a></li></ul><p>있는 경우, <code>error.dest</code>는 파일 시스템 오류를 보고할 때의 파일 경로 대상입니다.</p><h3 id="errorerrno" tabindex="-1"><code>error.errno</code> <a class="header-anchor" href="#errorerrno" aria-label="Permalink to “error.errno”">​</a></h3><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" target="_blank" rel="noreferrer">&lt;number&gt;</a></li></ul><p><code>error.errno</code> 속성은 <a href="https://docs.libuv.org/en/v1.x/errors" target="_blank" rel="noreferrer"><code>libuv 오류 처리</code></a>에 정의된 오류 코드에 해당하는 음수입니다.</p><p>Windows에서는 시스템에서 제공하는 오류 번호가 libuv에 의해 정규화됩니다.</p><p>오류 코드의 문자열 표현을 얻으려면 <a href="/ko/nodejs/api/util#utilgetsystemerrornameerr"><code>util.getSystemErrorName(error.errno)</code></a>를 사용하십시오.</p><h3 id="errorinfo" tabindex="-1"><code>error.info</code> <a class="header-anchor" href="#errorinfo" aria-label="Permalink to “error.info”">​</a></h3><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a></li></ul><p>있는 경우, <code>error.info</code>는 오류 조건에 대한 세부 정보가 있는 객체입니다.</p><h3 id="errormessage_1" tabindex="-1"><code>error.message</code> <a class="header-anchor" href="#errormessage_1" aria-label="Permalink to “error.message”">​</a></h3><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a></li></ul><p><code>error.message</code>는 시스템에서 제공하는 사람이 읽을 수 있는 오류 설명입니다.</p><h3 id="errorpath" tabindex="-1"><code>error.path</code> <a class="header-anchor" href="#errorpath" aria-label="Permalink to “error.path”">​</a></h3><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a></li></ul><p>있는 경우, <code>error.path</code>는 관련 없는 잘못된 경로 이름을 포함하는 문자열입니다.</p><h3 id="errorport" tabindex="-1"><code>error.port</code> <a class="header-anchor" href="#errorport" aria-label="Permalink to “error.port”">​</a></h3><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" target="_blank" rel="noreferrer">&lt;number&gt;</a></li></ul><p>있는 경우, <code>error.port</code>는 사용할 수 없는 네트워크 연결 포트입니다.</p><h3 id="errorsyscall" tabindex="-1"><code>error.syscall</code> <a class="header-anchor" href="#errorsyscall" aria-label="Permalink to “error.syscall”">​</a></h3><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a></li></ul><p><code>error.syscall</code> 속성은 실패한 <a href="https://man7.org/linux/man-pages/man2/syscalls.2" target="_blank" rel="noreferrer">syscall</a>을 설명하는 문자열입니다.</p><h3 id="common-system-errors" tabindex="-1">일반적인 시스템 오류 <a class="header-anchor" href="#common-system-errors" aria-label="Permalink to “일반적인 시스템 오류”">​</a></h3><p>다음은 Node.js 프로그램을 작성할 때 흔히 발생하는 시스템 오류 목록입니다. 전체 목록은 <a href="https://man7.org/linux/man-pages/man3/errno.3" target="_blank" rel="noreferrer"><code>errno(3) man page</code></a>를 참조하십시오.</p><ul><li><code>EACCES</code> (Permission denied): 파일 액세스 권한에 의해 금지된 방식으로 파일에 액세스하려고 시도했습니다.</li><li><code>EADDRINUSE</code> (Address already in use): 로컬 시스템의 다른 서버가 이미 해당 주소를 사용하고 있기 때문에 서버(<a href="/ko/nodejs/api/net"><code>net</code></a>, <a href="/ko/nodejs/api/http"><code>http</code></a> 또는 <a href="/ko/nodejs/api/https"><code>https</code></a>)를 로컬 주소에 바인딩하지 못했습니다.</li><li><code>ECONNREFUSED</code> (Connection refused): 대상 시스템이 활발하게 거부했기 때문에 연결할 수 없습니다. 일반적으로 외부 호스트에서 비활성 상태인 서비스에 연결하려고 시도한 결과입니다.</li><li><code>ECONNRESET</code> (Connection reset by peer): 피어가 강제로 연결을 닫았습니다. 일반적으로 시간 초과 또는 재부팅으로 인해 원격 소켓에서 연결이 끊어진 결과입니다. <a href="/ko/nodejs/api/http"><code>http</code></a> 및 <a href="/ko/nodejs/api/net"><code>net</code></a> 모듈을 통해 흔히 발생합니다.</li><li><code>EEXIST</code> (File exists): 대상이 존재하지 않아야 하는 작업의 대상이 기존 파일이었습니다.</li><li><code>EISDIR</code> (Is a directory): 작업에서 파일을 예상했지만 주어진 경로 이름이 디렉터리였습니다.</li><li><code>EMFILE</code> (Too many open files in system): 시스템에서 허용 가능한 최대 <a href="https://en.wikipedia.org/wiki/File_descriptor" target="_blank" rel="noreferrer">파일 설명자</a> 수에 도달했으며, 하나 이상이 닫힐 때까지 다른 설명자 요청을 충족할 수 없습니다. 특히 프로세스에 대한 파일 설명자 제한이 낮은 시스템(특히 macOS)에서 동시에 여러 파일을 열 때 발생합니다. 낮은 제한을 해결하려면 Node.js 프로세스를 실행할 셸에서 <code>ulimit -n 2048</code>을 실행하십시오.</li><li><code>ENOENT</code> (No such file or directory): 지정된 경로 이름의 구성 요소가 존재하지 않음을 나타내기 위해 <a href="/ko/nodejs/api/fs"><code>fs</code></a> 작업에서 흔히 발생합니다. 주어진 경로로 엔터티(파일 또는 디렉터리)를 찾을 수 없습니다.</li><li><code>ENOTDIR</code> (Not a directory): 주어진 경로 이름의 구성 요소가 존재했지만 예상대로 디렉터리가 아니었습니다. 일반적으로 <a href="/ko/nodejs/api/fs#fsreaddirpath-options-callback"><code>fs.readdir</code></a>에서 발생합니다.</li><li><code>ENOTEMPTY</code> (Directory not empty): 항목이 있는 디렉터리가 빈 디렉터리가 필요한 작업(일반적으로 <a href="/ko/nodejs/api/fs#fsunlinkpath-callback"><code>fs.unlink</code></a>)의 대상이었습니다.</li><li><code>ENOTFOUND</code> (DNS lookup failed): <code>EAI_NODATA</code> 또는 <code>EAI_NONAME</code>의 DNS 실패를 나타냅니다. 이것은 표준 POSIX 오류가 아닙니다.</li><li><code>EPERM</code> (Operation not permitted): 권한 상승이 필요한 작업을 수행하려고 시도했습니다.</li><li><code>EPIPE</code> (Broken pipe): 데이터를 읽을 프로세스가 없는 파이프, 소켓 또는 FIFO에 쓰기 작업입니다. <a href="/ko/nodejs/api/net"><code>net</code></a> 및 <a href="/ko/nodejs/api/http"><code>http</code></a> 레이어에서 흔히 발생하며, 쓰기 작업이 수행되는 스트림의 원격 측면이 닫혔음을 나타냅니다.</li><li><code>ETIMEDOUT</code> (Operation timed out): 연결된 당사자가 일정 기간 후 적절하게 응답하지 않아 연결 또는 보내기 요청이 실패했습니다. 일반적으로 <a href="/ko/nodejs/api/http"><code>http</code></a> 또는 <a href="/ko/nodejs/api/net"><code>net</code></a>에서 발생합니다. 종종 <code>socket.end()</code>가 제대로 호출되지 않았다는 신호입니다.</li></ul><h2 id="class-typeerror" tabindex="-1">클래스: <code>TypeError</code> <a class="header-anchor" href="#class-typeerror" aria-label="Permalink to “클래스: TypeError”">​</a></h2><ul><li><a href="/ko/nodejs/api/errors#class-error">&lt;errors.Error&gt;</a>를 확장합니다.</li></ul><p>제공된 인수가 허용 가능한 유형이 아님을 나타냅니다. 예를 들어 문자열을 예상하는 매개변수에 함수를 전달하면 <code>TypeError</code>가 됩니다.</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;node:url&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { });</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 문자열을 예상했기 때문에 TypeError를 발생시킵니다.</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Node.js는 인수 유효성 검사의 한 형태로 <code>TypeError</code> 인스턴스를 <em>즉시</em> 생성하고 throw합니다.</p><h2 id="exceptions-vs-errors" tabindex="-1">예외와 오류 <a class="header-anchor" href="#exceptions-vs-errors" aria-label="Permalink to “예외와 오류”">​</a></h2><p>JavaScript 예외는 유효하지 않은 작업의 결과 또는 <code>throw</code> 문의 대상으로 throw되는 값입니다. 이러한 값이 <code>Error</code>의 인스턴스 또는 <code>Error</code>에서 상속된 클래스의 인스턴스일 필요는 없지만 Node.js 또는 JavaScript 런타임에서 throw되는 모든 예외는 <code>Error</code>의 인스턴스<em>입니다</em>.</p><p>일부 예외는 JavaScript 레이어에서 <em>복구할 수 없습니다</em>. 이러한 예외는 <em>항상</em> Node.js 프로세스를 충돌시킵니다. 예로는 C++ 레이어의 <code>assert()</code> 검사 또는 <code>abort()</code> 호출이 있습니다.</p><h2 id="openssl-errors" tabindex="-1">OpenSSL 오류 <a class="header-anchor" href="#openssl-errors" aria-label="Permalink to “OpenSSL 오류”">​</a></h2><p><code>crypto</code> 또는 <code>tls</code>에서 발생하는 오류는 <code>Error</code> 클래스에 속하며 표준 <code>.code</code> 및 <code>.message</code> 속성 외에도 일부 추가 OpenSSL 관련 속성을 가질 수 있습니다.</p><h3 id="erroropensslerrorstack" tabindex="-1"><code>error.opensslErrorStack</code> <a class="header-anchor" href="#erroropensslerrorstack" aria-label="Permalink to “error.opensslErrorStack”">​</a></h3><p>오류가 OpenSSL 라이브러리의 어디에서 발생하는지에 대한 컨텍스트를 제공할 수 있는 오류 배열입니다.</p><h3 id="errorfunction" tabindex="-1"><code>error.function</code> <a class="header-anchor" href="#errorfunction" aria-label="Permalink to “error.function”">​</a></h3><p>오류가 발생하는 OpenSSL 함수입니다.</p><h3 id="errorlibrary" tabindex="-1"><code>error.library</code> <a class="header-anchor" href="#errorlibrary" aria-label="Permalink to “error.library”">​</a></h3><p>오류가 발생하는 OpenSSL 라이브러리입니다.</p><h3 id="errorreason" tabindex="-1"><code>error.reason</code> <a class="header-anchor" href="#errorreason" aria-label="Permalink to “error.reason”">​</a></h3><p>오류의 원인을 설명하는 사람이 읽을 수 있는 문자열입니다.</p><h2 id="nodejs-error-codes" tabindex="-1">Node.js 오류 코드 <a class="header-anchor" href="#nodejs-error-codes" aria-label="Permalink to “Node.js 오류 코드”">​</a></h2><h3 id="abort_err" tabindex="-1"><code>ABORT_ERR</code> <a class="header-anchor" href="#abort_err" aria-label="Permalink to “ABORT_ERR”">​</a></h3><p><strong>추가됨: v15.0.0</strong></p><p>작업이 중단되었을 때 사용됩니다(일반적으로 <code>AbortController</code> 사용).</p><p><code>AbortSignal</code>을 사용<em>하지 않는</em> API는 일반적으로 이 코드로 오류를 발생시키지 않습니다.</p><p>이 코드는 웹 플랫폼의 <code>AbortError</code>와의 호환성을 위해 Node.js 오류가 사용하는 일반적인 <code>ERR_*</code> 규칙을 사용하지 않습니다.</p><h3 id="err_access_denied" tabindex="-1"><code>ERR_ACCESS_DENIED</code> <a class="header-anchor" href="#err_access_denied" aria-label="Permalink to “ERR_ACCESS_DENIED”">​</a></h3><p>Node.js가 <a href="/ko/nodejs/api/permissions#permission-model">권한 모델</a>에 의해 제한된 리소스에 액세스하려고 할 때마다 트리거되는 특별한 유형의 오류입니다.</p><h3 id="err_ambiguous_argument" tabindex="-1"><code>ERR_AMBIGUOUS_ARGUMENT</code> <a class="header-anchor" href="#err_ambiguous_argument" aria-label="Permalink to “ERR_AMBIGUOUS_ARGUMENT”">​</a></h3><p>함수 시그니처를 오해할 수 있다는 것을 암시하는 방식으로 함수 인수가 사용되고 있습니다. 이는 <code>assert.throws(block, message)</code>의 <code>message</code> 매개변수가 <code>block</code>에서 던져진 오류 메시지와 일치할 때 <code>node:assert</code> 모듈에서 발생합니다. 왜냐하면 해당 사용법은 사용자가 <code>message</code>를 <code>block</code>이 던지지 않을 경우 <code>AssertionError</code>가 표시할 메시지 대신 예상되는 메시지라고 믿는다는 것을 암시하기 때문입니다.</p><h3 id="err_arg_not_iterable" tabindex="-1"><code>ERR_ARG_NOT_ITERABLE</code> <a class="header-anchor" href="#err_arg_not_iterable" aria-label="Permalink to “ERR_ARG_NOT_ITERABLE”">​</a></h3><p>반복 가능한 인수(<code>for...of</code> 루프에서 작동하는 값)가 필요했지만 Node.js API에 제공되지 않았습니다.</p><h3 id="err_assertion" tabindex="-1"><code>ERR_ASSERTION</code> <a class="header-anchor" href="#err_assertion" aria-label="Permalink to “ERR_ASSERTION”">​</a></h3><p>Node.js가 발생해서는 안 되는 예외적인 논리 위반을 감지할 때마다 트리거될 수 있는 특별한 유형의 오류입니다. 이는 일반적으로 <code>node:assert</code> 모듈에 의해 발생합니다.</p><h3 id="err_async_callback" tabindex="-1"><code>ERR_ASYNC_CALLBACK</code> <a class="header-anchor" href="#err_async_callback" aria-label="Permalink to “ERR_ASYNC_CALLBACK”">​</a></h3><p>함수가 아닌 것을 <code>AsyncHooks</code> 콜백으로 등록하려는 시도가 있었습니다.</p><h3 id="err_async_type" tabindex="-1"><code>ERR_ASYNC_TYPE</code> <a class="header-anchor" href="#err_async_type" aria-label="Permalink to “ERR_ASYNC_TYPE”">​</a></h3><p>비동기 리소스의 유형이 유효하지 않았습니다. 사용자는 공개 임베더 API를 사용하는 경우 자체 유형을 정의할 수도 있습니다.</p><h3 id="err_brotli_compression_failed" tabindex="-1"><code>ERR_BROTLI_COMPRESSION_FAILED</code> <a class="header-anchor" href="#err_brotli_compression_failed" aria-label="Permalink to “ERR_BROTLI_COMPRESSION_FAILED”">​</a></h3><p>Brotli 스트림으로 전달된 데이터가 성공적으로 압축되지 않았습니다.</p><h3 id="err_brotli_invalid_param" tabindex="-1"><code>ERR_BROTLI_INVALID_PARAM</code> <a class="header-anchor" href="#err_brotli_invalid_param" aria-label="Permalink to “ERR_BROTLI_INVALID_PARAM”">​</a></h3><p>Brotli 스트림을 구성하는 동안 잘못된 매개변수 키가 전달되었습니다.</p><h3 id="err_buffer_context_not_available" tabindex="-1"><code>ERR_BUFFER_CONTEXT_NOT_AVAILABLE</code> <a class="header-anchor" href="#err_buffer_context_not_available" aria-label="Permalink to “ERR_BUFFER_CONTEXT_NOT_AVAILABLE”">​</a></h3><p>Node.js 인스턴스와 연결되지 않은 JS 엔진 컨텍스트에 있는 동안 애드온 또는 임베더 코드에서 Node.js <code>Buffer</code> 인스턴스를 만들려고 시도했습니다. <code>Buffer</code> 메서드에 전달된 데이터는 메서드가 반환될 때 해제됩니다.</p><p>이 오류가 발생하면 <code>Buffer</code> 인스턴스를 만드는 대신 일반 <code>Uint8Array</code>를 만드는 것이 가능합니다. 이는 결과 객체의 프로토타입만 다릅니다. <code>Uint8Array</code>는 일반적으로 <code>Buffer</code>가 있는 모든 Node.js 코어 API에서 허용되며 모든 컨텍스트에서 사용할 수 있습니다.</p><h3 id="err_buffer_out_of_bounds" tabindex="-1"><code>ERR_BUFFER_OUT_OF_BOUNDS</code> <a class="header-anchor" href="#err_buffer_out_of_bounds" aria-label="Permalink to “ERR_BUFFER_OUT_OF_BOUNDS”">​</a></h3><p><code>Buffer</code>의 범위를 벗어난 작업이 시도되었습니다.</p><h3 id="err_buffer_too_large" tabindex="-1"><code>ERR_BUFFER_TOO_LARGE</code> <a class="header-anchor" href="#err_buffer_too_large" aria-label="Permalink to “ERR_BUFFER_TOO_LARGE”">​</a></h3><p>최대 허용 크기보다 큰 <code>Buffer</code>를 만들려고 시도했습니다.</p><h3 id="err_cannot_watch_sigint" tabindex="-1"><code>ERR_CANNOT_WATCH_SIGINT</code> <a class="header-anchor" href="#err_cannot_watch_sigint" aria-label="Permalink to “ERR_CANNOT_WATCH_SIGINT”">​</a></h3><p>Node.js가 <code>SIGINT</code> 신호를 감시할 수 없었습니다.</p><h3 id="err_child_closed_before_reply" tabindex="-1"><code>ERR_CHILD_CLOSED_BEFORE_REPLY</code> <a class="header-anchor" href="#err_child_closed_before_reply" aria-label="Permalink to “ERR_CHILD_CLOSED_BEFORE_REPLY”">​</a></h3><p>부모 프로세스가 응답을 받기 전에 자식 프로세스가 종료되었습니다.</p><h3 id="err_child_process_ipc_required" tabindex="-1"><code>ERR_CHILD_PROCESS_IPC_REQUIRED</code> <a class="header-anchor" href="#err_child_process_ipc_required" aria-label="Permalink to “ERR_CHILD_PROCESS_IPC_REQUIRED”">​</a></h3><p>IPC 채널을 지정하지 않고 자식 프로세스를 포크할 때 사용됩니다.</p><h3 id="err_child_process_stdio_maxbuffer" tabindex="-1"><code>ERR_CHILD_PROCESS_STDIO_MAXBUFFER</code> <a class="header-anchor" href="#err_child_process_stdio_maxbuffer" aria-label="Permalink to “ERR_CHILD_PROCESS_STDIO_MAXBUFFER”">​</a></h3><p>주 프로세스가 자식 프로세스의 STDERR/STDOUT에서 데이터를 읽으려고 할 때 데이터 길이가 <code>maxBuffer</code> 옵션보다 긴 경우 사용됩니다.</p><h3 id="err_closed_message_port" tabindex="-1"><code>ERR_CLOSED_MESSAGE_PORT</code> <a class="header-anchor" href="#err_closed_message_port" aria-label="Permalink to “ERR_CLOSED_MESSAGE_PORT”">​</a></h3><div class="info custom-block"><p class="custom-block-title">[기록]</p><table tabindex="0"><thead><tr><th>버전</th><th>변경 사항</th></tr></thead><tbody><tr><td>v16.2.0, v14.17.1</td><td>오류 메시지가 다시 도입되었습니다.</td></tr><tr><td>v11.12.0</td><td>오류 메시지가 제거되었습니다.</td></tr><tr><td>v10.5.0</td><td>추가됨: v10.5.0</td></tr></tbody></table></div><p>일반적으로 <code>.close()</code>가 호출된 후 닫힌 상태의 <code>MessagePort</code> 인스턴스를 사용하려는 시도가 있었습니다.</p><h3 id="err_console_writable_stream" tabindex="-1"><code>ERR_CONSOLE_WRITABLE_STREAM</code> <a class="header-anchor" href="#err_console_writable_stream" aria-label="Permalink to “ERR_CONSOLE_WRITABLE_STREAM”">​</a></h3><p><code>Console</code>이 <code>stdout</code> 스트림 없이 인스턴스화되었거나 <code>Console</code>에 쓰기 불가능한 <code>stdout</code> 또는 <code>stderr</code> 스트림이 있습니다.</p><h3 id="err_construct_call_invalid" tabindex="-1"><code>ERR_CONSTRUCT_CALL_INVALID</code> <a class="header-anchor" href="#err_construct_call_invalid" aria-label="Permalink to “ERR_CONSTRUCT_CALL_INVALID”">​</a></h3><p><strong>추가됨: v12.5.0</strong></p><p>호출할 수 없는 클래스 생성자가 호출되었습니다.</p><h3 id="err_construct_call_required" tabindex="-1"><code>ERR_CONSTRUCT_CALL_REQUIRED</code> <a class="header-anchor" href="#err_construct_call_required" aria-label="Permalink to “ERR_CONSTRUCT_CALL_REQUIRED”">​</a></h3><p>클래스에 대한 생성자가 <code>new</code> 없이 호출되었습니다.</p><h3 id="err_context_not_initialized" tabindex="-1"><code>ERR_CONTEXT_NOT_INITIALIZED</code> <a class="header-anchor" href="#err_context_not_initialized" aria-label="Permalink to “ERR_CONTEXT_NOT_INITIALIZED”">​</a></h3><p>API에 전달된 vm 컨텍스트가 아직 초기화되지 않았습니다. 이는 컨텍스트를 생성하는 동안 오류가 발생하고 (잡히는 경우) 발생할 수 있습니다. 예를 들어 컨텍스트를 생성할 때 할당에 실패하거나 최대 호출 스택 크기에 도달한 경우입니다.</p><h3 id="err_crypto_custom_engine_not_supported" tabindex="-1"><code>ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED</code> <a class="header-anchor" href="#err_crypto_custom_engine_not_supported" aria-label="Permalink to “ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED”">​</a></h3><p>사용 중인 OpenSSL 버전에 의해 지원되지 않는 OpenSSL 엔진이 요청되었습니다 (예: <code>clientCertEngine</code> 또는 <code>privateKeyEngine</code> TLS 옵션을 통해). 이는 컴파일 시간 플래그 <code>OPENSSL_NO_ENGINE</code> 때문일 가능성이 높습니다.</p><h3 id="err_crypto_ecdh_invalid_format" tabindex="-1"><code>ERR_CRYPTO_ECDH_INVALID_FORMAT</code> <a class="header-anchor" href="#err_crypto_ecdh_invalid_format" aria-label="Permalink to “ERR_CRYPTO_ECDH_INVALID_FORMAT”">​</a></h3><p><code>crypto.ECDH()</code> 클래스 <code>getPublicKey()</code> 메서드에 대한 <code>format</code> 인수에 잘못된 값이 전달되었습니다.</p><h3 id="err_crypto_ecdh_invalid_public_key" tabindex="-1"><code>ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY</code> <a class="header-anchor" href="#err_crypto_ecdh_invalid_public_key" aria-label="Permalink to “ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY”">​</a></h3><p><code>crypto.ECDH()</code> 클래스 <code>computeSecret()</code> 메서드에 대한 <code>key</code> 인수에 잘못된 값이 전달되었습니다. 이는 공개 키가 타원 곡선 외부에 있음을 의미합니다.</p><h3 id="err_crypto_engine_unknown" tabindex="-1"><code>ERR_CRYPTO_ENGINE_UNKNOWN</code> <a class="header-anchor" href="#err_crypto_engine_unknown" aria-label="Permalink to “ERR_CRYPTO_ENGINE_UNKNOWN”">​</a></h3><p>잘못된 암호화 엔진 식별자가 <a href="/ko/nodejs/api/crypto#cryptosetengineengine-flags"><code>require(&#39;node:crypto&#39;).setEngine()</code></a>에 전달되었습니다.</p><h3 id="err_crypto_fips_forced" tabindex="-1"><code>ERR_CRYPTO_FIPS_FORCED</code> <a class="header-anchor" href="#err_crypto_fips_forced" aria-label="Permalink to “ERR_CRYPTO_FIPS_FORCED”">​</a></h3><p><a href="/ko/nodejs/api/cli#force-fips"><code>--force-fips</code></a> 명령줄 인수가 사용되었지만 <code>node:crypto</code> 모듈에서 FIPS 모드를 활성화하거나 비활성화하려는 시도가 있었습니다.</p><h3 id="err_crypto_fips_unavailable" tabindex="-1"><code>ERR_CRYPTO_FIPS_UNAVAILABLE</code> <a class="header-anchor" href="#err_crypto_fips_unavailable" aria-label="Permalink to “ERR_CRYPTO_FIPS_UNAVAILABLE”">​</a></h3><p>FIPS 모드를 활성화하거나 비활성화하려는 시도가 있었지만 FIPS 모드를 사용할 수 없었습니다.</p><h3 id="err_crypto_hash_finalized" tabindex="-1"><code>ERR_CRYPTO_HASH_FINALIZED</code> <a class="header-anchor" href="#err_crypto_hash_finalized" aria-label="Permalink to “ERR_CRYPTO_HASH_FINALIZED”">​</a></h3><p><a href="/ko/nodejs/api/crypto#hashdigestencoding"><code>hash.digest()</code></a>가 여러 번 호출되었습니다. <code>hash.digest()</code> 메서드는 <code>Hash</code> 객체의 인스턴스당 한 번만 호출해야 합니다.</p><h3 id="err_crypto_hash_update_failed" tabindex="-1"><code>ERR_CRYPTO_HASH_UPDATE_FAILED</code> <a class="header-anchor" href="#err_crypto_hash_update_failed" aria-label="Permalink to “ERR_CRYPTO_HASH_UPDATE_FAILED”">​</a></h3><p><a href="/ko/nodejs/api/crypto#hashupdatedata-inputencoding"><code>hash.update()</code></a>가 어떤 이유로든 실패했습니다. 이는 거의 발생하지 않아야 합니다.</p><h3 id="err_crypto_incompatible_key" tabindex="-1"><code>ERR_CRYPTO_INCOMPATIBLE_KEY</code> <a class="header-anchor" href="#err_crypto_incompatible_key" aria-label="Permalink to “ERR_CRYPTO_INCOMPATIBLE_KEY”">​</a></h3><p>주어진 암호화 키가 시도된 작업과 호환되지 않습니다.</p><h3 id="err_crypto_incompatible_key_options" tabindex="-1"><code>ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS</code> <a class="header-anchor" href="#err_crypto_incompatible_key_options" aria-label="Permalink to “ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS”">​</a></h3><p>선택한 공개 키 또는 개인 키 인코딩이 다른 옵션과 호환되지 않습니다.</p><h3 id="err_crypto_initialization_failed" tabindex="-1"><code>ERR_CRYPTO_INITIALIZATION_FAILED</code> <a class="header-anchor" href="#err_crypto_initialization_failed" aria-label="Permalink to “ERR_CRYPTO_INITIALIZATION_FAILED”">​</a></h3><p><strong>추가된 버전: v15.0.0</strong></p><p>암호화 하위 시스템 초기화에 실패했습니다.</p><h3 id="err_crypto_invalid_auth_tag" tabindex="-1"><code>ERR_CRYPTO_INVALID_AUTH_TAG</code> <a class="header-anchor" href="#err_crypto_invalid_auth_tag" aria-label="Permalink to “ERR_CRYPTO_INVALID_AUTH_TAG”">​</a></h3><p><strong>추가된 버전: v15.0.0</strong></p><p>잘못된 인증 태그가 제공되었습니다.</p><h3 id="err_crypto_invalid_counter" tabindex="-1"><code>ERR_CRYPTO_INVALID_COUNTER</code> <a class="header-anchor" href="#err_crypto_invalid_counter" aria-label="Permalink to “ERR_CRYPTO_INVALID_COUNTER”">​</a></h3><p><strong>추가된 버전: v15.0.0</strong></p><p>카운터 모드 암호에 대해 잘못된 카운터가 제공되었습니다.</p><h3 id="err_crypto_invalid_curve" tabindex="-1"><code>ERR_CRYPTO_INVALID_CURVE</code> <a class="header-anchor" href="#err_crypto_invalid_curve" aria-label="Permalink to “ERR_CRYPTO_INVALID_CURVE”">​</a></h3><p><strong>추가된 버전: v15.0.0</strong></p><p>잘못된 타원 곡선이 제공되었습니다.</p><h3 id="err_crypto_invalid_digest" tabindex="-1"><code>ERR_CRYPTO_INVALID_DIGEST</code> <a class="header-anchor" href="#err_crypto_invalid_digest" aria-label="Permalink to “ERR_CRYPTO_INVALID_DIGEST”">​</a></h3><p>잘못된 <a href="/ko/nodejs/api/crypto#cryptogethashes">암호화 다이제스트 알고리즘</a>이 지정되었습니다.</p><h3 id="err_crypto_invalid_iv" tabindex="-1"><code>ERR_CRYPTO_INVALID_IV</code> <a class="header-anchor" href="#err_crypto_invalid_iv" aria-label="Permalink to “ERR_CRYPTO_INVALID_IV”">​</a></h3><p><strong>추가된 버전: v15.0.0</strong></p><p>잘못된 초기화 벡터가 제공되었습니다.</p><h3 id="err_crypto_invalid_jwk" tabindex="-1"><code>ERR_CRYPTO_INVALID_JWK</code> <a class="header-anchor" href="#err_crypto_invalid_jwk" aria-label="Permalink to “ERR_CRYPTO_INVALID_JWK”">​</a></h3><p><strong>추가된 버전: v15.0.0</strong></p><p>잘못된 JSON 웹 키가 제공되었습니다.</p><h3 id="err_crypto_invalid_keylen" tabindex="-1"><code>ERR_CRYPTO_INVALID_KEYLEN</code> <a class="header-anchor" href="#err_crypto_invalid_keylen" aria-label="Permalink to “ERR_CRYPTO_INVALID_KEYLEN”">​</a></h3><p><strong>추가된 버전: v15.0.0</strong></p><p>잘못된 키 길이가 제공되었습니다.</p><h3 id="err_crypto_invalid_keypair" tabindex="-1"><code>ERR_CRYPTO_INVALID_KEYPAIR</code> <a class="header-anchor" href="#err_crypto_invalid_keypair" aria-label="Permalink to “ERR_CRYPTO_INVALID_KEYPAIR”">​</a></h3><p><strong>추가된 버전: v15.0.0</strong></p><p>잘못된 키 쌍이 제공되었습니다.</p><h3 id="err_crypto_invalid_keytype" tabindex="-1"><code>ERR_CRYPTO_INVALID_KEYTYPE</code> <a class="header-anchor" href="#err_crypto_invalid_keytype" aria-label="Permalink to “ERR_CRYPTO_INVALID_KEYTYPE”">​</a></h3><p><strong>추가된 버전: v15.0.0</strong></p><p>잘못된 키 유형이 제공되었습니다.</p><h3 id="err_crypto_invalid_key_object_type" tabindex="-1"><code>ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE</code> <a class="header-anchor" href="#err_crypto_invalid_key_object_type" aria-label="Permalink to “ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE”">​</a></h3><p>제공된 암호 키 객체의 유형이 시도된 작업에 유효하지 않습니다.</p><h3 id="err_crypto_invalid_messagelen" tabindex="-1"><code>ERR_CRYPTO_INVALID_MESSAGELEN</code> <a class="header-anchor" href="#err_crypto_invalid_messagelen" aria-label="Permalink to “ERR_CRYPTO_INVALID_MESSAGELEN”">​</a></h3><p><strong>추가된 버전: v15.0.0</strong></p><p>유효하지 않은 메시지 길이가 제공되었습니다.</p><h3 id="err_crypto_invalid_scrypt_params" tabindex="-1"><code>ERR_CRYPTO_INVALID_SCRYPT_PARAMS</code> <a class="header-anchor" href="#err_crypto_invalid_scrypt_params" aria-label="Permalink to “ERR_CRYPTO_INVALID_SCRYPT_PARAMS”">​</a></h3><p><strong>추가된 버전: v15.0.0</strong></p><p>하나 이상의 <a href="/ko/nodejs/api/crypto#cryptoscryptpassword-salt-keylen-options-callback"><code>crypto.scrypt()</code></a> 또는 <a href="/ko/nodejs/api/crypto#cryptoscryptsyncpassword-salt-keylen-options"><code>crypto.scryptSync()</code></a> 매개변수가 해당 유효 범위 밖에 있습니다.</p><h3 id="err_crypto_invalid_state" tabindex="-1"><code>ERR_CRYPTO_INVALID_STATE</code> <a class="header-anchor" href="#err_crypto_invalid_state" aria-label="Permalink to “ERR_CRYPTO_INVALID_STATE”">​</a></h3><p>유효하지 않은 상태의 객체에 암호화 메서드가 사용되었습니다. 예를 들어 <code>cipher.final()</code>을 호출하기 전에 <a href="/ko/nodejs/api/crypto#ciphergetauthtag"><code>cipher.getAuthTag()</code></a>를 호출하는 경우입니다.</p><h3 id="err_crypto_invalid_tag_length" tabindex="-1"><code>ERR_CRYPTO_INVALID_TAG_LENGTH</code> <a class="header-anchor" href="#err_crypto_invalid_tag_length" aria-label="Permalink to “ERR_CRYPTO_INVALID_TAG_LENGTH”">​</a></h3><p><strong>추가된 버전: v15.0.0</strong></p><p>유효하지 않은 인증 태그 길이가 제공되었습니다.</p><h3 id="err_crypto_job_init_failed" tabindex="-1"><code>ERR_CRYPTO_JOB_INIT_FAILED</code> <a class="header-anchor" href="#err_crypto_job_init_failed" aria-label="Permalink to “ERR_CRYPTO_JOB_INIT_FAILED”">​</a></h3><p><strong>추가된 버전: v15.0.0</strong></p><p>비동기 암호화 작업의 초기화에 실패했습니다.</p><h3 id="err_crypto_jwk_unsupported_curve" tabindex="-1"><code>ERR_CRYPTO_JWK_UNSUPPORTED_CURVE</code> <a class="header-anchor" href="#err_crypto_jwk_unsupported_curve" aria-label="Permalink to “ERR_CRYPTO_JWK_UNSUPPORTED_CURVE”">​</a></h3><p>키의 타원 곡선이 <a href="https://www.iana.org/assignments/jose/jose.xhtml#web-key-elliptic-curve" target="_blank" rel="noreferrer">JSON Web Key Elliptic Curve Registry</a>에서 사용하도록 등록되지 않았습니다.</p><h3 id="err_crypto_jwk_unsupported_key_type" tabindex="-1"><code>ERR_CRYPTO_JWK_UNSUPPORTED_KEY_TYPE</code> <a class="header-anchor" href="#err_crypto_jwk_unsupported_key_type" aria-label="Permalink to “ERR_CRYPTO_JWK_UNSUPPORTED_KEY_TYPE”">​</a></h3><p>키의 비대칭 키 유형이 <a href="https://www.iana.org/assignments/jose/jose.xhtml#web-key-types" target="_blank" rel="noreferrer">JSON Web Key Types Registry</a>에서 사용하도록 등록되지 않았습니다.</p><h3 id="err_crypto_operation_failed" tabindex="-1"><code>ERR_CRYPTO_OPERATION_FAILED</code> <a class="header-anchor" href="#err_crypto_operation_failed" aria-label="Permalink to “ERR_CRYPTO_OPERATION_FAILED”">​</a></h3><p><strong>추가된 버전: v15.0.0</strong></p><p>암호화 작업이 지정되지 않은 이유로 실패했습니다.</p><h3 id="err_crypto_pbkdf2_error" tabindex="-1"><code>ERR_CRYPTO_PBKDF2_ERROR</code> <a class="header-anchor" href="#err_crypto_pbkdf2_error" aria-label="Permalink to “ERR_CRYPTO_PBKDF2_ERROR”">​</a></h3><p>지정되지 않은 이유로 PBKDF2 알고리즘이 실패했습니다. OpenSSL은 자세한 내용을 제공하지 않으므로 Node.js도 제공하지 않습니다.</p><h3 id="err_crypto_scrypt_not_supported" tabindex="-1"><code>ERR_CRYPTO_SCRYPT_NOT_SUPPORTED</code> <a class="header-anchor" href="#err_crypto_scrypt_not_supported" aria-label="Permalink to “ERR_CRYPTO_SCRYPT_NOT_SUPPORTED”">​</a></h3><p>Node.js가 <code>scrypt</code> 지원 없이 컴파일되었습니다. 공식 릴리스 바이너리에서는 불가능하지만 배포판 빌드를 포함한 사용자 정의 빌드에서는 발생할 수 있습니다.</p><h3 id="err_crypto_sign_key_required" tabindex="-1"><code>ERR_CRYPTO_SIGN_KEY_REQUIRED</code> <a class="header-anchor" href="#err_crypto_sign_key_required" aria-label="Permalink to “ERR_CRYPTO_SIGN_KEY_REQUIRED”">​</a></h3><p>서명 <code>key</code>가 <a href="/ko/nodejs/api/crypto#signsignprivatekey-outputencoding"><code>sign.sign()</code></a> 메서드에 제공되지 않았습니다.</p><h3 id="err_crypto_timing_safe_equal_length" tabindex="-1"><code>ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH</code> <a class="header-anchor" href="#err_crypto_timing_safe_equal_length" aria-label="Permalink to “ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH”">​</a></h3><p>서로 다른 길이의 <code>Buffer</code>, <code>TypedArray</code> 또는 <code>DataView</code> 인수로 <a href="/ko/nodejs/api/crypto#cryptotimingsafeequala-b"><code>crypto.timingSafeEqual()</code></a>이 호출되었습니다.</p><h3 id="err_crypto_unknown_cipher" tabindex="-1"><code>ERR_CRYPTO_UNKNOWN_CIPHER</code> <a class="header-anchor" href="#err_crypto_unknown_cipher" aria-label="Permalink to “ERR_CRYPTO_UNKNOWN_CIPHER”">​</a></h3><p>알 수 없는 암호가 지정되었습니다.</p><h3 id="err_crypto_unknown_dh_group" tabindex="-1"><code>ERR_CRYPTO_UNKNOWN_DH_GROUP</code> <a class="header-anchor" href="#err_crypto_unknown_dh_group" aria-label="Permalink to “ERR_CRYPTO_UNKNOWN_DH_GROUP”">​</a></h3><p>알 수 없는 Diffie-Hellman 그룹 이름이 지정되었습니다. 유효한 그룹 이름 목록은 <a href="/ko/nodejs/api/crypto#cryptogetdiffiehellmangroupname"><code>crypto.getDiffieHellman()</code></a>을 참조하십시오.</p><h3 id="err_crypto_unsupported_operation" tabindex="-1"><code>ERR_CRYPTO_UNSUPPORTED_OPERATION</code> <a class="header-anchor" href="#err_crypto_unsupported_operation" aria-label="Permalink to “ERR_CRYPTO_UNSUPPORTED_OPERATION”">​</a></h3><p><strong>추가된 버전: v15.0.0, v14.18.0</strong></p><p>지원되지 않는 암호화 작업을 호출하려는 시도가 있었습니다.</p><h3 id="err_debugger_error" tabindex="-1"><code>ERR_DEBUGGER_ERROR</code> <a class="header-anchor" href="#err_debugger_error" aria-label="Permalink to “ERR_DEBUGGER_ERROR”">​</a></h3><p><strong>추가된 버전: v16.4.0, v14.17.4</strong></p><p><a href="/ko/nodejs/api/debugger">디버거</a>에서 오류가 발생했습니다.</p><h3 id="err_debugger_startup_error" tabindex="-1"><code>ERR_DEBUGGER_STARTUP_ERROR</code> <a class="header-anchor" href="#err_debugger_startup_error" aria-label="Permalink to “ERR_DEBUGGER_STARTUP_ERROR”">​</a></h3><p><strong>추가된 버전: v16.4.0, v14.17.4</strong></p><p><a href="/ko/nodejs/api/debugger">디버거</a>가 필요한 호스트/포트가 사용 가능해질 때까지 기다리는 동안 시간 초과되었습니다.</p><h3 id="err_dir_closed" tabindex="-1"><code>ERR_DIR_CLOSED</code> <a class="header-anchor" href="#err_dir_closed" aria-label="Permalink to “ERR_DIR_CLOSED”">​</a></h3><p><a href="/ko/nodejs/api/fs#class-fsdir"><code>fs.Dir</code></a>가 이전에 닫혔습니다.</p><h3 id="err_dir_concurrent_operation" tabindex="-1"><code>ERR_DIR_CONCURRENT_OPERATION</code> <a class="header-anchor" href="#err_dir_concurrent_operation" aria-label="Permalink to “ERR_DIR_CONCURRENT_OPERATION”">​</a></h3><p><strong>추가된 버전: v14.3.0</strong></p><p>진행 중인 비동기 작업이 있는 <a href="/ko/nodejs/api/fs#class-fsdir"><code>fs.Dir</code></a>에서 동기 읽기 또는 닫기 호출이 시도되었습니다.</p><h3 id="err_dlopen_disabled" tabindex="-1"><code>ERR_DLOPEN_DISABLED</code> <a class="header-anchor" href="#err_dlopen_disabled" aria-label="Permalink to “ERR_DLOPEN_DISABLED”">​</a></h3><p><strong>추가된 버전: v16.10.0, v14.19.0</strong></p><p>네이티브 애드온 로딩이 <a href="/ko/nodejs/api/cli#no-addons"><code>--no-addons</code></a>를 사용하여 비활성화되었습니다.</p><h3 id="err_dlopen_failed" tabindex="-1"><code>ERR_DLOPEN_FAILED</code> <a class="header-anchor" href="#err_dlopen_failed" aria-label="Permalink to “ERR_DLOPEN_FAILED”">​</a></h3><p><strong>추가된 버전: v15.0.0</strong></p><p><code>process.dlopen()</code> 호출이 실패했습니다.</p><h3 id="err_dns_set_servers_failed" tabindex="-1"><code>ERR_DNS_SET_SERVERS_FAILED</code> <a class="header-anchor" href="#err_dns_set_servers_failed" aria-label="Permalink to “ERR_DNS_SET_SERVERS_FAILED”">​</a></h3><p><code>c-ares</code>가 DNS 서버를 설정하지 못했습니다.</p><h3 id="err_domain_callback_not_available" tabindex="-1"><code>ERR_DOMAIN_CALLBACK_NOT_AVAILABLE</code> <a class="header-anchor" href="#err_domain_callback_not_available" aria-label="Permalink to “ERR_DOMAIN_CALLBACK_NOT_AVAILABLE”">​</a></h3><p><code>node:domain</code> 모듈은 <a href="/ko/nodejs/api/process#processsetuncaughtexceptioncapturecallbackfn"><code>process.setUncaughtExceptionCaptureCallback()</code></a>이 이전 시점에 호출되었기 때문에 필요한 오류 처리 후크를 설정할 수 없어 사용할 수 없었습니다.</p><h3 id="err_domain_cannot_set_uncaught_exception_capture" tabindex="-1"><code>ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE</code> <a class="header-anchor" href="#err_domain_cannot_set_uncaught_exception_capture" aria-label="Permalink to “ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE”">​</a></h3><p><code>node:domain</code> 모듈이 이전 시점에 로드되었기 때문에 <a href="/ko/nodejs/api/process#processsetuncaughtexceptioncapturecallbackfn"><code>process.setUncaughtExceptionCaptureCallback()</code></a>을 호출할 수 없습니다.</p><p>스택 추적은 <code>node:domain</code> 모듈이 로드된 시점을 포함하도록 확장됩니다.</p><h3 id="err_duplicate_startup_snapshot_main_function" tabindex="-1"><code>ERR_DUPLICATE_STARTUP_SNAPSHOT_MAIN_FUNCTION</code> <a class="header-anchor" href="#err_duplicate_startup_snapshot_main_function" aria-label="Permalink to “ERR_DUPLICATE_STARTUP_SNAPSHOT_MAIN_FUNCTION”">​</a></h3><p><a href="/ko/nodejs/api/v8#v8startupsnapshotsetdeserializemainfunctioncallback-data"><code>v8.startupSnapshot.setDeserializeMainFunction()</code></a>은 이미 이전에 호출되었기 때문에 호출할 수 없습니다.</p><h3 id="err_encoding_invalid_encoded_data" tabindex="-1"><code>ERR_ENCODING_INVALID_ENCODED_DATA</code> <a class="header-anchor" href="#err_encoding_invalid_encoded_data" aria-label="Permalink to “ERR_ENCODING_INVALID_ENCODED_DATA”">​</a></h3><p><code>TextDecoder()</code> API에 제공된 데이터가 제공된 인코딩에 따라 유효하지 않습니다.</p><h3 id="err_encoding_not_supported" tabindex="-1"><code>ERR_ENCODING_NOT_SUPPORTED</code> <a class="header-anchor" href="#err_encoding_not_supported" aria-label="Permalink to “ERR_ENCODING_NOT_SUPPORTED”">​</a></h3><p><code>TextDecoder()</code> API에 제공된 인코딩이 <a href="/ko/nodejs/api/util#whatwg-supported-encodings">WHATWG 지원 인코딩</a> 중 하나가 아닙니다.</p><h3 id="err_eval_esm_cannot_print" tabindex="-1"><code>ERR_EVAL_ESM_CANNOT_PRINT</code> <a class="header-anchor" href="#err_eval_esm_cannot_print" aria-label="Permalink to “ERR_EVAL_ESM_CANNOT_PRINT”">​</a></h3><p><code>--print</code>는 ESM 입력과 함께 사용할 수 없습니다.</p><h3 id="err_event_recursion" tabindex="-1"><code>ERR_EVENT_RECURSION</code> <a class="header-anchor" href="#err_event_recursion" aria-label="Permalink to “ERR_EVENT_RECURSION”">​</a></h3><p><code>EventTarget</code>에서 이벤트를 재귀적으로 디스패치하려는 시도가 있을 때 발생합니다.</p><h3 id="err_execution_environment_not_available" tabindex="-1"><code>ERR_EXECUTION_ENVIRONMENT_NOT_AVAILABLE</code> <a class="header-anchor" href="#err_execution_environment_not_available" aria-label="Permalink to “ERR_EXECUTION_ENVIRONMENT_NOT_AVAILABLE”">​</a></h3><p>JS 실행 컨텍스트가 Node.js 환경과 연결되어 있지 않습니다. 이는 Node.js가 임베디드 라이브러리로 사용되고 JS 엔진에 대한 일부 후크가 제대로 설정되지 않은 경우에 발생할 수 있습니다.</p><h3 id="err_falsy_value_rejection" tabindex="-1"><code>ERR_FALSY_VALUE_REJECTION</code> <a class="header-anchor" href="#err_falsy_value_rejection" aria-label="Permalink to “ERR_FALSY_VALUE_REJECTION”">​</a></h3><p><code>util.callbackify()</code>를 통해 콜백화된 <code>Promise</code>가 거짓 값으로 거부되었습니다.</p><h3 id="err_feature_unavailable_on_platform" tabindex="-1"><code>ERR_FEATURE_UNAVAILABLE_ON_PLATFORM</code> <a class="header-anchor" href="#err_feature_unavailable_on_platform" aria-label="Permalink to “ERR_FEATURE_UNAVAILABLE_ON_PLATFORM”">​</a></h3><p><strong>추가된 버전: v14.0.0</strong></p><p>Node.js를 실행 중인 현재 플랫폼에서 사용할 수 없는 기능을 사용하는 경우에 사용됩니다.</p><h3 id="err_fs_cp_dir_to_non_dir" tabindex="-1"><code>ERR_FS_CP_DIR_TO_NON_DIR</code> <a class="header-anchor" href="#err_fs_cp_dir_to_non_dir" aria-label="Permalink to “ERR_FS_CP_DIR_TO_NON_DIR”">​</a></h3><p><strong>추가된 버전: v16.7.0</strong></p><p><a href="/ko/nodejs/api/fs#fscpsrc-dest-options-callback"><code>fs.cp()</code></a>를 사용하여 디렉토리를 비 디렉토리(파일, 심볼릭 링크 등)로 복사하려는 시도가 있었습니다.</p><h3 id="err_fs_cp_eexist" tabindex="-1"><code>ERR_FS_CP_EEXIST</code> <a class="header-anchor" href="#err_fs_cp_eexist" aria-label="Permalink to “ERR_FS_CP_EEXIST”">​</a></h3><p><strong>추가된 버전: v16.7.0</strong></p><p><code>force</code> 및 <code>errorOnExist</code>가 <code>true</code>로 설정된 상태에서 <a href="/ko/nodejs/api/fs#fscpsrc-dest-options-callback"><code>fs.cp()</code></a>를 사용하여 이미 존재하는 파일을 덮어쓰려고 했습니다.</p><h3 id="err_fs_cp_einval" tabindex="-1"><code>ERR_FS_CP_EINVAL</code> <a class="header-anchor" href="#err_fs_cp_einval" aria-label="Permalink to “ERR_FS_CP_EINVAL”">​</a></h3><p><strong>추가된 버전: v16.7.0</strong></p><p><a href="/ko/nodejs/api/fs#fscpsrc-dest-options-callback"><code>fs.cp()</code></a>를 사용할 때 <code>src</code> 또는 <code>dest</code>가 유효하지 않은 경로를 가리켰습니다.</p><h3 id="err_fs_cp_fifo_pipe" tabindex="-1"><code>ERR_FS_CP_FIFO_PIPE</code> <a class="header-anchor" href="#err_fs_cp_fifo_pipe" aria-label="Permalink to “ERR_FS_CP_FIFO_PIPE”">​</a></h3><p><strong>추가된 버전: v16.7.0</strong></p><p><a href="/ko/nodejs/api/fs#fscpsrc-dest-options-callback"><code>fs.cp()</code></a>를 사용하여 명명된 파이프를 복사하려는 시도가 있었습니다.</p><h3 id="err_fs_cp_non_dir_to_dir" tabindex="-1"><code>ERR_FS_CP_NON_DIR_TO_DIR</code> <a class="header-anchor" href="#err_fs_cp_non_dir_to_dir" aria-label="Permalink to “ERR_FS_CP_NON_DIR_TO_DIR”">​</a></h3><p><strong>추가된 버전: v16.7.0</strong></p><p><a href="/ko/nodejs/api/fs#fscpsrc-dest-options-callback"><code>fs.cp()</code></a>를 사용하여 비 디렉토리(파일, 심볼릭 링크 등)를 디렉토리로 복사하려는 시도가 있었습니다.</p><h3 id="err_fs_cp_socket" tabindex="-1"><code>ERR_FS_CP_SOCKET</code> <a class="header-anchor" href="#err_fs_cp_socket" aria-label="Permalink to “ERR_FS_CP_SOCKET”">​</a></h3><p><strong>추가된 버전: v16.7.0</strong></p><p><a href="/ko/nodejs/api/fs#fscpsrc-dest-options-callback"><code>fs.cp()</code></a>를 사용하여 소켓에 복사하려는 시도가 있었습니다.</p><h3 id="err_fs_cp_symlink_to_subdirectory" tabindex="-1"><code>ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY</code> <a class="header-anchor" href="#err_fs_cp_symlink_to_subdirectory" aria-label="Permalink to “ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY”">​</a></h3><p><strong>Added in: v16.7.0</strong></p><p><a href="/ko/nodejs/api/fs#fscpsrc-dest-options-callback"><code>fs.cp()</code></a>을 사용할 때 <code>dest</code>의 심볼릭 링크가 <code>src</code>의 하위 디렉터리를 가리켰습니다.</p><h3 id="err_fs_cp_unknown" tabindex="-1"><code>ERR_FS_CP_UNKNOWN</code> <a class="header-anchor" href="#err_fs_cp_unknown" aria-label="Permalink to “ERR_FS_CP_UNKNOWN”">​</a></h3><p><strong>Added in: v16.7.0</strong></p><p><a href="/ko/nodejs/api/fs#fscpsrc-dest-options-callback"><code>fs.cp()</code></a>을 사용하여 알 수 없는 파일 유형으로 복사하려 했습니다.</p><h3 id="err_fs_eisdir" tabindex="-1"><code>ERR_FS_EISDIR</code> <a class="header-anchor" href="#err_fs_eisdir" aria-label="Permalink to “ERR_FS_EISDIR”">​</a></h3><p>경로는 디렉터리입니다.</p><h3 id="err_fs_file_too_large" tabindex="-1"><code>ERR_FS_FILE_TOO_LARGE</code> <a class="header-anchor" href="#err_fs_file_too_large" aria-label="Permalink to “ERR_FS_FILE_TOO_LARGE”">​</a></h3><p>파일 크기가 <code>Buffer</code>의 최대 허용 크기보다 큰 파일을 읽으려고 했습니다.</p><h3 id="err_http2_altsvc_invalid_origin" tabindex="-1"><code>ERR_HTTP2_ALTSVC_INVALID_ORIGIN</code> <a class="header-anchor" href="#err_http2_altsvc_invalid_origin" aria-label="Permalink to “ERR_HTTP2_ALTSVC_INVALID_ORIGIN”">​</a></h3><p>HTTP/2 ALTSVC 프레임에는 유효한 Origin이 필요합니다.</p><h3 id="err_http2_altsvc_length" tabindex="-1"><code>ERR_HTTP2_ALTSVC_LENGTH</code> <a class="header-anchor" href="#err_http2_altsvc_length" aria-label="Permalink to “ERR_HTTP2_ALTSVC_LENGTH”">​</a></h3><p>HTTP/2 ALTSVC 프레임은 최대 16,382바이트의 페이로드로 제한됩니다.</p><h3 id="err_http2_connect_authority" tabindex="-1"><code>ERR_HTTP2_CONNECT_AUTHORITY</code> <a class="header-anchor" href="#err_http2_connect_authority" aria-label="Permalink to “ERR_HTTP2_CONNECT_AUTHORITY”">​</a></h3><p><code>CONNECT</code> 메서드를 사용하는 HTTP/2 요청의 경우 <code>:authority</code> 유사 헤더가 필요합니다.</p><h3 id="err_http2_connect_path" tabindex="-1"><code>ERR_HTTP2_CONNECT_PATH</code> <a class="header-anchor" href="#err_http2_connect_path" aria-label="Permalink to “ERR_HTTP2_CONNECT_PATH”">​</a></h3><p><code>CONNECT</code> 메서드를 사용하는 HTTP/2 요청의 경우 <code>:path</code> 유사 헤더는 금지됩니다.</p><h3 id="err_http2_connect_scheme" tabindex="-1"><code>ERR_HTTP2_CONNECT_SCHEME</code> <a class="header-anchor" href="#err_http2_connect_scheme" aria-label="Permalink to “ERR_HTTP2_CONNECT_SCHEME”">​</a></h3><p><code>CONNECT</code> 메서드를 사용하는 HTTP/2 요청의 경우 <code>:scheme</code> 유사 헤더는 금지됩니다.</p><h3 id="err_http2_error" tabindex="-1"><code>ERR_HTTP2_ERROR</code> <a class="header-anchor" href="#err_http2_error" aria-label="Permalink to “ERR_HTTP2_ERROR”">​</a></h3><p>특정되지 않은 HTTP/2 오류가 발생했습니다.</p><h3 id="err_http2_goaway_session" tabindex="-1"><code>ERR_HTTP2_GOAWAY_SESSION</code> <a class="header-anchor" href="#err_http2_goaway_session" aria-label="Permalink to “ERR_HTTP2_GOAWAY_SESSION”">​</a></h3><p>연결된 피어로부터 <code>GOAWAY</code> 프레임을 수신한 후에는 새 HTTP/2 스트림을 열 수 없습니다.</p><h3 id="err_http2_headers_after_respond" tabindex="-1"><code>ERR_HTTP2_HEADERS_AFTER_RESPOND</code> <a class="header-anchor" href="#err_http2_headers_after_respond" aria-label="Permalink to “ERR_HTTP2_HEADERS_AFTER_RESPOND”">​</a></h3><p>HTTP/2 응답이 시작된 후 추가 헤더가 지정되었습니다.</p><h3 id="err_http2_headers_sent" tabindex="-1"><code>ERR_HTTP2_HEADERS_SENT</code> <a class="header-anchor" href="#err_http2_headers_sent" aria-label="Permalink to “ERR_HTTP2_HEADERS_SENT”">​</a></h3><p>여러 응답 헤더를 보내려고 했습니다.</p><h3 id="err_http2_header_single_value" tabindex="-1"><code>ERR_HTTP2_HEADER_SINGLE_VALUE</code> <a class="header-anchor" href="#err_http2_header_single_value" aria-label="Permalink to “ERR_HTTP2_HEADER_SINGLE_VALUE”">​</a></h3><p>단일 값만 있어야 하는 HTTP/2 헤더 필드에 여러 값이 제공되었습니다.</p><h3 id="err_http2_info_status_not_allowed" tabindex="-1"><code>ERR_HTTP2_INFO_STATUS_NOT_ALLOWED</code> <a class="header-anchor" href="#err_http2_info_status_not_allowed" aria-label="Permalink to “ERR_HTTP2_INFO_STATUS_NOT_ALLOWED”">​</a></h3><p>정보 HTTP 상태 코드(<code>1xx</code>)는 HTTP/2 응답의 응답 상태 코드로 설정할 수 없습니다.</p><h3 id="err_http2_invalid_connection_headers" tabindex="-1"><code>ERR_HTTP2_INVALID_CONNECTION_HEADERS</code> <a class="header-anchor" href="#err_http2_invalid_connection_headers" aria-label="Permalink to “ERR_HTTP2_INVALID_CONNECTION_HEADERS”">​</a></h3><p>HTTP/1 연결 특정 헤더는 HTTP/2 요청 및 응답에서 사용할 수 없습니다.</p><h3 id="err_http2_invalid_header_value" tabindex="-1"><code>ERR_HTTP2_INVALID_HEADER_VALUE</code> <a class="header-anchor" href="#err_http2_invalid_header_value" aria-label="Permalink to “ERR_HTTP2_INVALID_HEADER_VALUE”">​</a></h3><p>잘못된 HTTP/2 헤더 값이 지정되었습니다.</p><h3 id="err_http2_invalid_info_status" tabindex="-1"><code>ERR_HTTP2_INVALID_INFO_STATUS</code> <a class="header-anchor" href="#err_http2_invalid_info_status" aria-label="Permalink to “ERR_HTTP2_INVALID_INFO_STATUS”">​</a></h3><p>유효하지 않은 HTTP 정보 상태 코드가 지정되었습니다. 정보 상태 코드는 <code>100</code>에서 <code>199</code> 사이의 정수여야 합니다(경계값 포함).</p><h3 id="err_http2_invalid_origin" tabindex="-1"><code>ERR_HTTP2_INVALID_ORIGIN</code> <a class="header-anchor" href="#err_http2_invalid_origin" aria-label="Permalink to “ERR_HTTP2_INVALID_ORIGIN”">​</a></h3><p>HTTP/2 <code>ORIGIN</code> 프레임에는 유효한 출처가 필요합니다.</p><h3 id="err_http2_invalid_packed_settings_length" tabindex="-1"><code>ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH</code> <a class="header-anchor" href="#err_http2_invalid_packed_settings_length" aria-label="Permalink to “ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH”">​</a></h3><p><code>http2.getUnpackedSettings()</code> API에 전달된 입력 <code>Buffer</code> 및 <code>Uint8Array</code> 인스턴스의 길이는 6의 배수여야 합니다.</p><h3 id="err_http2_invalid_pseudoheader" tabindex="-1"><code>ERR_HTTP2_INVALID_PSEUDOHEADER</code> <a class="header-anchor" href="#err_http2_invalid_pseudoheader" aria-label="Permalink to “ERR_HTTP2_INVALID_PSEUDOHEADER”">​</a></h3><p>유효한 HTTP/2 의사 헤더(<code>:status</code>, <code>:path</code>, <code>:authority</code>, <code>:scheme</code>, 및 <code>:method</code>)만 사용할 수 있습니다.</p><h3 id="err_http2_invalid_session" tabindex="-1"><code>ERR_HTTP2_INVALID_SESSION</code> <a class="header-anchor" href="#err_http2_invalid_session" aria-label="Permalink to “ERR_HTTP2_INVALID_SESSION”">​</a></h3><p>이미 소멸된 <code>Http2Session</code> 객체에 대해 작업이 수행되었습니다.</p><h3 id="err_http2_invalid_setting_value" tabindex="-1"><code>ERR_HTTP2_INVALID_SETTING_VALUE</code> <a class="header-anchor" href="#err_http2_invalid_setting_value" aria-label="Permalink to “ERR_HTTP2_INVALID_SETTING_VALUE”">​</a></h3><p>유효하지 않은 값이 HTTP/2 설정에 지정되었습니다.</p><h3 id="err_http2_invalid_stream" tabindex="-1"><code>ERR_HTTP2_INVALID_STREAM</code> <a class="header-anchor" href="#err_http2_invalid_stream" aria-label="Permalink to “ERR_HTTP2_INVALID_STREAM”">​</a></h3><p>이미 소멸된 스트림에 대해 작업이 수행되었습니다.</p><h3 id="err_http2_max_pending_settings_ack" tabindex="-1"><code>ERR_HTTP2_MAX_PENDING_SETTINGS_ACK</code> <a class="header-anchor" href="#err_http2_max_pending_settings_ack" aria-label="Permalink to “ERR_HTTP2_MAX_PENDING_SETTINGS_ACK”">​</a></h3><p>HTTP/2 <code>SETTINGS</code> 프레임이 연결된 피어에 전송될 때마다 피어는 새로운 <code>SETTINGS</code>를 수신하고 적용했다는 확인을 보내야 합니다. 기본적으로 승인되지 않은 <code>SETTINGS</code> 프레임의 최대 개수를 언제든지 보낼 수 있습니다. 이 오류 코드는 해당 제한에 도달했을 때 사용됩니다.</p><h3 id="err_http2_nested_push" tabindex="-1"><code>ERR_HTTP2_NESTED_PUSH</code> <a class="header-anchor" href="#err_http2_nested_push" aria-label="Permalink to “ERR_HTTP2_NESTED_PUSH”">​</a></h3><p>푸시 스트림 내에서 새 푸시 스트림을 시작하려고 시도했습니다. 중첩된 푸시 스트림은 허용되지 않습니다.</p><h3 id="err_http2_no_mem" tabindex="-1"><code>ERR_HTTP2_NO_MEM</code> <a class="header-anchor" href="#err_http2_no_mem" aria-label="Permalink to “ERR_HTTP2_NO_MEM”">​</a></h3><p><code>http2session.setLocalWindowSize(windowSize)</code> API를 사용하는 동안 메모리가 부족합니다.</p><h3 id="err_http2_no_socket_manipulation" tabindex="-1"><code>ERR_HTTP2_NO_SOCKET_MANIPULATION</code> <a class="header-anchor" href="#err_http2_no_socket_manipulation" aria-label="Permalink to “ERR_HTTP2_NO_SOCKET_MANIPULATION”">​</a></h3><p><code>Http2Session</code>에 연결된 소켓을 직접 조작(읽기, 쓰기, 일시 중지, 재개 등)하려고 시도했습니다.</p><h3 id="err_http2_origin_length" tabindex="-1"><code>ERR_HTTP2_ORIGIN_LENGTH</code> <a class="header-anchor" href="#err_http2_origin_length" aria-label="Permalink to “ERR_HTTP2_ORIGIN_LENGTH”">​</a></h3><p>HTTP/2 <code>ORIGIN</code> 프레임은 길이가 16382바이트로 제한됩니다.</p><h3 id="err_http2_out_of_streams" tabindex="-1"><code>ERR_HTTP2_OUT_OF_STREAMS</code> <a class="header-anchor" href="#err_http2_out_of_streams" aria-label="Permalink to “ERR_HTTP2_OUT_OF_STREAMS”">​</a></h3><p>단일 HTTP/2 세션에서 생성된 스트림 수가 최대 제한에 도달했습니다.</p><h3 id="err_http2_payload_forbidden" tabindex="-1"><code>ERR_HTTP2_PAYLOAD_FORBIDDEN</code> <a class="header-anchor" href="#err_http2_payload_forbidden" aria-label="Permalink to “ERR_HTTP2_PAYLOAD_FORBIDDEN”">​</a></h3><p>페이로드가 금지된 HTTP 응답 코드에 대해 메시지 페이로드가 지정되었습니다.</p><h3 id="err_http2_ping_cancel" tabindex="-1"><code>ERR_HTTP2_PING_CANCEL</code> <a class="header-anchor" href="#err_http2_ping_cancel" aria-label="Permalink to “ERR_HTTP2_PING_CANCEL”">​</a></h3><p>HTTP/2 핑이 취소되었습니다.</p><h3 id="err_http2_ping_length" tabindex="-1"><code>ERR_HTTP2_PING_LENGTH</code> <a class="header-anchor" href="#err_http2_ping_length" aria-label="Permalink to “ERR_HTTP2_PING_LENGTH”">​</a></h3><p>HTTP/2 핑 페이로드는 정확히 8바이트 길이여야 합니다.</p><h3 id="err_http2_pseudoheader_not_allowed" tabindex="-1"><code>ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED</code> <a class="header-anchor" href="#err_http2_pseudoheader_not_allowed" aria-label="Permalink to “ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED”">​</a></h3><p>HTTP/2 유사 헤더가 부적절하게 사용되었습니다. 유사 헤더는 <code>:</code> 접두사로 시작하는 헤더 키 이름입니다.</p><h3 id="err_http2_push_disabled" tabindex="-1"><code>ERR_HTTP2_PUSH_DISABLED</code> <a class="header-anchor" href="#err_http2_push_disabled" aria-label="Permalink to “ERR_HTTP2_PUSH_DISABLED”">​</a></h3><p>클라이언트에서 비활성화된 푸시 스트림을 생성하려고 시도했습니다.</p><h3 id="err_http2_send_file" tabindex="-1"><code>ERR_HTTP2_SEND_FILE</code> <a class="header-anchor" href="#err_http2_send_file" aria-label="Permalink to “ERR_HTTP2_SEND_FILE”">​</a></h3><p><code>Http2Stream.prototype.responseWithFile()</code> API를 사용하여 디렉터리를 보내려고 시도했습니다.</p><h3 id="err_http2_send_file_noseek" tabindex="-1"><code>ERR_HTTP2_SEND_FILE_NOSEEK</code> <a class="header-anchor" href="#err_http2_send_file_noseek" aria-label="Permalink to “ERR_HTTP2_SEND_FILE_NOSEEK”">​</a></h3><p><code>Http2Stream.prototype.responseWithFile()</code> API를 사용하여 일반 파일이 아닌 것을 보내려고 시도했지만 <code>offset</code> 또는 <code>length</code> 옵션이 제공되었습니다.</p><h3 id="err_http2_session_error" tabindex="-1"><code>ERR_HTTP2_SESSION_ERROR</code> <a class="header-anchor" href="#err_http2_session_error" aria-label="Permalink to “ERR_HTTP2_SESSION_ERROR”">​</a></h3><p><code>Http2Session</code>이 0이 아닌 오류 코드로 닫혔습니다.</p><h3 id="err_http2_settings_cancel" tabindex="-1"><code>ERR_HTTP2_SETTINGS_CANCEL</code> <a class="header-anchor" href="#err_http2_settings_cancel" aria-label="Permalink to “ERR_HTTP2_SETTINGS_CANCEL”">​</a></h3><p><code>Http2Session</code> 설정이 취소되었습니다.</p><h3 id="err_http2_socket_bound" tabindex="-1"><code>ERR_HTTP2_SOCKET_BOUND</code> <a class="header-anchor" href="#err_http2_socket_bound" aria-label="Permalink to “ERR_HTTP2_SOCKET_BOUND”">​</a></h3><p>이미 다른 <code>Http2Session</code> 객체에 바인딩된 <code>net.Socket</code> 또는 <code>tls.TLSSocket</code>에 <code>Http2Session</code> 객체를 연결하려고 시도했습니다.</p><h3 id="err_http2_socket_unbound" tabindex="-1"><code>ERR_HTTP2_SOCKET_UNBOUND</code> <a class="header-anchor" href="#err_http2_socket_unbound" aria-label="Permalink to “ERR_HTTP2_SOCKET_UNBOUND”">​</a></h3><p>이미 닫힌 <code>Http2Session</code>의 <code>socket</code> 속성을 사용하려고 시도했습니다.</p><h3 id="err_http2_status_101" tabindex="-1"><code>ERR_HTTP2_STATUS_101</code> <a class="header-anchor" href="#err_http2_status_101" aria-label="Permalink to “ERR_HTTP2_STATUS_101”">​</a></h3><p>HTTP/2에서는 <code>101</code> 정보 상태 코드의 사용이 금지됩니다.</p><h3 id="err_http2_status_invalid" tabindex="-1"><code>ERR_HTTP2_STATUS_INVALID</code> <a class="header-anchor" href="#err_http2_status_invalid" aria-label="Permalink to “ERR_HTTP2_STATUS_INVALID”">​</a></h3><p>잘못된 HTTP 상태 코드가 지정되었습니다. 상태 코드는 <code>100</code>과 <code>599</code> 사이의 정수여야 합니다(경계값 포함).</p><h3 id="err_http2_stream_cancel" tabindex="-1"><code>ERR_HTTP2_STREAM_CANCEL</code> <a class="header-anchor" href="#err_http2_stream_cancel" aria-label="Permalink to “ERR_HTTP2_STREAM_CANCEL”">​</a></h3><p>연결된 피어로 데이터가 전송되기 전에 <code>Http2Stream</code>이 파괴되었습니다.</p><h3 id="err_http2_stream_error" tabindex="-1"><code>ERR_HTTP2_STREAM_ERROR</code> <a class="header-anchor" href="#err_http2_stream_error" aria-label="Permalink to “ERR_HTTP2_STREAM_ERROR”">​</a></h3><p><code>RST_STREAM</code> 프레임에 0이 아닌 오류 코드가 지정되었습니다.</p><h3 id="err_http2_stream_self_dependency" tabindex="-1"><code>ERR_HTTP2_STREAM_SELF_DEPENDENCY</code> <a class="header-anchor" href="#err_http2_stream_self_dependency" aria-label="Permalink to “ERR_HTTP2_STREAM_SELF_DEPENDENCY”">​</a></h3><p>HTTP/2 스트림의 우선 순위를 설정할 때 스트림은 부모 스트림의 종속성으로 표시될 수 있습니다. 이 오류 코드는 스트림 자체를 종속 항목으로 표시하려고 할 때 사용됩니다.</p><h3 id="err_http2_too_many_custom_settings" tabindex="-1"><code>ERR_HTTP2_TOO_MANY_CUSTOM_SETTINGS</code> <a class="header-anchor" href="#err_http2_too_many_custom_settings" aria-label="Permalink to “ERR_HTTP2_TOO_MANY_CUSTOM_SETTINGS”">​</a></h3><p>지원되는 사용자 지정 설정 수(10)를 초과했습니다.</p><h3 id="err_http2_too_many_invalid_frames" tabindex="-1"><code>ERR_HTTP2_TOO_MANY_INVALID_FRAMES</code> <a class="header-anchor" href="#err_http2_too_many_invalid_frames" aria-label="Permalink to “ERR_HTTP2_TOO_MANY_INVALID_FRAMES”">​</a></h3><p><strong>Added in: v15.14.0</strong></p><p><code>maxSessionInvalidFrames</code> 옵션을 통해 지정된 피어가 보낸 허용 가능한 잘못된 HTTP/2 프로토콜 프레임 제한을 초과했습니다.</p><h3 id="err_http2_trailers_already_sent" tabindex="-1"><code>ERR_HTTP2_TRAILERS_ALREADY_SENT</code> <a class="header-anchor" href="#err_http2_trailers_already_sent" aria-label="Permalink to “ERR_HTTP2_TRAILERS_ALREADY_SENT”">​</a></h3><p>트레일링 헤더가 <code>Http2Stream</code>에서 이미 전송되었습니다.</p><h3 id="err_http2_trailers_not_ready" tabindex="-1"><code>ERR_HTTP2_TRAILERS_NOT_READY</code> <a class="header-anchor" href="#err_http2_trailers_not_ready" aria-label="Permalink to “ERR_HTTP2_TRAILERS_NOT_READY”">​</a></h3><p><code>http2stream.sendTrailers()</code> 메서드는 <code>Http2Stream</code> 객체에서 <code>&#39;wantTrailers&#39;</code> 이벤트가 발생한 후에 호출할 수 있습니다. <code>&#39;wantTrailers&#39;</code> 이벤트는 <code>Http2Stream</code>에 대해 <code>waitForTrailers</code> 옵션이 설정된 경우에만 발생합니다.</p><h3 id="err_http2_unsupported_protocol" tabindex="-1"><code>ERR_HTTP2_UNSUPPORTED_PROTOCOL</code> <a class="header-anchor" href="#err_http2_unsupported_protocol" aria-label="Permalink to “ERR_HTTP2_UNSUPPORTED_PROTOCOL”">​</a></h3><p><code>http2.connect()</code>에 <code>http:</code> 또는 <code>https:</code> 이외의 프로토콜을 사용하는 URL이 전달되었습니다.</p><h3 id="err_http_body_not_allowed" tabindex="-1"><code>ERR_HTTP_BODY_NOT_ALLOWED</code> <a class="header-anchor" href="#err_http_body_not_allowed" aria-label="Permalink to “ERR_HTTP_BODY_NOT_ALLOWED”">​</a></h3><p>콘텐츠를 허용하지 않는 HTTP 응답에 쓰려고 할 때 오류가 발생합니다.</p><h3 id="err_http_content_length_mismatch" tabindex="-1"><code>ERR_HTTP_CONTENT_LENGTH_MISMATCH</code> <a class="header-anchor" href="#err_http_content_length_mismatch" aria-label="Permalink to “ERR_HTTP_CONTENT_LENGTH_MISMATCH”">​</a></h3><p>응답 본문 크기가 지정된 콘텐츠 길이 헤더 값과 일치하지 않습니다.</p><h3 id="err_http_headers_sent" tabindex="-1"><code>ERR_HTTP_HEADERS_SENT</code> <a class="header-anchor" href="#err_http_headers_sent" aria-label="Permalink to “ERR_HTTP_HEADERS_SENT”">​</a></h3><p>헤더가 이미 전송된 후에 더 많은 헤더를 추가하려고 시도했습니다.</p><h3 id="err_http_invalid_header_value" tabindex="-1"><code>ERR_HTTP_INVALID_HEADER_VALUE</code> <a class="header-anchor" href="#err_http_invalid_header_value" aria-label="Permalink to “ERR_HTTP_INVALID_HEADER_VALUE”">​</a></h3><p>잘못된 HTTP 헤더 값이 지정되었습니다.</p><h3 id="err_http_invalid_status_code" tabindex="-1"><code>ERR_HTTP_INVALID_STATUS_CODE</code> <a class="header-anchor" href="#err_http_invalid_status_code" aria-label="Permalink to “ERR_HTTP_INVALID_STATUS_CODE”">​</a></h3><p>상태 코드가 일반 상태 코드 범위(100-999)를 벗어났습니다.</p><h3 id="err_http_request_timeout" tabindex="-1"><code>ERR_HTTP_REQUEST_TIMEOUT</code> <a class="header-anchor" href="#err_http_request_timeout" aria-label="Permalink to “ERR_HTTP_REQUEST_TIMEOUT”">​</a></h3><p>클라이언트가 허용된 시간 내에 전체 요청을 보내지 않았습니다.</p><h3 id="err_http_socket_assigned" tabindex="-1"><code>ERR_HTTP_SOCKET_ASSIGNED</code> <a class="header-anchor" href="#err_http_socket_assigned" aria-label="Permalink to “ERR_HTTP_SOCKET_ASSIGNED”">​</a></h3><p>지정된 <a href="/ko/nodejs/api/http#class-httpserverresponse"><code>ServerResponse</code></a>에 이미 소켓이 할당되었습니다.</p><h3 id="err_http_socket_encoding" tabindex="-1"><code>ERR_HTTP_SOCKET_ENCODING</code> <a class="header-anchor" href="#err_http_socket_encoding" aria-label="Permalink to “ERR_HTTP_SOCKET_ENCODING”">​</a></h3><p>소켓 인코딩 변경은 <a href="https://tools.ietf.org/html/rfc7230#section-3" target="_blank" rel="noreferrer">RFC 7230 섹션 3</a>에 따라 허용되지 않습니다.</p><h3 id="err_http_trailer_invalid" tabindex="-1"><code>ERR_HTTP_TRAILER_INVALID</code> <a class="header-anchor" href="#err_http_trailer_invalid" aria-label="Permalink to “ERR_HTTP_TRAILER_INVALID”">​</a></h3><p>전송 인코딩이 이를 지원하지 않더라도 <code>Trailer</code> 헤더가 설정되었습니다.</p><h3 id="err_illegal_constructor" tabindex="-1"><code>ERR_ILLEGAL_CONSTRUCTOR</code> <a class="header-anchor" href="#err_illegal_constructor" aria-label="Permalink to “ERR_ILLEGAL_CONSTRUCTOR”">​</a></h3><p>공용이 아닌 생성자를 사용하여 객체를 생성하려고 시도했습니다.</p><h3 id="err_import_attribute_missing" tabindex="-1"><code>ERR_IMPORT_ATTRIBUTE_MISSING</code> <a class="header-anchor" href="#err_import_attribute_missing" aria-label="Permalink to “ERR_IMPORT_ATTRIBUTE_MISSING”">​</a></h3><p><strong>Added in: v21.1.0</strong></p><p>가져오기 속성이 누락되어 지정된 모듈을 가져올 수 없습니다.</p><h3 id="err_import_attribute_type_incompatible" tabindex="-1"><code>ERR_IMPORT_ATTRIBUTE_TYPE_INCOMPATIBLE</code> <a class="header-anchor" href="#err_import_attribute_type_incompatible" aria-label="Permalink to “ERR_IMPORT_ATTRIBUTE_TYPE_INCOMPATIBLE”">​</a></h3><p><strong>Added in: v21.1.0</strong></p><p>가져오기 <code>type</code> 속성이 제공되었지만, 지정된 모듈은 다른 유형입니다.</p><h3 id="err_import_attribute_unsupported" tabindex="-1"><code>ERR_IMPORT_ATTRIBUTE_UNSUPPORTED</code> <a class="header-anchor" href="#err_import_attribute_unsupported" aria-label="Permalink to “ERR_IMPORT_ATTRIBUTE_UNSUPPORTED”">​</a></h3><p><strong>Added in: v21.0.0, v20.10.0, v18.19.0</strong></p><p>이 Node.js 버전에서는 가져오기 속성이 지원되지 않습니다.</p><h3 id="err_incompatible_option_pair" tabindex="-1"><code>ERR_INCOMPATIBLE_OPTION_PAIR</code> <a class="header-anchor" href="#err_incompatible_option_pair" aria-label="Permalink to “ERR_INCOMPATIBLE_OPTION_PAIR”">​</a></h3><p>옵션 쌍이 서로 호환되지 않아 동시에 사용할 수 없습니다.</p><h3 id="err_input_type_not_allowed" tabindex="-1"><code>ERR_INPUT_TYPE_NOT_ALLOWED</code> <a class="header-anchor" href="#err_input_type_not_allowed" aria-label="Permalink to “ERR_INPUT_TYPE_NOT_ALLOWED”">​</a></h3><div class="warning custom-block"><p class="custom-block-title">[Stable: 1 - Experimental]</p><p><a href="/ko/nodejs/api/documentation#stability-index">Stable: 1</a> <a href="/ko/nodejs/api/documentation#stability-index">Stability: 1</a> - 실험적</p></div><p><code>--input-type</code> 플래그가 파일을 실행하려고 시도하는 데 사용되었습니다. 이 플래그는 <code>--eval</code>, <code>--print</code> 또는 <code>STDIN</code>을 통한 입력에만 사용할 수 있습니다.</p><h3 id="err_inspector_already_activated" tabindex="-1"><code>ERR_INSPECTOR_ALREADY_ACTIVATED</code> <a class="header-anchor" href="#err_inspector_already_activated" aria-label="Permalink to “ERR_INSPECTOR_ALREADY_ACTIVATED”">​</a></h3><p><code>node:inspector</code> 모듈을 사용하는 동안, 인스펙터가 이미 포트에서 수신 대기하기 시작했을 때 활성화하려고 시도했습니다. 다른 주소에서 활성화하기 전에 <code>inspector.close()</code>를 사용하십시오.</p><h3 id="err_inspector_already_connected" tabindex="-1"><code>ERR_INSPECTOR_ALREADY_CONNECTED</code> <a class="header-anchor" href="#err_inspector_already_connected" aria-label="Permalink to “ERR_INSPECTOR_ALREADY_CONNECTED”">​</a></h3><p><code>node:inspector</code> 모듈을 사용하는 동안, 인스펙터가 이미 연결되었을 때 연결하려고 시도했습니다.</p><h3 id="err_inspector_closed" tabindex="-1"><code>ERR_INSPECTOR_CLOSED</code> <a class="header-anchor" href="#err_inspector_closed" aria-label="Permalink to “ERR_INSPECTOR_CLOSED”">​</a></h3><p><code>node:inspector</code> 모듈을 사용하는 동안, 세션이 이미 닫힌 후 인스펙터를 사용하려고 시도했습니다.</p><h3 id="err_inspector_command" tabindex="-1"><code>ERR_INSPECTOR_COMMAND</code> <a class="header-anchor" href="#err_inspector_command" aria-label="Permalink to “ERR_INSPECTOR_COMMAND”">​</a></h3><p><code>node:inspector</code> 모듈을 통해 명령을 실행하는 동안 오류가 발생했습니다.</p><h3 id="err_inspector_not_active" tabindex="-1"><code>ERR_INSPECTOR_NOT_ACTIVE</code> <a class="header-anchor" href="#err_inspector_not_active" aria-label="Permalink to “ERR_INSPECTOR_NOT_ACTIVE”">​</a></h3><p><code>inspector.waitForDebugger()</code>가 호출될 때 <code>inspector</code>가 활성화되지 않았습니다.</p><h3 id="err_inspector_not_available" tabindex="-1"><code>ERR_INSPECTOR_NOT_AVAILABLE</code> <a class="header-anchor" href="#err_inspector_not_available" aria-label="Permalink to “ERR_INSPECTOR_NOT_AVAILABLE”">​</a></h3><p><code>node:inspector</code> 모듈을 사용할 수 없습니다.</p><h3 id="err_inspector_not_connected" tabindex="-1"><code>ERR_INSPECTOR_NOT_CONNECTED</code> <a class="header-anchor" href="#err_inspector_not_connected" aria-label="Permalink to “ERR_INSPECTOR_NOT_CONNECTED”">​</a></h3><p><code>node:inspector</code> 모듈을 사용하는 동안, 인스펙터가 연결되기 전에 사용하려고 시도했습니다.</p><h3 id="err_inspector_not_worker" tabindex="-1"><code>ERR_INSPECTOR_NOT_WORKER</code> <a class="header-anchor" href="#err_inspector_not_worker" aria-label="Permalink to “ERR_INSPECTOR_NOT_WORKER”">​</a></h3><p>워커 스레드에서만 사용할 수 있는 API가 메인 스레드에서 호출되었습니다.</p><h3 id="err_internal_assertion" tabindex="-1"><code>ERR_INTERNAL_ASSERTION</code> <a class="header-anchor" href="#err_internal_assertion" aria-label="Permalink to “ERR_INTERNAL_ASSERTION”">​</a></h3><p>Node.js에 버그가 있거나 Node.js 내부를 잘못 사용했습니다. 오류를 수정하려면 <a href="https://github.com/nodejs/node/issues" target="_blank" rel="noreferrer">https://github.com/nodejs/node/issues</a>에 문제를 여십시오.</p><h3 id="err_invalid_address" tabindex="-1"><code>ERR_INVALID_ADDRESS</code> <a class="header-anchor" href="#err_invalid_address" aria-label="Permalink to “ERR_INVALID_ADDRESS”">​</a></h3><p>제공된 주소를 Node.js API가 이해하지 못합니다.</p><h3 id="err_invalid_address_family" tabindex="-1"><code>ERR_INVALID_ADDRESS_FAMILY</code> <a class="header-anchor" href="#err_invalid_address_family" aria-label="Permalink to “ERR_INVALID_ADDRESS_FAMILY”">​</a></h3><p>제공된 주소 체계를 Node.js API가 이해하지 못합니다.</p><h3 id="err_invalid_arg_type" tabindex="-1"><code>ERR_INVALID_ARG_TYPE</code> <a class="header-anchor" href="#err_invalid_arg_type" aria-label="Permalink to “ERR_INVALID_ARG_TYPE”">​</a></h3><p>잘못된 유형의 인수가 Node.js API에 전달되었습니다.</p><h3 id="err_invalid_arg_value" tabindex="-1"><code>ERR_INVALID_ARG_VALUE</code> <a class="header-anchor" href="#err_invalid_arg_value" aria-label="Permalink to “ERR_INVALID_ARG_VALUE”">​</a></h3><p>주어진 인수에 대해 잘못되었거나 지원되지 않는 값이 전달되었습니다.</p><h3 id="err_invalid_async_id" tabindex="-1"><code>ERR_INVALID_ASYNC_ID</code> <a class="header-anchor" href="#err_invalid_async_id" aria-label="Permalink to “ERR_INVALID_ASYNC_ID”">​</a></h3><p>잘못된 <code>asyncId</code> 또는 <code>triggerAsyncId</code>가 <code>AsyncHooks</code>를 사용하여 전달되었습니다. -1보다 작은 ID는 발생하지 않아야 합니다.</p><h3 id="err_invalid_buffer_size" tabindex="-1"><code>ERR_INVALID_BUFFER_SIZE</code> <a class="header-anchor" href="#err_invalid_buffer_size" aria-label="Permalink to “ERR_INVALID_BUFFER_SIZE”">​</a></h3><p><code>Buffer</code>에서 스왑이 수행되었지만 해당 크기가 작업과 호환되지 않았습니다.</p><h3 id="err_invalid_char" tabindex="-1"><code>ERR_INVALID_CHAR</code> <a class="header-anchor" href="#err_invalid_char" aria-label="Permalink to “ERR_INVALID_CHAR”">​</a></h3><p>헤더에서 잘못된 문자가 감지되었습니다.</p><h3 id="err_invalid_cursor_pos" tabindex="-1"><code>ERR_INVALID_CURSOR_POS</code> <a class="header-anchor" href="#err_invalid_cursor_pos" aria-label="Permalink to “ERR_INVALID_CURSOR_POS”">​</a></h3><p>지정된 스트림의 커서를 지정된 열 없이 지정된 행으로 이동할 수 없습니다.</p><h3 id="err_invalid_fd" tabindex="-1"><code>ERR_INVALID_FD</code> <a class="header-anchor" href="#err_invalid_fd" aria-label="Permalink to “ERR_INVALID_FD”">​</a></h3><p>파일 설명자(&#39;fd&#39;)가 유효하지 않습니다 (예: 음수 값).</p><h3 id="err_invalid_fd_type" tabindex="-1"><code>ERR_INVALID_FD_TYPE</code> <a class="header-anchor" href="#err_invalid_fd_type" aria-label="Permalink to “ERR_INVALID_FD_TYPE”">​</a></h3><p>파일 설명자(&#39;fd&#39;) 유형이 유효하지 않습니다.</p><h3 id="err_invalid_file_url_host" tabindex="-1"><code>ERR_INVALID_FILE_URL_HOST</code> <a class="header-anchor" href="#err_invalid_file_url_host" aria-label="Permalink to “ERR_INVALID_FILE_URL_HOST”">​</a></h3><p><code>file:</code> URL을 사용하는 Node.js API (예: <a href="/ko/nodejs/api/fs"><code>fs</code></a> 모듈의 특정 함수)에서 호환되지 않는 호스트를 가진 파일 URL을 발견했습니다. 이 상황은 <code>localhost</code> 또는 빈 호스트만 지원되는 Unix 계열 시스템에서만 발생할 수 있습니다.</p><h3 id="err_invalid_file_url_path" tabindex="-1"><code>ERR_INVALID_FILE_URL_PATH</code> <a class="header-anchor" href="#err_invalid_file_url_path" aria-label="Permalink to “ERR_INVALID_FILE_URL_PATH”">​</a></h3><p><code>file:</code> URL을 사용하는 Node.js API (예: <a href="/ko/nodejs/api/fs"><code>fs</code></a> 모듈의 특정 함수)에서 호환되지 않는 경로를 가진 파일 URL을 발견했습니다. 경로를 사용할 수 있는지 여부를 결정하는 정확한 의미 체계는 플랫폼에 따라 다릅니다.</p><h3 id="err_invalid_handle_type" tabindex="-1"><code>ERR_INVALID_HANDLE_TYPE</code> <a class="header-anchor" href="#err_invalid_handle_type" aria-label="Permalink to “ERR_INVALID_HANDLE_TYPE”">​</a></h3><p>IPC 통신 채널을 통해 자식 프로세스로 지원되지 않는 &quot;핸들&quot;을 보내려고 시도했습니다. 자세한 내용은 <a href="/ko/nodejs/api/child_process#subprocesssendmessage-sendhandle-options-callback"><code>subprocess.send()</code></a> 및 <a href="/ko/nodejs/api/process#processsendmessage-sendhandle-options-callback"><code>process.send()</code></a>를 참조하십시오.</p><h3 id="err_invalid_http_token" tabindex="-1"><code>ERR_INVALID_HTTP_TOKEN</code> <a class="header-anchor" href="#err_invalid_http_token" aria-label="Permalink to “ERR_INVALID_HTTP_TOKEN”">​</a></h3><p>잘못된 HTTP 토큰이 제공되었습니다.</p><h3 id="err_invalid_ip_address" tabindex="-1"><code>ERR_INVALID_IP_ADDRESS</code> <a class="header-anchor" href="#err_invalid_ip_address" aria-label="Permalink to “ERR_INVALID_IP_ADDRESS”">​</a></h3><p>IP 주소가 유효하지 않습니다.</p><h3 id="err_invalid_mime_syntax" tabindex="-1"><code>ERR_INVALID_MIME_SYNTAX</code> <a class="header-anchor" href="#err_invalid_mime_syntax" aria-label="Permalink to “ERR_INVALID_MIME_SYNTAX”">​</a></h3><p>MIME의 구문이 유효하지 않습니다.</p><h3 id="err_invalid_module" tabindex="-1"><code>ERR_INVALID_MODULE</code> <a class="header-anchor" href="#err_invalid_module" aria-label="Permalink to “ERR_INVALID_MODULE”">​</a></h3><p><strong>Added in: v15.0.0, v14.18.0</strong></p><p>존재하지 않거나 유효하지 않은 모듈을 로드하려고 시도했습니다.</p><h3 id="err_invalid_module_specifier" tabindex="-1"><code>ERR_INVALID_MODULE_SPECIFIER</code> <a class="header-anchor" href="#err_invalid_module_specifier" aria-label="Permalink to “ERR_INVALID_MODULE_SPECIFIER”">​</a></h3><p>가져온 모듈 문자열이 유효하지 않은 URL, 패키지 이름 또는 패키지 하위 경로 지정자입니다.</p><h3 id="err_invalid_object_define_property" tabindex="-1"><code>ERR_INVALID_OBJECT_DEFINE_PROPERTY</code> <a class="header-anchor" href="#err_invalid_object_define_property" aria-label="Permalink to “ERR_INVALID_OBJECT_DEFINE_PROPERTY”">​</a></h3><p>객체의 속성에 유효하지 않은 속성을 설정하는 동안 오류가 발생했습니다.</p><h3 id="err_invalid_package_config" tabindex="-1"><code>ERR_INVALID_PACKAGE_CONFIG</code> <a class="header-anchor" href="#err_invalid_package_config" aria-label="Permalink to “ERR_INVALID_PACKAGE_CONFIG”">​</a></h3><p>유효하지 않은 <a href="/ko/nodejs/api/packages#nodejs-packagejson-field-definitions"><code>package.json</code></a> 파일을 구문 분석하지 못했습니다.</p><h3 id="err_invalid_package_target" tabindex="-1"><code>ERR_INVALID_PACKAGE_TARGET</code> <a class="header-anchor" href="#err_invalid_package_target" aria-label="Permalink to “ERR_INVALID_PACKAGE_TARGET”">​</a></h3><p><code>package.json</code> <a href="/ko/nodejs/api/packages#exports"><code>&quot;exports&quot;</code></a> 필드에 시도한 모듈 확인에 대한 유효하지 않은 대상 매핑 값이 포함되어 있습니다.</p><h3 id="err_invalid_protocol" tabindex="-1"><code>ERR_INVALID_PROTOCOL</code> <a class="header-anchor" href="#err_invalid_protocol" aria-label="Permalink to “ERR_INVALID_PROTOCOL”">​</a></h3><p>유효하지 않은 <code>options.protocol</code>이 <code>http.request()</code>에 전달되었습니다.</p><h3 id="err_invalid_repl_eval_config" tabindex="-1"><code>ERR_INVALID_REPL_EVAL_CONFIG</code> <a class="header-anchor" href="#err_invalid_repl_eval_config" aria-label="Permalink to “ERR_INVALID_REPL_EVAL_CONFIG”">​</a></h3><p><a href="/ko/nodejs/api/repl"><code>REPL</code></a> 구성에서 <code>breakEvalOnSigint</code> 및 <code>eval</code> 옵션이 모두 설정되었으며 이는 지원되지 않습니다.</p><h3 id="err_invalid_repl_input" tabindex="-1"><code>ERR_INVALID_REPL_INPUT</code> <a class="header-anchor" href="#err_invalid_repl_input" aria-label="Permalink to “ERR_INVALID_REPL_INPUT”">​</a></h3><p>입력을 <a href="/ko/nodejs/api/repl"><code>REPL</code></a>에서 사용할 수 없습니다. 이 오류가 사용되는 조건은 <a href="/ko/nodejs/api/repl"><code>REPL</code></a> 문서에 설명되어 있습니다.</p><h3 id="err_invalid_return_property" tabindex="-1"><code>ERR_INVALID_RETURN_PROPERTY</code> <a class="header-anchor" href="#err_invalid_return_property" aria-label="Permalink to “ERR_INVALID_RETURN_PROPERTY”">​</a></h3><p>함수 옵션이 실행 시 반환된 객체 속성 중 하나에 대해 유효한 값을 제공하지 않는 경우 발생합니다.</p><h3 id="err_invalid_return_property_value" tabindex="-1"><code>ERR_INVALID_RETURN_PROPERTY_VALUE</code> <a class="header-anchor" href="#err_invalid_return_property_value" aria-label="Permalink to “ERR_INVALID_RETURN_PROPERTY_VALUE”">​</a></h3><p>함수 옵션이 실행 시 반환된 객체 속성 중 하나에 대해 예상되는 값 유형을 제공하지 않는 경우 발생합니다.</p><h3 id="err_invalid_return_value" tabindex="-1"><code>ERR_INVALID_RETURN_VALUE</code> <a class="header-anchor" href="#err_invalid_return_value" aria-label="Permalink to “ERR_INVALID_RETURN_VALUE”">​</a></h3><p>함수가 Promise를 반환해야 하는 경우와 같이 함수 옵션이 실행 시 예상되는 값 유형을 반환하지 않는 경우 발생합니다.</p><h3 id="err_invalid_state" tabindex="-1"><code>ERR_INVALID_STATE</code> <a class="header-anchor" href="#err_invalid_state" aria-label="Permalink to “ERR_INVALID_STATE”">​</a></h3><p><strong>Added in: v15.0.0</strong></p><p>유효하지 않은 상태로 인해 작업을 완료할 수 없음을 나타냅니다. 예를 들어 개체가 이미 소멸되었거나 다른 작업을 수행 중일 수 있습니다.</p><h3 id="err_invalid_sync_fork_input" tabindex="-1"><code>ERR_INVALID_SYNC_FORK_INPUT</code> <a class="header-anchor" href="#err_invalid_sync_fork_input" aria-label="Permalink to “ERR_INVALID_SYNC_FORK_INPUT”">​</a></h3><p><code>Buffer</code>, <code>TypedArray</code>, <code>DataView</code> 또는 <code>string</code>이 비동기 포크에 대한 stdio 입력으로 제공되었습니다. 자세한 내용은 <a href="/ko/nodejs/api/child_process"><code>child_process</code></a> 모듈에 대한 문서를 참조하세요.</p><h3 id="err_invalid_this" tabindex="-1"><code>ERR_INVALID_THIS</code> <a class="header-anchor" href="#err_invalid_this" aria-label="Permalink to “ERR_INVALID_THIS”">​</a></h3><p>Node.js API 함수가 호환되지 않는 <code>this</code> 값으로 호출되었습니다.</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> urlSearchParams</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> URLSearchParams</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo=bar&amp;baz=new&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> buf</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Buffer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">urlSearchParams.has.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buf, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &#39;ERR_INVALID_THIS&#39; 코드가 있는 TypeError를 발생시킵니다.</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="err_invalid_tuple" tabindex="-1"><code>ERR_INVALID_TUPLE</code> <a class="header-anchor" href="#err_invalid_tuple" aria-label="Permalink to “ERR_INVALID_TUPLE”">​</a></h3><p><a href="/ko/nodejs/api/url#the-whatwg-url-api">WHATWG</a> <a href="/ko/nodejs/api/url#new-urlsearchparamsiterable"><code>URLSearchParams</code> 생성자</a>에 제공된 <code>iterable</code>의 요소가 <code>[name, value]</code> 튜플을 나타내지 않았습니다. 즉, 요소가 iterable이 아니거나 정확히 두 개의 요소로 구성되지 않은 경우입니다.</p><h3 id="err_invalid_typescript_syntax" tabindex="-1"><code>ERR_INVALID_TYPESCRIPT_SYNTAX</code> <a class="header-anchor" href="#err_invalid_typescript_syntax" aria-label="Permalink to “ERR_INVALID_TYPESCRIPT_SYNTAX”">​</a></h3><p><strong>추가된 버전: v23.0.0</strong></p><p>제공된 TypeScript 구문이 유효하지 않거나 지원되지 않습니다. 이는 <a href="/ko/nodejs/api/typescript#type-stripping">타입 제거</a>를 통해 변환이 필요한 TypeScript 구문을 사용할 때 발생할 수 있습니다.</p><h3 id="err_invalid_uri" tabindex="-1"><code>ERR_INVALID_URI</code> <a class="header-anchor" href="#err_invalid_uri" aria-label="Permalink to “ERR_INVALID_URI”">​</a></h3><p>잘못된 URI가 전달되었습니다.</p><h3 id="err_invalid_url" tabindex="-1"><code>ERR_INVALID_URL</code> <a class="header-anchor" href="#err_invalid_url" aria-label="Permalink to “ERR_INVALID_URL”">​</a></h3><p>잘못된 URL이 <a href="/ko/nodejs/api/url#the-whatwg-url-api">WHATWG</a> <a href="/ko/nodejs/api/url#new-urlinput-base"><code>URL</code> 생성자</a> 또는 레거시 <a href="/ko/nodejs/api/url#urlparseurlstring-parsequerystring-slashesdenotehost"><code>url.parse()</code></a>에 전달되어 구문 분석되었습니다. 발생된 오류 객체에는 일반적으로 구문 분석에 실패한 URL을 포함하는 추가 속성 <code>&#39;input&#39;</code>이 있습니다.</p><h3 id="err_invalid_url_scheme" tabindex="-1"><code>ERR_INVALID_URL_SCHEME</code> <a class="header-anchor" href="#err_invalid_url_scheme" aria-label="Permalink to “ERR_INVALID_URL_SCHEME”">​</a></h3><p>특정 목적에 맞지 않는 스킴(프로토콜)의 URL을 사용하려고 시도했습니다. 이는 <a href="/ko/nodejs/api/fs"><code>fs</code></a> 모듈의 <a href="/ko/nodejs/api/url#the-whatwg-url-api">WHATWG URL API</a> 지원에서만 사용되지만(파일 스킴 <code>&#39;file&#39;</code>이 있는 URL만 허용), 향후 다른 Node.js API에서도 사용될 수 있습니다.</p><h3 id="err_ipc_channel_closed" tabindex="-1"><code>ERR_IPC_CHANNEL_CLOSED</code> <a class="header-anchor" href="#err_ipc_channel_closed" aria-label="Permalink to “ERR_IPC_CHANNEL_CLOSED”">​</a></h3><p>이미 닫힌 IPC 통신 채널을 사용하려고 시도했습니다.</p><h3 id="err_ipc_disconnected" tabindex="-1"><code>ERR_IPC_DISCONNECTED</code> <a class="header-anchor" href="#err_ipc_disconnected" aria-label="Permalink to “ERR_IPC_DISCONNECTED”">​</a></h3><p>이미 연결이 끊어진 IPC 통신 채널의 연결을 끊으려고 시도했습니다. 자세한 내용은 <a href="/ko/nodejs/api/child_process"><code>child_process</code></a> 모듈의 설명서를 참조하세요.</p><h3 id="err_ipc_one_pipe" tabindex="-1"><code>ERR_IPC_ONE_PIPE</code> <a class="header-anchor" href="#err_ipc_one_pipe" aria-label="Permalink to “ERR_IPC_ONE_PIPE”">​</a></h3><p>둘 이상의 IPC 통신 채널을 사용하여 자식 Node.js 프로세스를 만들려고 시도했습니다. 자세한 내용은 <a href="/ko/nodejs/api/child_process"><code>child_process</code></a> 모듈의 설명서를 참조하세요.</p><h3 id="err_ipc_sync_fork" tabindex="-1"><code>ERR_IPC_SYNC_FORK</code> <a class="header-anchor" href="#err_ipc_sync_fork" aria-label="Permalink to “ERR_IPC_SYNC_FORK”">​</a></h3><p>동기적으로 포크된 Node.js 프로세스와 IPC 통신 채널을 열려고 시도했습니다. 자세한 내용은 <a href="/ko/nodejs/api/child_process"><code>child_process</code></a> 모듈 문서를 참조하십시오.</p><h3 id="err_ip_blocked" tabindex="-1"><code>ERR_IP_BLOCKED</code> <a class="header-anchor" href="#err_ip_blocked" aria-label="Permalink to “ERR_IP_BLOCKED”">​</a></h3><p>IP가 <code>net.BlockList</code>에 의해 차단되었습니다.</p><h3 id="err_loader_chain_incomplete" tabindex="-1"><code>ERR_LOADER_CHAIN_INCOMPLETE</code> <a class="header-anchor" href="#err_loader_chain_incomplete" aria-label="Permalink to “ERR_LOADER_CHAIN_INCOMPLETE”">​</a></h3><p><strong>추가된 버전: v18.6.0, v16.17.0</strong></p><p>ESM 로더 후크가 <code>next()</code>를 호출하지 않고 명시적으로 단락을 알리지 않고 반환되었습니다.</p><h3 id="err_load_sqlite_extension" tabindex="-1"><code>ERR_LOAD_SQLITE_EXTENSION</code> <a class="header-anchor" href="#err_load_sqlite_extension" aria-label="Permalink to “ERR_LOAD_SQLITE_EXTENSION”">​</a></h3><p><strong>추가된 버전: v23.5.0</strong></p><p>SQLite 확장 프로그램을 로드하는 동안 오류가 발생했습니다.</p><h3 id="err_memory_allocation_failed" tabindex="-1"><code>ERR_MEMORY_ALLOCATION_FAILED</code> <a class="header-anchor" href="#err_memory_allocation_failed" aria-label="Permalink to “ERR_MEMORY_ALLOCATION_FAILED”">​</a></h3><p>메모리 할당 시도(일반적으로 C++ 레이어에서)가 실패했습니다.</p><h3 id="err_message_target_context_unavailable" tabindex="-1"><code>ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE</code> <a class="header-anchor" href="#err_message_target_context_unavailable" aria-label="Permalink to “ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE”">​</a></h3><p><strong>추가된 버전: v14.5.0, v12.19.0</strong></p><p><a href="/ko/nodejs/api/worker_threads#class-messageport"><code>MessagePort</code></a>로 게시된 메시지를 대상 <a href="/ko/nodejs/api/vm">vm</a> <code>Context</code>에서 역직렬화할 수 없습니다. 모든 Node.js 객체를 현재 모든 컨텍스트에서 성공적으로 인스턴스화할 수 있는 것은 아니며, 이 경우 <code>postMessage()</code>를 사용하여 전송하려고 하면 수신 측에서 실패할 수 있습니다.</p><h3 id="err_method_not_implemented" tabindex="-1"><code>ERR_METHOD_NOT_IMPLEMENTED</code> <a class="header-anchor" href="#err_method_not_implemented" aria-label="Permalink to “ERR_METHOD_NOT_IMPLEMENTED”">​</a></h3><p>메서드가 필요하지만 구현되지 않았습니다.</p><h3 id="err_missing_args" tabindex="-1"><code>ERR_MISSING_ARGS</code> <a class="header-anchor" href="#err_missing_args" aria-label="Permalink to “ERR_MISSING_ARGS”">​</a></h3><p>Node.js API의 필수 인수가 전달되지 않았습니다. 이는 API 사양을 엄격히 준수하기 위해서만 사용됩니다(일부 경우에는 <code>func(undefined)</code>는 허용하지만 <code>func()</code>는 허용하지 않을 수 있음). 대부분의 네이티브 Node.js API에서 <code>func(undefined)</code>와 <code>func()</code>는 동일하게 처리되며, 대신 <a href="/ko/nodejs/api/errors#err-invalid-arg-type"><code>ERR_INVALID_ARG_TYPE</code></a> 오류 코드가 사용될 수 있습니다.</p><h3 id="err_missing_option" tabindex="-1"><code>ERR_MISSING_OPTION</code> <a class="header-anchor" href="#err_missing_option" aria-label="Permalink to “ERR_MISSING_OPTION”">​</a></h3><p>옵션 객체를 허용하는 API의 경우 일부 옵션은 필수일 수 있습니다. 필수 옵션이 누락된 경우 이 코드가 발생합니다.</p><h3 id="err_missing_passphrase" tabindex="-1"><code>ERR_MISSING_PASSPHRASE</code> <a class="header-anchor" href="#err_missing_passphrase" aria-label="Permalink to “ERR_MISSING_PASSPHRASE”">​</a></h3><p>암호 구문을 지정하지 않고 암호화된 키를 읽으려고 시도했습니다.</p><h3 id="err_missing_platform_for_worker" tabindex="-1"><code>ERR_MISSING_PLATFORM_FOR_WORKER</code> <a class="header-anchor" href="#err_missing_platform_for_worker" aria-label="Permalink to “ERR_MISSING_PLATFORM_FOR_WORKER”">​</a></h3><p>이 Node.js 인스턴스에서 사용하는 V8 플랫폼은 Worker 생성을 지원하지 않습니다. 이는 Worker에 대한 임베더 지원 부족으로 인해 발생합니다. 특히 이 오류는 Node.js의 표준 빌드에서는 발생하지 않습니다.</p><h3 id="err_module_not_found" tabindex="-1"><code>ERR_MODULE_NOT_FOUND</code> <a class="header-anchor" href="#err_module_not_found" aria-label="Permalink to “ERR_MODULE_NOT_FOUND”">​</a></h3><p><code>import</code> 작업이나 프로그램 진입점을 로드하는 동안 ECMAScript 모듈 로더가 모듈 파일을 확인할 수 없습니다.</p><h3 id="err_multiple_callback" tabindex="-1"><code>ERR_MULTIPLE_CALLBACK</code> <a class="header-anchor" href="#err_multiple_callback" aria-label="Permalink to “ERR_MULTIPLE_CALLBACK”">​</a></h3><p>콜백이 두 번 이상 호출되었습니다.</p><p>콜백은 쿼리가 충족되거나 거부될 수 있지만 동시에 둘 다 될 수 없으므로 거의 항상 한 번만 호출되도록 되어 있습니다. 후자는 콜백을 두 번 이상 호출하면 가능합니다.</p><h3 id="err_napi_cons_function" tabindex="-1"><code>ERR_NAPI_CONS_FUNCTION</code> <a class="header-anchor" href="#err_napi_cons_function" aria-label="Permalink to “ERR_NAPI_CONS_FUNCTION”">​</a></h3><p><code>Node-API</code>를 사용하는 동안 전달된 생성자가 함수가 아니었습니다.</p><h3 id="err_napi_invalid_dataview_args" tabindex="-1"><code>ERR_NAPI_INVALID_DATAVIEW_ARGS</code> <a class="header-anchor" href="#err_napi_invalid_dataview_args" aria-label="Permalink to “ERR_NAPI_INVALID_DATAVIEW_ARGS”">​</a></h3><p><code>napi_create_dataview()</code>를 호출하는 동안 주어진 <code>offset</code>이 데이터 뷰의 범위를 벗어나거나 <code>offset + length</code>가 주어진 <code>buffer</code>의 길이보다 컸습니다.</p><h3 id="err_napi_invalid_typedarray_alignment" tabindex="-1"><code>ERR_NAPI_INVALID_TYPEDARRAY_ALIGNMENT</code> <a class="header-anchor" href="#err_napi_invalid_typedarray_alignment" aria-label="Permalink to “ERR_NAPI_INVALID_TYPEDARRAY_ALIGNMENT”">​</a></h3><p><code>napi_create_typedarray()</code>를 호출하는 동안 제공된 <code>offset</code>이 요소 크기의 배수가 아니었습니다.</p><h3 id="err_napi_invalid_typedarray_length" tabindex="-1"><code>ERR_NAPI_INVALID_TYPEDARRAY_LENGTH</code> <a class="header-anchor" href="#err_napi_invalid_typedarray_length" aria-label="Permalink to “ERR_NAPI_INVALID_TYPEDARRAY_LENGTH”">​</a></h3><p><code>napi_create_typedarray()</code>를 호출하는 동안 <code>(length * size_of_element) + byte_offset</code>이 주어진 <code>buffer</code>의 길이보다 컸습니다.</p><h3 id="err_napi_tsfn_call_js" tabindex="-1"><code>ERR_NAPI_TSFN_CALL_JS</code> <a class="header-anchor" href="#err_napi_tsfn_call_js" aria-label="Permalink to “ERR_NAPI_TSFN_CALL_JS”">​</a></h3><p>스레드 안전 함수의 JavaScript 부분을 호출하는 동안 오류가 발생했습니다.</p><h3 id="err_napi_tsfn_get_undefined" tabindex="-1"><code>ERR_NAPI_TSFN_GET_UNDEFINED</code> <a class="header-anchor" href="#err_napi_tsfn_get_undefined" aria-label="Permalink to “ERR_NAPI_TSFN_GET_UNDEFINED”">​</a></h3><p>JavaScript <code>undefined</code> 값을 검색하는 동안 오류가 발생했습니다.</p><h3 id="err_non_context_aware_disabled" tabindex="-1"><code>ERR_NON_CONTEXT_AWARE_DISABLED</code> <a class="header-anchor" href="#err_non_context_aware_disabled" aria-label="Permalink to “ERR_NON_CONTEXT_AWARE_DISABLED”">​</a></h3><p>컨텍스트를 인식하지 못하는 네이티브 애드온이 컨텍스트를 허용하지 않는 프로세스에서 로드되었습니다.</p><h3 id="err_not_building_snapshot" tabindex="-1"><code>ERR_NOT_BUILDING_SNAPSHOT</code> <a class="header-anchor" href="#err_not_building_snapshot" aria-label="Permalink to “ERR_NOT_BUILDING_SNAPSHOT”">​</a></h3><p>Node.js가 V8 시작 스냅샷을 빌드하지 않는데도 V8 시작 스냅샷을 빌드할 때만 사용할 수 있는 작업을 사용하려고 시도했습니다.</p><h3 id="err_not_in_single_executable_application" tabindex="-1"><code>ERR_NOT_IN_SINGLE_EXECUTABLE_APPLICATION</code> <a class="header-anchor" href="#err_not_in_single_executable_application" aria-label="Permalink to “ERR_NOT_IN_SINGLE_EXECUTABLE_APPLICATION”">​</a></h3><p><strong>추가된 버전: v21.7.0, v20.12.0</strong></p><p>단일 실행 파일 애플리케이션이 아닌 경우 작업을 수행할 수 없습니다.</p><h3 id="err_not_supported_in_snapshot" tabindex="-1"><code>ERR_NOT_SUPPORTED_IN_SNAPSHOT</code> <a class="header-anchor" href="#err_not_supported_in_snapshot" aria-label="Permalink to “ERR_NOT_SUPPORTED_IN_SNAPSHOT”">​</a></h3><p>시작 스냅샷을 빌드할 때 지원되지 않는 작업을 수행하려고 시도했습니다.</p><h3 id="err_no_crypto" tabindex="-1"><code>ERR_NO_CRYPTO</code> <a class="header-anchor" href="#err_no_crypto" aria-label="Permalink to “ERR_NO_CRYPTO”">​</a></h3><p>Node.js가 OpenSSL 암호화 지원으로 컴파일되지 않았는데도 암호화 기능을 사용하려고 시도했습니다.</p><h3 id="err_no_icu" tabindex="-1"><code>ERR_NO_ICU</code> <a class="header-anchor" href="#err_no_icu" aria-label="Permalink to “ERR_NO_ICU”">​</a></h3><p><a href="/ko/nodejs/api/intl#internationalization-support">ICU</a>를 필요로 하는 기능을 사용하려고 시도했지만 Node.js가 ICU 지원으로 컴파일되지 않았습니다.</p><h3 id="err_no_typescript" tabindex="-1"><code>ERR_NO_TYPESCRIPT</code> <a class="header-anchor" href="#err_no_typescript" aria-label="Permalink to “ERR_NO_TYPESCRIPT”">​</a></h3><p><strong>추가됨: v23.0.0</strong></p><p><a href="/ko/nodejs/api/typescript#type-stripping">네이티브 TypeScript 지원</a>을 필요로 하는 기능을 사용하려고 시도했지만 Node.js가 TypeScript 지원으로 컴파일되지 않았습니다.</p><h3 id="err_operation_failed" tabindex="-1"><code>ERR_OPERATION_FAILED</code> <a class="header-anchor" href="#err_operation_failed" aria-label="Permalink to “ERR_OPERATION_FAILED”">​</a></h3><p><strong>추가됨: v15.0.0</strong></p><p>작업이 실패했습니다. 일반적으로 비동기 작업의 일반적인 실패를 알리는 데 사용됩니다.</p><h3 id="err_out_of_range" tabindex="-1"><code>ERR_OUT_OF_RANGE</code> <a class="header-anchor" href="#err_out_of_range" aria-label="Permalink to “ERR_OUT_OF_RANGE”">​</a></h3><p>주어진 값이 허용된 범위를 벗어났습니다.</p><h3 id="err_package_import_not_defined" tabindex="-1"><code>ERR_PACKAGE_IMPORT_NOT_DEFINED</code> <a class="header-anchor" href="#err_package_import_not_defined" aria-label="Permalink to “ERR_PACKAGE_IMPORT_NOT_DEFINED”">​</a></h3><p><code>package.json</code> <a href="/ko/nodejs/api/packages#imports"><code>&quot;imports&quot;</code></a> 필드에 주어진 내부 패키지 지정자 매핑이 정의되어 있지 않습니다.</p><h3 id="err_package_path_not_exported" tabindex="-1"><code>ERR_PACKAGE_PATH_NOT_EXPORTED</code> <a class="header-anchor" href="#err_package_path_not_exported" aria-label="Permalink to “ERR_PACKAGE_PATH_NOT_EXPORTED”">​</a></h3><p><code>package.json</code> <a href="/ko/nodejs/api/packages#exports"><code>&quot;exports&quot;</code></a> 필드에 요청된 하위 경로가 내보내지지 않았습니다. 내보내기는 캡슐화되어 있기 때문에 절대 URL을 사용하지 않는 한 내보내지지 않은 개인 내부 모듈은 패키지 분석을 통해 가져올 수 없습니다.</p><h3 id="err_parse_args_invalid_option_value" tabindex="-1"><code>ERR_PARSE_ARGS_INVALID_OPTION_VALUE</code> <a class="header-anchor" href="#err_parse_args_invalid_option_value" aria-label="Permalink to “ERR_PARSE_ARGS_INVALID_OPTION_VALUE”">​</a></h3><p><strong>추가됨: v18.3.0, v16.17.0</strong></p><p><code>strict</code>가 <code>true</code>로 설정된 경우, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;문자열&gt;</a> 유형의 옵션에 대해 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" target="_blank" rel="noreferrer">&lt;부울&gt;</a> 값이 제공되거나, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" target="_blank" rel="noreferrer">&lt;부울&gt;</a> 유형의 옵션에 대해 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;문자열&gt;</a> 값이 제공되는 경우 <a href="/ko/nodejs/api/util#utilparseargsconfig"><code>util.parseArgs()</code></a>에 의해 발생합니다.</p><h3 id="err_parse_args_unexpected_positional" tabindex="-1"><code>ERR_PARSE_ARGS_UNEXPECTED_POSITIONAL</code> <a class="header-anchor" href="#err_parse_args_unexpected_positional" aria-label="Permalink to “ERR_PARSE_ARGS_UNEXPECTED_POSITIONAL”">​</a></h3><p><strong>추가됨: v18.3.0, v16.17.0</strong></p><p>위치 인수가 제공되고 <code>allowPositionals</code>가 <code>false</code>로 설정된 경우 <a href="/ko/nodejs/api/util#utilparseargsconfig"><code>util.parseArgs()</code></a>에 의해 발생합니다.</p><h3 id="err_parse_args_unknown_option" tabindex="-1"><code>ERR_PARSE_ARGS_UNKNOWN_OPTION</code> <a class="header-anchor" href="#err_parse_args_unknown_option" aria-label="Permalink to “ERR_PARSE_ARGS_UNKNOWN_OPTION”">​</a></h3><p><strong>추가됨: v18.3.0, v16.17.0</strong></p><p><code>strict</code>가 <code>true</code>로 설정된 경우, <code>options</code>에 인수가 구성되지 않은 경우 <a href="/ko/nodejs/api/util#utilparseargsconfig"><code>util.parseArgs()</code></a>에 의해 발생합니다.</p><h3 id="err_performance_invalid_timestamp" tabindex="-1"><code>ERR_PERFORMANCE_INVALID_TIMESTAMP</code> <a class="header-anchor" href="#err_performance_invalid_timestamp" aria-label="Permalink to “ERR_PERFORMANCE_INVALID_TIMESTAMP”">​</a></h3><p>유효하지 않은 타임스탬프 값이 성능 마크 또는 측정에 제공되었습니다.</p><h3 id="err_performance_measure_invalid_options" tabindex="-1"><code>ERR_PERFORMANCE_MEASURE_INVALID_OPTIONS</code> <a class="header-anchor" href="#err_performance_measure_invalid_options" aria-label="Permalink to “ERR_PERFORMANCE_MEASURE_INVALID_OPTIONS”">​</a></h3><p>유효하지 않은 옵션이 성능 측정에 제공되었습니다.</p><h3 id="err_proto_access" tabindex="-1"><code>ERR_PROTO_ACCESS</code> <a class="header-anchor" href="#err_proto_access" aria-label="Permalink to “ERR_PROTO_ACCESS”">​</a></h3><p><code>Object.prototype.__proto__</code>에 접근하는 것은 <a href="/ko/nodejs/api/cli#disable-protomode"><code>--disable-proto=throw</code></a>를 사용하여 금지되었습니다. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf" target="_blank" rel="noreferrer"><code>Object.getPrototypeOf</code></a> 및 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noreferrer"><code>Object.setPrototypeOf</code></a>는 객체의 프로토타입을 가져오고 설정하는 데 사용해야 합니다.</p><h3 id="err_quic_application_error" tabindex="-1"><code>ERR_QUIC_APPLICATION_ERROR</code> <a class="header-anchor" href="#err_quic_application_error" aria-label="Permalink to “ERR_QUIC_APPLICATION_ERROR”">​</a></h3><p><strong>추가된 버전: v23.4.0</strong></p><div class="warning custom-block"><p class="custom-block-title">[안정성: 1 - 실험적]</p><p><a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a> <a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a> - 실험적</p></div><p>QUIC 애플리케이션 오류가 발생했습니다.</p><h3 id="err_quic_connection_failed" tabindex="-1"><code>ERR_QUIC_CONNECTION_FAILED</code> <a class="header-anchor" href="#err_quic_connection_failed" aria-label="Permalink to “ERR_QUIC_CONNECTION_FAILED”">​</a></h3><p><strong>추가된 버전: v23.0.0</strong></p><div class="warning custom-block"><p class="custom-block-title">[안정성: 1 - 실험적]</p><p><a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a> <a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a> - 실험적</p></div><p>QUIC 연결 설정에 실패했습니다.</p><h3 id="err_quic_endpoint_closed" tabindex="-1"><code>ERR_QUIC_ENDPOINT_CLOSED</code> <a class="header-anchor" href="#err_quic_endpoint_closed" aria-label="Permalink to “ERR_QUIC_ENDPOINT_CLOSED”">​</a></h3><p><strong>추가된 버전: v23.0.0</strong></p><div class="warning custom-block"><p class="custom-block-title">[안정성: 1 - 실험적]</p><p><a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a> <a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a> - 실험적</p></div><p>QUIC 엔드포인트가 오류와 함께 종료되었습니다.</p><h3 id="err_quic_open_stream_failed" tabindex="-1"><code>ERR_QUIC_OPEN_STREAM_FAILED</code> <a class="header-anchor" href="#err_quic_open_stream_failed" aria-label="Permalink to “ERR_QUIC_OPEN_STREAM_FAILED”">​</a></h3><p><strong>추가된 버전: v23.0.0</strong></p><div class="warning custom-block"><p class="custom-block-title">[안정성: 1 - 실험적]</p><p><a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a> <a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a> - 실험적</p></div><p>QUIC 스트림 열기에 실패했습니다.</p><h3 id="err_quic_transport_error" tabindex="-1"><code>ERR_QUIC_TRANSPORT_ERROR</code> <a class="header-anchor" href="#err_quic_transport_error" aria-label="Permalink to “ERR_QUIC_TRANSPORT_ERROR”">​</a></h3><p><strong>추가된 버전: v23.4.0</strong></p><div class="warning custom-block"><p class="custom-block-title">[안정성: 1 - 실험적]</p><p><a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a> <a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a> - 실험적</p></div><p>QUIC 전송 오류가 발생했습니다.</p><h3 id="err_quic_version_negotiation_error" tabindex="-1"><code>ERR_QUIC_VERSION_NEGOTIATION_ERROR</code> <a class="header-anchor" href="#err_quic_version_negotiation_error" aria-label="Permalink to “ERR_QUIC_VERSION_NEGOTIATION_ERROR”">​</a></h3><p><strong>추가된 버전: v23.4.0</strong></p><div class="warning custom-block"><p class="custom-block-title">[안정성: 1 - 실험적]</p><p><a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a> <a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a> - 실험적</p></div><p>버전 협상이 필요하기 때문에 QUIC 세션에 실패했습니다.</p><h3 id="err_require_async_module" tabindex="-1"><code>ERR_REQUIRE_ASYNC_MODULE</code> <a class="header-anchor" href="#err_require_async_module" aria-label="Permalink to “ERR_REQUIRE_ASYNC_MODULE”">​</a></h3><div class="warning custom-block"><p class="custom-block-title">[Stable: 1 - Experimental]</p><p><a href="/ko/nodejs/api/documentation#stability-index">Stable: 1</a> <a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a> - 실험적</p></div><p><a href="/ko/nodejs/api/esm">ES Module</a>을 <code>require()</code>하려고 할 때, 해당 모듈이 비동기인 것으로 밝혀졌습니다. 즉, 최상위 await를 포함합니다.</p><p>최상위 await가 어디에 있는지 확인하려면 <code>--experimental-print-required-tla</code>를 사용하십시오 (최상위 await를 찾기 전에 모듈을 실행합니다).</p><h3 id="err_require_cycle_module" tabindex="-1"><code>ERR_REQUIRE_CYCLE_MODULE</code> <a class="header-anchor" href="#err_require_cycle_module" aria-label="Permalink to “ERR_REQUIRE_CYCLE_MODULE”">​</a></h3><div class="warning custom-block"><p class="custom-block-title">[Stable: 1 - Experimental]</p><p><a href="/ko/nodejs/api/documentation#stability-index">Stable: 1</a> <a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a> - 실험적</p></div><p><a href="/ko/nodejs/api/esm">ES Module</a>을 <code>require()</code>하려고 할 때, CommonJS에서 ESM으로 또는 ESM에서 CommonJS로의 엣지가 즉각적인 순환에 참여합니다. ES 모듈은 이미 평가 중인 동안에는 평가할 수 없으므로 이는 허용되지 않습니다.</p><p>순환을 피하려면 순환에 관련된 <code>require()</code> 호출이 ES 모듈 (via <code>createRequire()</code>) 또는 CommonJS 모듈의 최상위에서 발생하지 않아야 하며 내부 함수에서 지연적으로 수행되어야 합니다.</p><h3 id="err_require_esm" tabindex="-1"><code>ERR_REQUIRE_ESM</code> <a class="header-anchor" href="#err_require_esm" aria-label="Permalink to “ERR_REQUIRE_ESM”">​</a></h3><div class="info custom-block"><p class="custom-block-title">[History]</p><table tabindex="0"><thead><tr><th>Version</th><th>Changes</th></tr></thead><tbody><tr><td>v23.0.0</td><td>require()는 이제 기본적으로 동기 ES 모듈 로드를 지원합니다.</td></tr></tbody></table></div><div class="danger custom-block"><p class="custom-block-title">[Stable: 0 - Deprecated]</p><p><a href="/ko/nodejs/api/documentation#stability-index">Stable: 0</a> <a href="/ko/nodejs/api/documentation#stability-index">안정성: 0</a> - 더 이상 사용되지 않음</p></div><p><a href="/ko/nodejs/api/esm">ES Module</a>을 <code>require()</code>하려는 시도가 있었습니다.</p><p><code>require()</code>가 이제 동기 ES 모듈 로드를 지원하므로 이 오류는 더 이상 사용되지 않습니다. <code>require()</code>가 최상위 <code>await</code>를 포함하는 ES 모듈을 발견하면 대신 <a href="/ko/nodejs/api/errors#err-require-async-module"><code>ERR_REQUIRE_ASYNC_MODULE</code></a>을 발생시킵니다.</p><h3 id="err_script_execution_interrupted" tabindex="-1"><code>ERR_SCRIPT_EXECUTION_INTERRUPTED</code> <a class="header-anchor" href="#err_script_execution_interrupted" aria-label="Permalink to “ERR_SCRIPT_EXECUTION_INTERRUPTED”">​</a></h3><p>스크립트 실행이 <code>SIGINT</code>에 의해 중단되었습니다. (예: + 키를 누름)</p><h3 id="err_script_execution_timeout" tabindex="-1"><code>ERR_SCRIPT_EXECUTION_TIMEOUT</code> <a class="header-anchor" href="#err_script_execution_timeout" aria-label="Permalink to “ERR_SCRIPT_EXECUTION_TIMEOUT”">​</a></h3><p>스크립트 실행 시간이 초과되었습니다. 실행 중인 스크립트에 버그가 있을 수 있습니다.</p><h3 id="err_server_already_listen" tabindex="-1"><code>ERR_SERVER_ALREADY_LISTEN</code> <a class="header-anchor" href="#err_server_already_listen" aria-label="Permalink to “ERR_SERVER_ALREADY_LISTEN”">​</a></h3><p><code>net.Server</code>가 이미 수신 중인 동안 <a href="/ko/nodejs/api/net#serverlisten"><code>server.listen()</code></a> 메서드가 호출되었습니다. 이는 HTTP, HTTPS 및 HTTP/2 <code>Server</code> 인스턴스를 포함한 <code>net.Server</code>의 모든 인스턴스에 적용됩니다.</p><h3 id="err_server_not_running" tabindex="-1"><code>ERR_SERVER_NOT_RUNNING</code> <a class="header-anchor" href="#err_server_not_running" aria-label="Permalink to “ERR_SERVER_NOT_RUNNING”">​</a></h3><p><code>net.Server</code>가 실행되고 있지 않을 때 <a href="/ko/nodejs/api/net#serverclosecallback"><code>server.close()</code></a> 메서드가 호출되었습니다. 이는 HTTP, HTTPS 및 HTTP/2 <code>Server</code> 인스턴스를 포함한 모든 <code>net.Server</code> 인스턴스에 적용됩니다.</p><h3 id="err_single_executable_application_asset_not_found" tabindex="-1"><code>ERR_SINGLE_EXECUTABLE_APPLICATION_ASSET_NOT_FOUND</code> <a class="header-anchor" href="#err_single_executable_application_asset_not_found" aria-label="Permalink to “ERR_SINGLE_EXECUTABLE_APPLICATION_ASSET_NOT_FOUND”">​</a></h3><p><strong>다음 버전부터 추가됨: v21.7.0, v20.12.0</strong></p><p>단일 실행 파일 애플리케이션 API에 자산을 식별하기 위한 키가 전달되었지만 일치하는 항목을 찾을 수 없습니다.</p><h3 id="err_socket_already_bound" tabindex="-1"><code>ERR_SOCKET_ALREADY_BOUND</code> <a class="header-anchor" href="#err_socket_already_bound" aria-label="Permalink to “ERR_SOCKET_ALREADY_BOUND”">​</a></h3><p>이미 바인딩된 소켓을 바인딩하려는 시도가 있었습니다.</p><h3 id="err_socket_bad_buffer_size" tabindex="-1"><code>ERR_SOCKET_BAD_BUFFER_SIZE</code> <a class="header-anchor" href="#err_socket_bad_buffer_size" aria-label="Permalink to “ERR_SOCKET_BAD_BUFFER_SIZE”">​</a></h3><p><a href="/ko/nodejs/api/dgram#dgramcreatesocketoptions-callback"><code>dgram.createSocket()</code></a>에서 <code>recvBufferSize</code> 또는 <code>sendBufferSize</code> 옵션에 유효하지 않은 (음수) 크기가 전달되었습니다.</p><h3 id="err_socket_bad_port" tabindex="-1"><code>ERR_SOCKET_BAD_PORT</code> <a class="header-anchor" href="#err_socket_bad_port" aria-label="Permalink to “ERR_SOCKET_BAD_PORT”">​</a></h3><p>&gt;= 0 및 &lt; 65536 포트를 예상하는 API 함수가 유효하지 않은 값을 받았습니다.</p><h3 id="err_socket_bad_type" tabindex="-1"><code>ERR_SOCKET_BAD_TYPE</code> <a class="header-anchor" href="#err_socket_bad_type" aria-label="Permalink to “ERR_SOCKET_BAD_TYPE”">​</a></h3><p>소켓 유형(<code>udp4</code> 또는 <code>udp6</code>)을 예상하는 API 함수가 유효하지 않은 값을 받았습니다.</p><h3 id="err_socket_buffer_size" tabindex="-1"><code>ERR_SOCKET_BUFFER_SIZE</code> <a class="header-anchor" href="#err_socket_buffer_size" aria-label="Permalink to “ERR_SOCKET_BUFFER_SIZE”">​</a></h3><p><a href="/ko/nodejs/api/dgram#dgramcreatesocketoptions-callback"><code>dgram.createSocket()</code></a>를 사용하는 동안 수신 또는 송신 <code>Buffer</code>의 크기를 확인할 수 없습니다.</p><h3 id="err_socket_closed" tabindex="-1"><code>ERR_SOCKET_CLOSED</code> <a class="header-anchor" href="#err_socket_closed" aria-label="Permalink to “ERR_SOCKET_CLOSED”">​</a></h3><p>이미 닫힌 소켓에서 작업을 시도했습니다.</p><h3 id="err_socket_closed_before_connection" tabindex="-1"><code>ERR_SOCKET_CLOSED_BEFORE_CONNECTION</code> <a class="header-anchor" href="#err_socket_closed_before_connection" aria-label="Permalink to “ERR_SOCKET_CLOSED_BEFORE_CONNECTION”">​</a></h3><p>연결 중인 소켓에서 <a href="/ko/nodejs/api/net#socketwritedata-encoding-callback"><code>net.Socket.write()</code></a>를 호출하고 연결이 설정되기 전에 소켓이 닫혔습니다.</p><h3 id="err_socket_connection_timeout" tabindex="-1"><code>ERR_SOCKET_CONNECTION_TIMEOUT</code> <a class="header-anchor" href="#err_socket_connection_timeout" aria-label="Permalink to “ERR_SOCKET_CONNECTION_TIMEOUT”">​</a></h3><p>소켓이 패밀리 자동 선택 알고리즘을 사용할 때 허용된 시간 초과 내에 DNS에서 반환된 주소에 연결할 수 없습니다.</p><h3 id="err_socket_dgram_is_connected" tabindex="-1"><code>ERR_SOCKET_DGRAM_IS_CONNECTED</code> <a class="header-anchor" href="#err_socket_dgram_is_connected" aria-label="Permalink to “ERR_SOCKET_DGRAM_IS_CONNECTED”">​</a></h3><p>이미 연결된 소켓에서 <a href="/ko/nodejs/api/dgram#socketconnectport-address-callback"><code>dgram.connect()</code></a> 호출이 이루어졌습니다.</p><h3 id="err_socket_dgram_not_connected" tabindex="-1"><code>ERR_SOCKET_DGRAM_NOT_CONNECTED</code> <a class="header-anchor" href="#err_socket_dgram_not_connected" aria-label="Permalink to “ERR_SOCKET_DGRAM_NOT_CONNECTED”">​</a></h3><p>연결이 끊긴 소켓에서 <a href="/ko/nodejs/api/dgram#socketdisconnect"><code>dgram.disconnect()</code></a> 또는 <a href="/ko/nodejs/api/dgram#socketremoteaddress"><code>dgram.remoteAddress()</code></a> 호출이 이루어졌습니다.</p><h3 id="err_socket_dgram_not_running" tabindex="-1"><code>ERR_SOCKET_DGRAM_NOT_RUNNING</code> <a class="header-anchor" href="#err_socket_dgram_not_running" aria-label="Permalink to “ERR_SOCKET_DGRAM_NOT_RUNNING”">​</a></h3><p>호출이 이루어졌지만 UDP 서브시스템이 실행되고 있지 않습니다.</p><h3 id="err_source_map_corrupt" tabindex="-1"><code>ERR_SOURCE_MAP_CORRUPT</code> <a class="header-anchor" href="#err_source_map_corrupt" aria-label="Permalink to “ERR_SOURCE_MAP_CORRUPT”">​</a></h3><p>소스 맵이 존재하지 않거나 손상되어 구문 분석할 수 없습니다.</p><h3 id="err_source_map_missing_source" tabindex="-1"><code>ERR_SOURCE_MAP_MISSING_SOURCE</code> <a class="header-anchor" href="#err_source_map_missing_source" aria-label="Permalink to “ERR_SOURCE_MAP_MISSING_SOURCE”">​</a></h3><p>소스 맵에서 가져온 파일을 찾을 수 없습니다.</p><h3 id="err_sqlite_error" tabindex="-1"><code>ERR_SQLITE_ERROR</code> <a class="header-anchor" href="#err_sqlite_error" aria-label="Permalink to “ERR_SQLITE_ERROR”">​</a></h3><p><strong>추가된 버전: v22.5.0</strong></p><p><a href="/ko/nodejs/api/sqlite">SQLite</a>에서 오류가 반환되었습니다.</p><h3 id="err_sri_parse" tabindex="-1"><code>ERR_SRI_PARSE</code> <a class="header-anchor" href="#err_sri_parse" aria-label="Permalink to “ERR_SRI_PARSE”">​</a></h3><p>Subresource Integrity 검사를 위해 문자열이 제공되었지만 구문 분석할 수 없었습니다. <a href="https://www.w3.org/TR/SRI/#the-integrity-attribute" target="_blank" rel="noreferrer">Subresource Integrity 사양</a>을 참조하여 integrity 속성의 형식을 확인하십시오.</p><h3 id="err_stream_already_finished" tabindex="-1"><code>ERR_STREAM_ALREADY_FINISHED</code> <a class="header-anchor" href="#err_stream_already_finished" aria-label="Permalink to “ERR_STREAM_ALREADY_FINISHED”">​</a></h3><p>스트림이 완료되었기 때문에 완료할 수 없는 스트림 메서드가 호출되었습니다.</p><h3 id="err_stream_cannot_pipe" tabindex="-1"><code>ERR_STREAM_CANNOT_PIPE</code> <a class="header-anchor" href="#err_stream_cannot_pipe" aria-label="Permalink to “ERR_STREAM_CANNOT_PIPE”">​</a></h3><p><a href="/ko/nodejs/api/stream#class-streamwritable"><code>Writable</code></a> 스트림에서 <a href="/ko/nodejs/api/stream#readablepipedestination-options"><code>stream.pipe()</code></a>를 호출하려고 시도했습니다.</p><h3 id="err_stream_destroyed" tabindex="-1"><code>ERR_STREAM_DESTROYED</code> <a class="header-anchor" href="#err_stream_destroyed" aria-label="Permalink to “ERR_STREAM_DESTROYED”">​</a></h3><p><code>stream.destroy()</code>를 사용하여 스트림이 파괴되었기 때문에 완료할 수 없는 스트림 메서드가 호출되었습니다.</p><h3 id="err_stream_null_values" tabindex="-1"><code>ERR_STREAM_NULL_VALUES</code> <a class="header-anchor" href="#err_stream_null_values" aria-label="Permalink to “ERR_STREAM_NULL_VALUES”">​</a></h3><p><code>null</code> 청크로 <a href="/ko/nodejs/api/stream#writablewritechunk-encoding-callback"><code>stream.write()</code></a>를 호출하려고 시도했습니다.</p><h3 id="err_stream_premature_close" tabindex="-1"><code>ERR_STREAM_PREMATURE_CLOSE</code> <a class="header-anchor" href="#err_stream_premature_close" aria-label="Permalink to “ERR_STREAM_PREMATURE_CLOSE”">​</a></h3><p>스트림 또는 파이프라인이 명시적인 오류 없이 정상적으로 종료되지 않을 때 <code>stream.finished()</code> 및 <code>stream.pipeline()</code>에서 반환되는 오류입니다.</p><h3 id="err_stream_push_after_eof" tabindex="-1"><code>ERR_STREAM_PUSH_AFTER_EOF</code> <a class="header-anchor" href="#err_stream_push_after_eof" aria-label="Permalink to “ERR_STREAM_PUSH_AFTER_EOF”">​</a></h3><p>스트림에 <code>null</code>(EOF)이 푸시된 후 <a href="/ko/nodejs/api/stream#readablepushchunk-encoding"><code>stream.push()</code></a>를 호출하려고 시도했습니다.</p><h3 id="err_stream_unable_to_pipe" tabindex="-1"><code>ERR_STREAM_UNABLE_TO_PIPE</code> <a class="header-anchor" href="#err_stream_unable_to_pipe" aria-label="Permalink to “ERR_STREAM_UNABLE_TO_PIPE”">​</a></h3><p>파이프라인에서 닫히거나 파괴된 스트림으로 파이프하려고 시도했습니다.</p><h3 id="err_stream_unshift_after_end_event" tabindex="-1"><code>ERR_STREAM_UNSHIFT_AFTER_END_EVENT</code> <a class="header-anchor" href="#err_stream_unshift_after_end_event" aria-label="Permalink to “ERR_STREAM_UNSHIFT_AFTER_END_EVENT”">​</a></h3><p><code>&#39;end&#39;</code> 이벤트가 발생한 후 <a href="/ko/nodejs/api/stream#readableunshiftchunk-encoding"><code>stream.unshift()</code></a>를 호출하려고 시도했습니다.</p><h3 id="err_stream_wrap" tabindex="-1"><code>ERR_STREAM_WRAP</code> <a class="header-anchor" href="#err_stream_wrap" aria-label="Permalink to “ERR_STREAM_WRAP”">​</a></h3><p>Socket에 문자열 디코더가 설정되었거나 디코더가 <code>objectMode</code>에 있는 경우 중단을 방지합니다.</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Socket</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;node:net&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).Socket;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> instance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Socket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">instance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setEncoding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;utf8&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="err_stream_write_after_end" tabindex="-1"><code>ERR_STREAM_WRITE_AFTER_END</code> <a class="header-anchor" href="#err_stream_write_after_end" aria-label="Permalink to “ERR_STREAM_WRITE_AFTER_END”">​</a></h3><p><code>stream.end()</code>가 호출된 후 <a href="/ko/nodejs/api/stream#writablewritechunk-encoding-callback"><code>stream.write()</code></a>를 호출하려는 시도가 있었습니다.</p><h3 id="err_string_too_long" tabindex="-1"><code>ERR_STRING_TOO_LONG</code> <a class="header-anchor" href="#err_string_too_long" aria-label="Permalink to “ERR_STRING_TOO_LONG”">​</a></h3><p>허용된 최대 길이보다 긴 문자열을 생성하려는 시도가 있었습니다.</p><h3 id="err_synthetic" tabindex="-1"><code>ERR_SYNTHETIC</code> <a class="header-anchor" href="#err_synthetic" aria-label="Permalink to “ERR_SYNTHETIC”">​</a></h3><p>진단 보고서를 위해 호출 스택을 캡처하는 데 사용되는 인공 오류 객체입니다.</p><h3 id="err_system_error" tabindex="-1"><code>ERR_SYSTEM_ERROR</code> <a class="header-anchor" href="#err_system_error" aria-label="Permalink to “ERR_SYSTEM_ERROR”">​</a></h3><p>Node.js 프로세스 내에서 지정되지 않았거나 구체적이지 않은 시스템 오류가 발생했습니다. 오류 객체에는 추가 정보가 포함된 <code>err.info</code> 객체 속성이 있습니다.</p><h3 id="err_tap_lexer_error" tabindex="-1"><code>ERR_TAP_LEXER_ERROR</code> <a class="header-anchor" href="#err_tap_lexer_error" aria-label="Permalink to “ERR_TAP_LEXER_ERROR”">​</a></h3><p>실패한 렉서 상태를 나타내는 오류입니다.</p><h3 id="err_tap_parser_error" tabindex="-1"><code>ERR_TAP_PARSER_ERROR</code> <a class="header-anchor" href="#err_tap_parser_error" aria-label="Permalink to “ERR_TAP_PARSER_ERROR”">​</a></h3><p>실패한 파서 상태를 나타내는 오류입니다. 오류를 유발한 토큰에 대한 추가 정보는 <code>cause</code> 속성을 통해 사용할 수 있습니다.</p><h3 id="err_tap_validation_error" tabindex="-1"><code>ERR_TAP_VALIDATION_ERROR</code> <a class="header-anchor" href="#err_tap_validation_error" aria-label="Permalink to “ERR_TAP_VALIDATION_ERROR”">​</a></h3><p>이 오류는 실패한 TAP 유효성 검사를 나타냅니다.</p><h3 id="err_test_failure" tabindex="-1"><code>ERR_TEST_FAILURE</code> <a class="header-anchor" href="#err_test_failure" aria-label="Permalink to “ERR_TEST_FAILURE”">​</a></h3><p>이 오류는 실패한 테스트를 나타냅니다. 실패에 대한 추가 정보는 <code>cause</code> 속성을 통해 사용할 수 있습니다. <code>failureType</code> 속성은 실패가 발생했을 때 테스트가 무엇을 하고 있었는지 지정합니다.</p><h3 id="err_tls_alpn_callback_invalid_result" tabindex="-1"><code>ERR_TLS_ALPN_CALLBACK_INVALID_RESULT</code> <a class="header-anchor" href="#err_tls_alpn_callback_invalid_result" aria-label="Permalink to “ERR_TLS_ALPN_CALLBACK_INVALID_RESULT”">​</a></h3><p>이 오류는 <code>ALPNCallback</code>이 클라이언트가 제공한 ALPN 프로토콜 목록에 없는 값을 반환할 때 발생합니다.</p><h3 id="err_tls_alpn_callback_with_protocols" tabindex="-1"><code>ERR_TLS_ALPN_CALLBACK_WITH_PROTOCOLS</code> <a class="header-anchor" href="#err_tls_alpn_callback_with_protocols" aria-label="Permalink to “ERR_TLS_ALPN_CALLBACK_WITH_PROTOCOLS”">​</a></h3><p>이 오류는 TLS 옵션에 <code>ALPNProtocols</code>와 <code>ALPNCallback</code>이 모두 포함된 경우 <code>TLSServer</code>를 생성할 때 발생합니다. 이러한 옵션은 상호 배타적입니다.</p><h3 id="err_tls_cert_altname_format" tabindex="-1"><code>ERR_TLS_CERT_ALTNAME_FORMAT</code> <a class="header-anchor" href="#err_tls_cert_altname_format" aria-label="Permalink to “ERR_TLS_CERT_ALTNAME_FORMAT”">​</a></h3><p>이 오류는 사용자 제공 <code>subjectaltname</code> 속성이 인코딩 규칙을 위반하는 경우 <code>checkServerIdentity</code>에 의해 발생합니다. Node.js 자체에서 생성된 인증서 객체는 항상 인코딩 규칙을 준수하므로 이 오류가 발생하지 않습니다.</p><h3 id="err_tls_cert_altname_invalid" tabindex="-1"><code>ERR_TLS_CERT_ALTNAME_INVALID</code> <a class="header-anchor" href="#err_tls_cert_altname_invalid" aria-label="Permalink to “ERR_TLS_CERT_ALTNAME_INVALID”">​</a></h3><p>TLS를 사용하는 동안 피어의 호스트 이름/IP가 인증서의 <code>subjectAltNames</code>와 일치하지 않았습니다.</p><h3 id="err_tls_dh_param_size" tabindex="-1"><code>ERR_TLS_DH_PARAM_SIZE</code> <a class="header-anchor" href="#err_tls_dh_param_size" aria-label="Permalink to “ERR_TLS_DH_PARAM_SIZE”">​</a></h3><p>TLS를 사용하는 동안 Diffie-Hellman(<code>DH</code>) 키 합의 프로토콜에 제공된 매개변수가 너무 작습니다. 기본적으로 키 길이는 취약점을 방지하기 위해 1024비트 이상이어야 하지만 더 강력한 보안을 위해 2048비트 이상을 사용하는 것이 좋습니다.</p><h3 id="err_tls_handshake_timeout" tabindex="-1"><code>ERR_TLS_HANDSHAKE_TIMEOUT</code> <a class="header-anchor" href="#err_tls_handshake_timeout" aria-label="Permalink to “ERR_TLS_HANDSHAKE_TIMEOUT”">​</a></h3><p>TLS/SSL 핸드셰이크 시간이 초과되었습니다. 이 경우 서버도 연결을 중단해야 합니다.</p><h3 id="err_tls_invalid_context" tabindex="-1"><code>ERR_TLS_INVALID_CONTEXT</code> <a class="header-anchor" href="#err_tls_invalid_context" aria-label="Permalink to “ERR_TLS_INVALID_CONTEXT”">​</a></h3><p><strong>Added in: v13.3.0</strong></p><p>컨텍스트는 <code>SecureContext</code>여야 합니다.</p><h3 id="err_tls_invalid_protocol_method" tabindex="-1"><code>ERR_TLS_INVALID_PROTOCOL_METHOD</code> <a class="header-anchor" href="#err_tls_invalid_protocol_method" aria-label="Permalink to “ERR_TLS_INVALID_PROTOCOL_METHOD”">​</a></h3><p>지정된 <code>secureProtocol</code> 메서드가 유효하지 않습니다. 알 수 없거나 보안에 취약하여 비활성화되었습니다.</p><h3 id="err_tls_invalid_protocol_version" tabindex="-1"><code>ERR_TLS_INVALID_PROTOCOL_VERSION</code> <a class="header-anchor" href="#err_tls_invalid_protocol_version" aria-label="Permalink to “ERR_TLS_INVALID_PROTOCOL_VERSION”">​</a></h3><p>유효한 TLS 프로토콜 버전은 <code>&#39;TLSv1&#39;</code>, <code>&#39;TLSv1.1&#39;</code>, 또는 <code>&#39;TLSv1.2&#39;</code>입니다.</p><h3 id="err_tls_invalid_state" tabindex="-1"><code>ERR_TLS_INVALID_STATE</code> <a class="header-anchor" href="#err_tls_invalid_state" aria-label="Permalink to “ERR_TLS_INVALID_STATE”">​</a></h3><p><strong>Added in: v13.10.0, v12.17.0</strong></p><p>TLS 소켓이 연결되어 보안이 설정되어야 합니다. 계속하기 전에 &#39;secure&#39; 이벤트가 발생하는지 확인하십시오.</p><h3 id="err_tls_protocol_version_conflict" tabindex="-1"><code>ERR_TLS_PROTOCOL_VERSION_CONFLICT</code> <a class="header-anchor" href="#err_tls_protocol_version_conflict" aria-label="Permalink to “ERR_TLS_PROTOCOL_VERSION_CONFLICT”">​</a></h3><p>TLS 프로토콜 <code>minVersion</code> 또는 <code>maxVersion</code>을 설정하려는 시도가 <code>secureProtocol</code>을 명시적으로 설정하려는 시도와 충돌합니다. 하나의 메커니즘만 사용하십시오.</p><h3 id="err_tls_psk_set_identity_hint_failed" tabindex="-1"><code>ERR_TLS_PSK_SET_IDENTITY_HINT_FAILED</code> <a class="header-anchor" href="#err_tls_psk_set_identity_hint_failed" aria-label="Permalink to “ERR_TLS_PSK_SET_IDENTITY_HINT_FAILED”">​</a></h3><p>PSK ID 힌트 설정에 실패했습니다. 힌트가 너무 길 수 있습니다.</p><h3 id="err_tls_renegotiation_disabled" tabindex="-1"><code>ERR_TLS_RENEGOTIATION_DISABLED</code> <a class="header-anchor" href="#err_tls_renegotiation_disabled" aria-label="Permalink to “ERR_TLS_RENEGOTIATION_DISABLED”">​</a></h3><p>재협상이 비활성화된 소켓 인스턴스에서 TLS를 재협상하려는 시도가 있었습니다.</p><h3 id="err_tls_required_server_name" tabindex="-1"><code>ERR_TLS_REQUIRED_SERVER_NAME</code> <a class="header-anchor" href="#err_tls_required_server_name" aria-label="Permalink to “ERR_TLS_REQUIRED_SERVER_NAME”">​</a></h3><p>TLS를 사용하는 동안 <code>server.addContext()</code> 메서드가 첫 번째 매개변수에 호스트 이름을 제공하지 않고 호출되었습니다.</p><h3 id="err_tls_session_attack" tabindex="-1"><code>ERR_TLS_SESSION_ATTACK</code> <a class="header-anchor" href="#err_tls_session_attack" aria-label="Permalink to “ERR_TLS_SESSION_ATTACK”">​</a></h3><p>과도한 양의 TLS 재협상이 감지되었으며, 이는 서비스 거부 공격의 잠재적인 벡터입니다.</p><h3 id="err_tls_sni_from_server" tabindex="-1"><code>ERR_TLS_SNI_FROM_SERVER</code> <a class="header-anchor" href="#err_tls_sni_from_server" aria-label="Permalink to “ERR_TLS_SNI_FROM_SERVER”">​</a></h3><p>TLS 서버 측 소켓에서 서버 이름 표시를 발행하려는 시도가 있었습니다. 이는 클라이언트에서만 유효합니다.</p><h3 id="err_trace_events_category_required" tabindex="-1"><code>ERR_TRACE_EVENTS_CATEGORY_REQUIRED</code> <a class="header-anchor" href="#err_trace_events_category_required" aria-label="Permalink to “ERR_TRACE_EVENTS_CATEGORY_REQUIRED”">​</a></h3><p><code>trace_events.createTracing()</code> 메서드에는 하나 이상의 추적 이벤트 범주가 필요합니다.</p><h3 id="err_trace_events_unavailable" tabindex="-1"><code>ERR_TRACE_EVENTS_UNAVAILABLE</code> <a class="header-anchor" href="#err_trace_events_unavailable" aria-label="Permalink to “ERR_TRACE_EVENTS_UNAVAILABLE”">​</a></h3><p>Node.js가 <code>--without-v8-platform</code> 플래그로 컴파일되었기 때문에 <code>node:trace_events</code> 모듈을 로드할 수 없습니다.</p><h3 id="err_transform_already_transforming" tabindex="-1"><code>ERR_TRANSFORM_ALREADY_TRANSFORMING</code> <a class="header-anchor" href="#err_transform_already_transforming" aria-label="Permalink to “ERR_TRANSFORM_ALREADY_TRANSFORMING”">​</a></h3><p><code>Transform</code> 스트림이 변환 중인 동안 완료되었습니다.</p><h3 id="err_transform_with_length_0" tabindex="-1"><code>ERR_TRANSFORM_WITH_LENGTH_0</code> <a class="header-anchor" href="#err_transform_with_length_0" aria-label="Permalink to “ERR_TRANSFORM_WITH_LENGTH_0”">​</a></h3><p><code>Transform</code> 스트림이 쓰기 버퍼에 데이터가 남아 있는 상태로 완료되었습니다.</p><h3 id="err_tty_init_failed" tabindex="-1"><code>ERR_TTY_INIT_FAILED</code> <a class="header-anchor" href="#err_tty_init_failed" aria-label="Permalink to “ERR_TTY_INIT_FAILED”">​</a></h3><p>시스템 오류로 인해 TTY 초기화에 실패했습니다.</p><h3 id="err_unavailable_during_exit" tabindex="-1"><code>ERR_UNAVAILABLE_DURING_EXIT</code> <a class="header-anchor" href="#err_unavailable_during_exit" aria-label="Permalink to “ERR_UNAVAILABLE_DURING_EXIT”">​</a></h3><p><a href="/ko/nodejs/api/process#event-exit"><code>process.on(&#39;exit&#39;)</code></a> 핸들러 내에서 호출되어서는 안 되는 함수가 <a href="/ko/nodejs/api/process#event-exit"><code>process.on(&#39;exit&#39;)</code></a> 핸들러 내에서 호출되었습니다.</p><h3 id="err_uncaught_exception_capture_already_set" tabindex="-1"><code>ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET</code> <a class="header-anchor" href="#err_uncaught_exception_capture_already_set" aria-label="Permalink to “ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET”">​</a></h3><p><a href="/ko/nodejs/api/process#processsetuncaughtexceptioncapturecallbackfn"><code>process.setUncaughtExceptionCaptureCallback()</code></a>이 콜백을 먼저 <code>null</code>로 재설정하지 않고 두 번 호출되었습니다.</p><p>이 오류는 다른 모듈에서 등록된 콜백을 실수로 덮어쓰는 것을 방지하기 위해 설계되었습니다.</p><h3 id="err_unescaped_characters" tabindex="-1"><code>ERR_UNESCAPED_CHARACTERS</code> <a class="header-anchor" href="#err_unescaped_characters" aria-label="Permalink to “ERR_UNESCAPED_CHARACTERS”">​</a></h3><p>이스케이프되지 않은 문자가 포함된 문자열이 수신되었습니다.</p><h3 id="err_unhandled_error" tabindex="-1"><code>ERR_UNHANDLED_ERROR</code> <a class="header-anchor" href="#err_unhandled_error" aria-label="Permalink to “ERR_UNHANDLED_ERROR”">​</a></h3><p>처리되지 않은 오류가 발생했습니다 (예: <a href="/ko/nodejs/api/events#class-eventemitter"><code>EventEmitter</code></a>에서 <code>&#39;error&#39;</code> 이벤트가 발생했지만 <code>&#39;error&#39;</code> 핸들러가 등록되지 않은 경우).</p><h3 id="err_unknown_builtin_module" tabindex="-1"><code>ERR_UNKNOWN_BUILTIN_MODULE</code> <a class="header-anchor" href="#err_unknown_builtin_module" aria-label="Permalink to “ERR_UNKNOWN_BUILTIN_MODULE”">​</a></h3><p>일반적으로 사용자 코드로 인해 트리거되어서는 안 되는 특정 종류의 내부 Node.js 오류를 식별하는 데 사용됩니다. 이 오류의 인스턴스는 Node.js 바이너리 자체 내의 내부 버그를 가리킵니다.</p><h3 id="err_unknown_credential" tabindex="-1"><code>ERR_UNKNOWN_CREDENTIAL</code> <a class="header-anchor" href="#err_unknown_credential" aria-label="Permalink to “ERR_UNKNOWN_CREDENTIAL”">​</a></h3><p>존재하지 않는 Unix 그룹 또는 사용자 식별자가 전달되었습니다.</p><h3 id="err_unknown_encoding" tabindex="-1"><code>ERR_UNKNOWN_ENCODING</code> <a class="header-anchor" href="#err_unknown_encoding" aria-label="Permalink to “ERR_UNKNOWN_ENCODING”">​</a></h3><p>API에 잘못되었거나 알 수 없는 인코딩 옵션이 전달되었습니다.</p><h3 id="err_unknown_file_extension" tabindex="-1"><code>ERR_UNKNOWN_FILE_EXTENSION</code> <a class="header-anchor" href="#err_unknown_file_extension" aria-label="Permalink to “ERR_UNKNOWN_FILE_EXTENSION”">​</a></h3><div class="warning custom-block"><p class="custom-block-title">[안정성: 1 - 실험적]</p><p><a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a> <a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a> - 실험적</p></div><p>알 수 없거나 지원되지 않는 파일 확장명을 가진 모듈을 로드하려고 했습니다.</p><h3 id="err_unknown_module_format" tabindex="-1"><code>ERR_UNKNOWN_MODULE_FORMAT</code> <a class="header-anchor" href="#err_unknown_module_format" aria-label="Permalink to “ERR_UNKNOWN_MODULE_FORMAT”">​</a></h3><div class="warning custom-block"><p class="custom-block-title">[안정성: 1 - 실험적]</p><p><a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a> <a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a> - 실험적</p></div><p>알 수 없거나 지원되지 않는 형식을 가진 모듈을 로드하려고 했습니다.</p><h3 id="err_unknown_signal" tabindex="-1"><code>ERR_UNKNOWN_SIGNAL</code> <a class="header-anchor" href="#err_unknown_signal" aria-label="Permalink to “ERR_UNKNOWN_SIGNAL”">​</a></h3><p>유효한 신호를 기대하는 API (예: <a href="/ko/nodejs/api/child_process#subprocesskillsignal"><code>subprocess.kill()</code></a>)에 잘못되었거나 알 수 없는 프로세스 신호가 전달되었습니다.</p><h3 id="err_unsupported_dir_import" tabindex="-1"><code>ERR_UNSUPPORTED_DIR_IMPORT</code> <a class="header-anchor" href="#err_unsupported_dir_import" aria-label="Permalink to “ERR_UNSUPPORTED_DIR_IMPORT”">​</a></h3><p>디렉터리 URL을 <code>import</code>하는 것은 지원되지 않습니다. 대신, <a href="/ko/nodejs/api/packages#self-referencing-a-package-using-its-name">이름을 사용하여 패키지를 자체 참조</a>하고 <a href="/ko/nodejs/api/packages#nodejs-packagejson-field-definitions"><code>package.json</code></a> 파일의 <a href="/ko/nodejs/api/packages#exports"><code>&quot;exports&quot;</code></a> 필드에서 <a href="/ko/nodejs/api/packages#subpath-exports">사용자 정의 하위 경로를 정의</a>하세요.</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 지원되지 않음</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./index.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 지원됨</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;package-name&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 지원됨</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="err_unsupported_esm_url_scheme" tabindex="-1"><code>ERR_UNSUPPORTED_ESM_URL_SCHEME</code> <a class="header-anchor" href="#err_unsupported_esm_url_scheme" aria-label="Permalink to “ERR_UNSUPPORTED_ESM_URL_SCHEME”">​</a></h3><p><code>file</code> 및 <code>data</code> 이외의 URL 체계를 사용하는 <code>import</code>는 지원되지 않습니다.</p><h3 id="err_unsupported_node_modules_type_stripping" tabindex="-1"><code>ERR_UNSUPPORTED_NODE_MODULES_TYPE_STRIPPING</code> <a class="header-anchor" href="#err_unsupported_node_modules_type_stripping" aria-label="Permalink to “ERR_UNSUPPORTED_NODE_MODULES_TYPE_STRIPPING”">​</a></h3><p><strong>추가됨: v22.6.0</strong></p><p>타입 제거는 <code>node_modules</code> 디렉터리의 하위 파일에 대해 지원되지 않습니다.</p><h3 id="err_unsupported_resolve_request" tabindex="-1"><code>ERR_UNSUPPORTED_RESOLVE_REQUEST</code> <a class="header-anchor" href="#err_unsupported_resolve_request" aria-label="Permalink to “ERR_UNSUPPORTED_RESOLVE_REQUEST”">​</a></h3><p>잘못된 모듈 참조자를 확인하려는 시도가 있었습니다. 이는 다음 중 하나를 사용하여 <code>import</code>하거나 <code>import.meta.resolve()</code>를 호출할 때 발생할 수 있습니다.</p><ul><li>URL 체계가 <code>file</code>이 아닌 모듈에서 빌트인 모듈이 아닌 베어 스펙 지정자.</li><li>URL 체계가 <a href="https://url.spec.whatwg.org/#special-scheme" target="_blank" rel="noreferrer">특수 체계</a>가 아닌 모듈의 <a href="https://url.spec.whatwg.org/#relative-url-string" target="_blank" rel="noreferrer">상대 URL</a>.</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // \`data:\` URL 모듈에서 &#39;bare-specifier&#39; 패키지를 import하려고 합니다.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  await</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;data:text/javascript,import &quot;bare-specifier&quot;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (e) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e.code); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ERR_UNSUPPORTED_RESOLVE_REQUEST</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="err_use_after_close" tabindex="-1"><code>ERR_USE_AFTER_CLOSE</code> <a class="header-anchor" href="#err_use_after_close" aria-label="Permalink to “ERR_USE_AFTER_CLOSE”">​</a></h3><div class="warning custom-block"><p class="custom-block-title">[안정성: 1 - 실험적]</p><p><a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a> <a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a> - 실험적</p></div><p>이미 닫힌 것을 사용하려는 시도가 있었습니다.</p><h3 id="err_valid_performance_entry_type" tabindex="-1"><code>ERR_VALID_PERFORMANCE_ENTRY_TYPE</code> <a class="header-anchor" href="#err_valid_performance_entry_type" aria-label="Permalink to “ERR_VALID_PERFORMANCE_ENTRY_TYPE”">​</a></h3><p>Performance Timing API(<code>perf_hooks</code>)를 사용하는 동안 유효한 성능 항목 유형이 발견되지 않았습니다.</p><h3 id="err_vm_dynamic_import_callback_missing" tabindex="-1"><code>ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING</code> <a class="header-anchor" href="#err_vm_dynamic_import_callback_missing" aria-label="Permalink to “ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING”">​</a></h3><p>동적 import 콜백이 지정되지 않았습니다.</p><h3 id="err_vm_dynamic_import_callback_missing_flag" tabindex="-1"><code>ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING_FLAG</code> <a class="header-anchor" href="#err_vm_dynamic_import_callback_missing_flag" aria-label="Permalink to “ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING_FLAG”">​</a></h3><p><code>--experimental-vm-modules</code> 없이 동적 import 콜백이 호출되었습니다.</p><h3 id="err_vm_module_already_linked" tabindex="-1"><code>ERR_VM_MODULE_ALREADY_LINKED</code> <a class="header-anchor" href="#err_vm_module_already_linked" aria-label="Permalink to “ERR_VM_MODULE_ALREADY_LINKED”">​</a></h3><p>연결하려는 모듈이 다음 이유 중 하나로 인해 연결할 수 없습니다.</p><ul><li>이미 연결되었습니다 (<code>linkingStatus</code>가 <code>&#39;linked&#39;</code>임).</li><li>연결 중입니다 (<code>linkingStatus</code>가 <code>&#39;linking&#39;</code>임).</li><li>이 모듈에 대한 연결이 실패했습니다 (<code>linkingStatus</code>가 <code>&#39;errored&#39;</code>임).</li></ul><h3 id="err_vm_module_cached_data_rejected" tabindex="-1"><code>ERR_VM_MODULE_CACHED_DATA_REJECTED</code> <a class="header-anchor" href="#err_vm_module_cached_data_rejected" aria-label="Permalink to “ERR_VM_MODULE_CACHED_DATA_REJECTED”">​</a></h3><p>모듈 생성자에 전달된 <code>cachedData</code> 옵션이 유효하지 않습니다.</p><h3 id="err_vm_module_cannot_create_cached_data" tabindex="-1"><code>ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA</code> <a class="header-anchor" href="#err_vm_module_cannot_create_cached_data" aria-label="Permalink to “ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA”">​</a></h3><p>이미 평가된 모듈에 대해서는 캐시된 데이터를 생성할 수 없습니다.</p><h3 id="err_vm_module_different_context" tabindex="-1"><code>ERR_VM_MODULE_DIFFERENT_CONTEXT</code> <a class="header-anchor" href="#err_vm_module_different_context" aria-label="Permalink to “ERR_VM_MODULE_DIFFERENT_CONTEXT”">​</a></h3><p>링커 함수에서 반환되는 모듈이 부모 모듈과 다른 컨텍스트에 있습니다. 연결된 모듈은 동일한 컨텍스트를 공유해야 합니다.</p><h3 id="err_vm_module_link_failure" tabindex="-1"><code>ERR_VM_MODULE_LINK_FAILURE</code> <a class="header-anchor" href="#err_vm_module_link_failure" aria-label="Permalink to “ERR_VM_MODULE_LINK_FAILURE”">​</a></h3><p>오류로 인해 모듈을 연결할 수 없습니다.</p><h3 id="err_vm_module_not_module" tabindex="-1"><code>ERR_VM_MODULE_NOT_MODULE</code> <a class="header-anchor" href="#err_vm_module_not_module" aria-label="Permalink to “ERR_VM_MODULE_NOT_MODULE”">​</a></h3><p>연결 약속의 이행된 값이 <code>vm.Module</code> 객체가 아닙니다.</p><h3 id="err_vm_module_status" tabindex="-1"><code>ERR_VM_MODULE_STATUS</code> <a class="header-anchor" href="#err_vm_module_status" aria-label="Permalink to “ERR_VM_MODULE_STATUS”">​</a></h3><p>현재 모듈의 상태가 이 작업을 허용하지 않습니다. 오류의 특정 의미는 특정 함수에 따라 다릅니다.</p><h3 id="err_wasi_already_started" tabindex="-1"><code>ERR_WASI_ALREADY_STARTED</code> <a class="header-anchor" href="#err_wasi_already_started" aria-label="Permalink to “ERR_WASI_ALREADY_STARTED”">​</a></h3><p>WASI 인스턴스가 이미 시작되었습니다.</p><h3 id="err_wasi_not_started" tabindex="-1"><code>ERR_WASI_NOT_STARTED</code> <a class="header-anchor" href="#err_wasi_not_started" aria-label="Permalink to “ERR_WASI_NOT_STARTED”">​</a></h3><p>WASI 인스턴스가 아직 시작되지 않았습니다.</p><h3 id="err_webassembly_response" tabindex="-1"><code>ERR_WEBASSEMBLY_RESPONSE</code> <a class="header-anchor" href="#err_webassembly_response" aria-label="Permalink to “ERR_WEBASSEMBLY_RESPONSE”">​</a></h3><p><strong>추가됨: v18.1.0</strong></p><p><code>WebAssembly.compileStreaming</code> 또는 <code>WebAssembly.instantiateStreaming</code>에 전달된 <code>Response</code>가 유효한 WebAssembly 응답이 아닙니다.</p><h3 id="err_worker_init_failed" tabindex="-1"><code>ERR_WORKER_INIT_FAILED</code> <a class="header-anchor" href="#err_worker_init_failed" aria-label="Permalink to “ERR_WORKER_INIT_FAILED”">​</a></h3><p><code>Worker</code> 초기화에 실패했습니다.</p><h3 id="err_worker_invalid_exec_argv" tabindex="-1"><code>ERR_WORKER_INVALID_EXEC_ARGV</code> <a class="header-anchor" href="#err_worker_invalid_exec_argv" aria-label="Permalink to “ERR_WORKER_INVALID_EXEC_ARGV”">​</a></h3><p><code>Worker</code> 생성자에 전달된 <code>execArgv</code> 옵션에 유효하지 않은 플래그가 포함되어 있습니다.</p><h3 id="err_worker_messaging_errored" tabindex="-1"><code>ERR_WORKER_MESSAGING_ERRORED</code> <a class="header-anchor" href="#err_worker_messaging_errored" aria-label="Permalink to “ERR_WORKER_MESSAGING_ERRORED”">​</a></h3><p><strong>추가됨: v22.5.0</strong></p><div class="warning custom-block"><p class="custom-block-title">[안정성: 1 - 실험적]</p><p><a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a> <a href="/ko/nodejs/api/documentation#stability-index">안정성: 1</a>.1 - 활발한 개발</p></div><p>대상 스레드가 <a href="/ko/nodejs/api/worker_threads#workerpostmessagetothreadthreadid-value-transferlist-timeout"><code>postMessageToThread()</code></a>를 통해 전송된 메시지를 처리하는 동안 오류를 발생시켰습니다.</p><h3 id="err_worker_messaging_failed" tabindex="-1"><code>ERR_WORKER_MESSAGING_FAILED</code> <a class="header-anchor" href="#err_worker_messaging_failed" aria-label="Permalink to “ERR_WORKER_MESSAGING_FAILED”">​</a></h3><p><strong>Added in: v22.5.0</strong></p><div class="warning custom-block"><p class="custom-block-title">[Stable: 1 - Experimental]</p><p><a href="/ko/nodejs/api/documentation#stability-index">Stable: 1</a> <a href="/ko/nodejs/api/documentation#stability-index">Stability: 1</a>.1 - 활발한 개발 중</p></div><p><a href="/ko/nodejs/api/worker_threads#workerpostmessagetothreadthreadid-value-transferlist-timeout"><code>postMessageToThread()</code></a>에서 요청된 스레드가 유효하지 않거나 <code>workerMessage</code> 리스너가 없습니다.</p><h3 id="err_worker_messaging_same_thread" tabindex="-1"><code>ERR_WORKER_MESSAGING_SAME_THREAD</code> <a class="header-anchor" href="#err_worker_messaging_same_thread" aria-label="Permalink to “ERR_WORKER_MESSAGING_SAME_THREAD”">​</a></h3><p><strong>Added in: v22.5.0</strong></p><div class="warning custom-block"><p class="custom-block-title">[Stable: 1 - Experimental]</p><p><a href="/ko/nodejs/api/documentation#stability-index">Stable: 1</a> <a href="/ko/nodejs/api/documentation#stability-index">Stability: 1</a>.1 - 활발한 개발 중</p></div><p><a href="/ko/nodejs/api/worker_threads#workerpostmessagetothreadthreadid-value-transferlist-timeout"><code>postMessageToThread()</code></a>에서 요청된 스레드 ID가 현재 스레드 ID입니다.</p><h3 id="err_worker_messaging_timeout" tabindex="-1"><code>ERR_WORKER_MESSAGING_TIMEOUT</code> <a class="header-anchor" href="#err_worker_messaging_timeout" aria-label="Permalink to “ERR_WORKER_MESSAGING_TIMEOUT”">​</a></h3><p><strong>Added in: v22.5.0</strong></p><div class="warning custom-block"><p class="custom-block-title">[Stable: 1 - Experimental]</p><p><a href="/ko/nodejs/api/documentation#stability-index">Stable: 1</a> <a href="/ko/nodejs/api/documentation#stability-index">Stability: 1</a>.1 - 활발한 개발 중</p></div><p><a href="/ko/nodejs/api/worker_threads#workerpostmessagetothreadthreadid-value-transferlist-timeout"><code>postMessageToThread()</code></a>를 통해 메시지를 보내는 데 시간이 초과되었습니다.</p><h3 id="err_worker_not_running" tabindex="-1"><code>ERR_WORKER_NOT_RUNNING</code> <a class="header-anchor" href="#err_worker_not_running" aria-label="Permalink to “ERR_WORKER_NOT_RUNNING”">​</a></h3><p><code>Worker</code> 인스턴스가 현재 실행 중이 아니기 때문에 작업이 실패했습니다.</p><h3 id="err_worker_out_of_memory" tabindex="-1"><code>ERR_WORKER_OUT_OF_MEMORY</code> <a class="header-anchor" href="#err_worker_out_of_memory" aria-label="Permalink to “ERR_WORKER_OUT_OF_MEMORY”">​</a></h3><p><code>Worker</code> 인스턴스가 메모리 제한에 도달하여 종료되었습니다.</p><h3 id="err_worker_path" tabindex="-1"><code>ERR_WORKER_PATH</code> <a class="header-anchor" href="#err_worker_path" aria-label="Permalink to “ERR_WORKER_PATH”">​</a></h3><p>워커의 메인 스크립트 경로는 절대 경로도 아니고 <code>./</code> 또는 <code>../</code>로 시작하는 상대 경로도 아닙니다.</p><h3 id="err_worker_unserializable_error" tabindex="-1"><code>ERR_WORKER_UNSERIALIZABLE_ERROR</code> <a class="header-anchor" href="#err_worker_unserializable_error" aria-label="Permalink to “ERR_WORKER_UNSERIALIZABLE_ERROR”">​</a></h3><p>워커 스레드에서 잡히지 않은 예외를 직렬화하려는 모든 시도가 실패했습니다.</p><h3 id="err_worker_unsupported_operation" tabindex="-1"><code>ERR_WORKER_UNSUPPORTED_OPERATION</code> <a class="header-anchor" href="#err_worker_unsupported_operation" aria-label="Permalink to “ERR_WORKER_UNSUPPORTED_OPERATION”">​</a></h3><p>요청된 기능은 워커 스레드에서 지원되지 않습니다.</p><h3 id="err_zlib_initialization_failed" tabindex="-1"><code>ERR_ZLIB_INITIALIZATION_FAILED</code> <a class="header-anchor" href="#err_zlib_initialization_failed" aria-label="Permalink to “ERR_ZLIB_INITIALIZATION_FAILED”">​</a></h3><p>잘못된 구성으로 인해 <a href="/ko/nodejs/api/zlib"><code>zlib</code></a> 객체 생성이 실패했습니다.</p><h3 id="hpe_chunk_extensions_overflow" tabindex="-1"><code>HPE_CHUNK_EXTENSIONS_OVERFLOW</code> <a class="header-anchor" href="#hpe_chunk_extensions_overflow" aria-label="Permalink to “HPE_CHUNK_EXTENSIONS_OVERFLOW”">​</a></h3><p><strong>Added in: v21.6.2, v20.11.1, v18.19.1</strong></p><p>청크 확장자에 너무 많은 데이터가 수신되었습니다. 악성 또는 잘못 구성된 클라이언트를 보호하기 위해 16 KiB 이상의 데이터가 수신되면 이 코드가 포함된 <code>Error</code>가 발생합니다.</p><h3 id="hpe_header_overflow" tabindex="-1"><code>HPE_HEADER_OVERFLOW</code> <a class="header-anchor" href="#hpe_header_overflow" aria-label="Permalink to “HPE_HEADER_OVERFLOW”">​</a></h3><div class="info custom-block"><p class="custom-block-title">[기록]</p><table tabindex="0"><thead><tr><th>버전</th><th>변경 사항</th></tr></thead><tbody><tr><td>v11.4.0, v10.15.0</td><td><code>http_parser</code>의 최대 헤더 크기가 8KiB로 설정되었습니다.</td></tr></tbody></table></div><p>너무 많은 HTTP 헤더 데이터가 수신되었습니다. 악성 클라이언트 또는 잘못 구성된 클라이언트로부터 보호하기 위해 <code>maxHeaderSize</code>보다 많은 HTTP 헤더 데이터가 수신되면 요청 또는 응답 객체를 생성하지 않고 HTTP 파싱이 중단되고 이 코드가 있는 <code>Error</code>가 발생합니다.</p><h3 id="hpe_unexpected_content_length" tabindex="-1"><code>HPE_UNEXPECTED_CONTENT_LENGTH</code> <a class="header-anchor" href="#hpe_unexpected_content_length" aria-label="Permalink to “HPE_UNEXPECTED_CONTENT_LENGTH”">​</a></h3><p>서버가 <code>Content-Length</code> 헤더와 <code>Transfer-Encoding: chunked</code>를 모두 전송하고 있습니다.</p><p><code>Transfer-Encoding: chunked</code>를 사용하면 서버가 동적으로 생성된 콘텐츠에 대해 HTTP 영구 연결을 유지할 수 있습니다. 이 경우 <code>Content-Length</code> HTTP 헤더를 사용할 수 없습니다.</p><p><code>Content-Length</code> 또는 <code>Transfer-Encoding: chunked</code>를 사용하세요.</p><h3 id="module_not_found" tabindex="-1"><code>MODULE_NOT_FOUND</code> <a class="header-anchor" href="#module_not_found" aria-label="Permalink to “MODULE_NOT_FOUND”">​</a></h3><div class="info custom-block"><p class="custom-block-title">[기록]</p><table tabindex="0"><thead><tr><th>버전</th><th>변경 사항</th></tr></thead><tbody><tr><td>v12.0.0</td><td><code>requireStack</code> 속성이 추가되었습니다.</td></tr></tbody></table></div><p><a href="/ko/nodejs/api/modules#requireid"><code>require()</code></a> 작업 또는 프로그램 진입점을 로드하는 동안 CommonJS 모듈 로더가 모듈 파일을 확인할 수 없습니다.</p><h2 id="legacy-nodejs-error-codes" tabindex="-1">레거시 Node.js 오류 코드 <a class="header-anchor" href="#legacy-nodejs-error-codes" aria-label="Permalink to “레거시 Node.js 오류 코드”">​</a></h2><div class="danger custom-block"><p class="custom-block-title">[안정성: 0 - 사용 중단됨]</p><p><a href="/ko/nodejs/api/documentation#stability-index">안정성: 0</a> <a href="/ko/nodejs/api/documentation#stability-index">안정성: 0</a> - 사용 중단됨. 이러한 오류 코드는 일관성이 없거나 제거되었습니다.</p></div><h3 id="err_cannot_transfer_object" tabindex="-1"><code>ERR_CANNOT_TRANSFER_OBJECT</code> <a class="header-anchor" href="#err_cannot_transfer_object" aria-label="Permalink to “ERR_CANNOT_TRANSFER_OBJECT”">​</a></h3><p><strong>추가된 버전: v10.5.0</strong></p><p><strong>제거된 버전: v12.5.0</strong></p><p><code>postMessage()</code>에 전달된 값에 전송을 지원하지 않는 객체가 포함되어 있습니다.</p><h3 id="err_cpu_usage" tabindex="-1"><code>ERR_CPU_USAGE</code> <a class="header-anchor" href="#err_cpu_usage" aria-label="Permalink to “ERR_CPU_USAGE”">​</a></h3><p><strong>제거된 버전: v15.0.0</strong></p><p><code>process.cpuUsage</code>의 네이티브 호출을 처리할 수 없습니다.</p><h3 id="err_crypto_hash_digest_no_utf16" tabindex="-1"><code>ERR_CRYPTO_HASH_DIGEST_NO_UTF16</code> <a class="header-anchor" href="#err_crypto_hash_digest_no_utf16" aria-label="Permalink to “ERR_CRYPTO_HASH_DIGEST_NO_UTF16”">​</a></h3><p><strong>추가된 버전: v9.0.0</strong></p><p><strong>제거된 버전: v12.12.0</strong></p><p>UTF-16 인코딩이 <a href="/ko/nodejs/api/crypto#hashdigestencoding"><code>hash.digest()</code></a>와 함께 사용되었습니다. <code>hash.digest()</code> 메서드는 <code>encoding</code> 인수를 전달하여 메서드가 <code>Buffer</code> 대신 문자열을 반환하도록 할 수 있지만 UTF-16 인코딩(예: <code>ucs</code> 또는 <code>utf16le</code>)은 지원되지 않습니다.</p><h3 id="err_crypto_scrypt_invalid_parameter" tabindex="-1"><code>ERR_CRYPTO_SCRYPT_INVALID_PARAMETER</code> <a class="header-anchor" href="#err_crypto_scrypt_invalid_parameter" aria-label="Permalink to “ERR_CRYPTO_SCRYPT_INVALID_PARAMETER”">​</a></h3><p><strong>제거됨: v23.0.0</strong></p><p>호환되지 않는 옵션 조합이 <a href="/ko/nodejs/api/crypto#cryptoscryptpassword-salt-keylen-options-callback"><code>crypto.scrypt()</code></a> 또는 <a href="/ko/nodejs/api/crypto#cryptoscryptsyncpassword-salt-keylen-options"><code>crypto.scryptSync()</code></a>에 전달되었습니다. Node.js의 새 버전에서는 다른 API와 일관성을 유지하기 위해 오류 코드 <a href="/ko/nodejs/api/errors#err-incompatible-option-pair"><code>ERR_INCOMPATIBLE_OPTION_PAIR</code></a>를 대신 사용합니다.</p><h3 id="err_fs_invalid_symlink_type" tabindex="-1"><code>ERR_FS_INVALID_SYMLINK_TYPE</code> <a class="header-anchor" href="#err_fs_invalid_symlink_type" aria-label="Permalink to “ERR_FS_INVALID_SYMLINK_TYPE”">​</a></h3><p><strong>제거됨: v23.0.0</strong></p><p>유효하지 않은 심볼릭 링크 유형이 <a href="/ko/nodejs/api/fs#fssymlinktarget-path-type-callback"><code>fs.symlink()</code></a> 또는 <a href="/ko/nodejs/api/fs#fssymlinksynctarget-path-type"><code>fs.symlinkSync()</code></a> 메서드에 전달되었습니다.</p><h3 id="err_http2_frame_error" tabindex="-1"><code>ERR_HTTP2_FRAME_ERROR</code> <a class="header-anchor" href="#err_http2_frame_error" aria-label="Permalink to “ERR_HTTP2_FRAME_ERROR”">​</a></h3><p><strong>추가됨: v9.0.0</strong></p><p><strong>제거됨: v10.0.0</strong></p><p>HTTP/2 세션에서 개별 프레임을 보내는 데 실패했을 때 사용됩니다.</p><h3 id="err_http2_headers_object" tabindex="-1"><code>ERR_HTTP2_HEADERS_OBJECT</code> <a class="header-anchor" href="#err_http2_headers_object" aria-label="Permalink to “ERR_HTTP2_HEADERS_OBJECT”">​</a></h3><p><strong>추가됨: v9.0.0</strong></p><p><strong>제거됨: v10.0.0</strong></p><p>HTTP/2 헤더 객체가 필요한 경우 사용됩니다.</p><h3 id="err_http2_header_required" tabindex="-1"><code>ERR_HTTP2_HEADER_REQUIRED</code> <a class="header-anchor" href="#err_http2_header_required" aria-label="Permalink to “ERR_HTTP2_HEADER_REQUIRED”">​</a></h3><p><strong>추가됨: v9.0.0</strong></p><p><strong>제거됨: v10.0.0</strong></p><p>필수 헤더가 HTTP/2 메시지에 없는 경우 사용됩니다.</p><h3 id="err_http2_info_headers_after_respond" tabindex="-1"><code>ERR_HTTP2_INFO_HEADERS_AFTER_RESPOND</code> <a class="header-anchor" href="#err_http2_info_headers_after_respond" aria-label="Permalink to “ERR_HTTP2_INFO_HEADERS_AFTER_RESPOND”">​</a></h3><p><strong>추가됨: v9.0.0</strong></p><p><strong>제거됨: v10.0.0</strong></p><p>HTTP/2 정보 헤더는 <code>Http2Stream.prototype.respond()</code> 메서드를 호출하기 <em>전에만</em> 보내야 합니다.</p><h3 id="err_http2_stream_closed" tabindex="-1"><code>ERR_HTTP2_STREAM_CLOSED</code> <a class="header-anchor" href="#err_http2_stream_closed" aria-label="Permalink to “ERR_HTTP2_STREAM_CLOSED”">​</a></h3><p><strong>추가됨: v9.0.0</strong></p><p><strong>제거됨: v10.0.0</strong></p><p>이미 닫힌 HTTP/2 스트림에서 작업이 수행된 경우 사용됩니다.</p><h3 id="err_http_invalid_char" tabindex="-1"><code>ERR_HTTP_INVALID_CHAR</code> <a class="header-anchor" href="#err_http_invalid_char" aria-label="Permalink to “ERR_HTTP_INVALID_CHAR”">​</a></h3><p><strong>추가됨: v9.0.0</strong></p><p><strong>제거됨: v10.0.0</strong></p><p>HTTP 응답 상태 메시지(이유 구절)에서 유효하지 않은 문자가 발견된 경우 사용됩니다.</p><h3 id="err_import_assertion_type_failed" tabindex="-1"><code>ERR_IMPORT_ASSERTION_TYPE_FAILED</code> <a class="header-anchor" href="#err_import_assertion_type_failed" aria-label="Permalink to “ERR_IMPORT_ASSERTION_TYPE_FAILED”">​</a></h3><p><strong>추가됨: v17.1.0, v16.14.0</strong></p><p><strong>제거됨: v21.1.0</strong></p><p>가져오기 어설션이 실패하여 지정된 모듈을 가져올 수 없습니다.</p><h3 id="err_import_assertion_type_missing" tabindex="-1"><code>ERR_IMPORT_ASSERTION_TYPE_MISSING</code> <a class="header-anchor" href="#err_import_assertion_type_missing" aria-label="Permalink to “ERR_IMPORT_ASSERTION_TYPE_MISSING”">​</a></h3><p><strong>추가됨: v17.1.0, v16.14.0</strong></p><p><strong>제거됨: v21.1.0</strong></p><p>가져오기 어설션이 누락되어 지정된 모듈을 가져올 수 없습니다.</p><h3 id="err_import_assertion_type_unsupported" tabindex="-1"><code>ERR_IMPORT_ASSERTION_TYPE_UNSUPPORTED</code> <a class="header-anchor" href="#err_import_assertion_type_unsupported" aria-label="Permalink to “ERR_IMPORT_ASSERTION_TYPE_UNSUPPORTED”">​</a></h3><p><strong>Added in: v17.1.0, v16.14.0</strong></p><p><strong>Removed in: v21.1.0</strong></p><p>가져오기 어설션이 이 Node.js 버전에서 지원되지 않습니다.</p><h3 id="err_index_out_of_range" tabindex="-1"><code>ERR_INDEX_OUT_OF_RANGE</code> <a class="header-anchor" href="#err_index_out_of_range" aria-label="Permalink to “ERR_INDEX_OUT_OF_RANGE”">​</a></h3><p><strong>Added in: v10.0.0</strong></p><p><strong>Removed in: v11.0.0</strong></p><p>주어진 인덱스가 허용된 범위를 벗어났습니다 (예: 음수 오프셋).</p><h3 id="err_invalid_opt_value" tabindex="-1"><code>ERR_INVALID_OPT_VALUE</code> <a class="header-anchor" href="#err_invalid_opt_value" aria-label="Permalink to “ERR_INVALID_OPT_VALUE”">​</a></h3><p><strong>Added in: v8.0.0</strong></p><p><strong>Removed in: v15.0.0</strong></p><p>옵션 객체에 유효하지 않거나 예상치 못한 값이 전달되었습니다.</p><h3 id="err_invalid_opt_value_encoding" tabindex="-1"><code>ERR_INVALID_OPT_VALUE_ENCODING</code> <a class="header-anchor" href="#err_invalid_opt_value_encoding" aria-label="Permalink to “ERR_INVALID_OPT_VALUE_ENCODING”">​</a></h3><p><strong>Added in: v9.0.0</strong></p><p><strong>Removed in: v15.0.0</strong></p><p>유효하지 않거나 알 수 없는 파일 인코딩이 전달되었습니다.</p><h3 id="err_invalid_performance_mark" tabindex="-1"><code>ERR_INVALID_PERFORMANCE_MARK</code> <a class="header-anchor" href="#err_invalid_performance_mark" aria-label="Permalink to “ERR_INVALID_PERFORMANCE_MARK”">​</a></h3><p><strong>Added in: v8.5.0</strong></p><p><strong>Removed in: v16.7.0</strong></p><p>Performance Timing API(<code>perf_hooks</code>)를 사용하는 동안 성능 마크가 유효하지 않습니다.</p><h3 id="err_invalid_transfer_object" tabindex="-1"><code>ERR_INVALID_TRANSFER_OBJECT</code> <a class="header-anchor" href="#err_invalid_transfer_object" aria-label="Permalink to “ERR_INVALID_TRANSFER_OBJECT”">​</a></h3><div class="info custom-block"><p class="custom-block-title">[기록]</p><table tabindex="0"><thead><tr><th>버전</th><th>변경 사항</th></tr></thead><tbody><tr><td>v21.0.0</td><td><code>DOMException</code>이 대신 발생합니다.</td></tr><tr><td>v21.0.0</td><td>Removed in: v21.0.0</td></tr></tbody></table></div><p>유효하지 않은 전송 객체가 <code>postMessage()</code>에 전달되었습니다.</p><h3 id="err_manifest_assert_integrity" tabindex="-1"><code>ERR_MANIFEST_ASSERT_INTEGRITY</code> <a class="header-anchor" href="#err_manifest_assert_integrity" aria-label="Permalink to “ERR_MANIFEST_ASSERT_INTEGRITY”">​</a></h3><p><strong>Removed in: v22.2.0</strong></p><p>리소스 로드를 시도했지만 리소스가 정책 매니페스트에 정의된 무결성과 일치하지 않았습니다. 자세한 내용은 정책 매니페스트 문서를 참조하십시오.</p><h3 id="err_manifest_dependency_missing" tabindex="-1"><code>ERR_MANIFEST_DEPENDENCY_MISSING</code> <a class="header-anchor" href="#err_manifest_dependency_missing" aria-label="Permalink to “ERR_MANIFEST_DEPENDENCY_MISSING”">​</a></h3><p><strong>Removed in: v22.2.0</strong></p><p>리소스 로드를 시도했지만 리소스가 로드를 시도한 위치에서 종속성으로 나열되지 않았습니다. 자세한 내용은 정책 매니페스트 문서를 참조하십시오.</p><h3 id="err_manifest_integrity_mismatch" tabindex="-1"><code>ERR_MANIFEST_INTEGRITY_MISMATCH</code> <a class="header-anchor" href="#err_manifest_integrity_mismatch" aria-label="Permalink to “ERR_MANIFEST_INTEGRITY_MISMATCH”">​</a></h3><p><strong>Removed in: v22.2.0</strong></p><p>정책 매니페스트 로드를 시도했지만 매니페스트에 서로 일치하지 않는 리소스에 대한 여러 항목이 있었습니다. 이 오류를 해결하려면 매니페스트 항목이 일치하도록 업데이트하십시오. 자세한 내용은 정책 매니페스트 문서를 참조하십시오.</p><h3 id="err_manifest_invalid_resource_field" tabindex="-1"><code>ERR_MANIFEST_INVALID_RESOURCE_FIELD</code> <a class="header-anchor" href="#err_manifest_invalid_resource_field" aria-label="Permalink to “ERR_MANIFEST_INVALID_RESOURCE_FIELD”">​</a></h3><p><strong>Removed in: v22.2.0</strong></p><p>정책 매니페스트 리소스에 해당 필드 중 하나에 대한 유효하지 않은 값이 있었습니다. 이 오류를 해결하려면 매니페스트 항목이 일치하도록 업데이트하십시오. 자세한 내용은 정책 매니페스트 문서를 참조하십시오.</p><h3 id="err_manifest_invalid_specifier" tabindex="-1"><code>ERR_MANIFEST_INVALID_SPECIFIER</code> <a class="header-anchor" href="#err_manifest_invalid_specifier" aria-label="Permalink to “ERR_MANIFEST_INVALID_SPECIFIER”">​</a></h3><p><strong>제거됨: v22.2.0</strong></p><p>정책 매니페스트 리소스에 해당 종속성 매핑에 대한 유효하지 않은 값이 있습니다. 이 오류를 해결하려면 매니페스트 항목을 일치하도록 업데이트하십시오. 자세한 내용은 정책 매니페스트 설명서를 참조하십시오.</p><h3 id="err_manifest_parse_policy" tabindex="-1"><code>ERR_MANIFEST_PARSE_POLICY</code> <a class="header-anchor" href="#err_manifest_parse_policy" aria-label="Permalink to “ERR_MANIFEST_PARSE_POLICY”">​</a></h3><p><strong>제거됨: v22.2.0</strong></p><p>정책 매니페스트를 로드하려고 시도했지만 매니페스트를 구문 분석할 수 없습니다. 자세한 내용은 정책 매니페스트 설명서를 참조하십시오.</p><h3 id="err_manifest_tdz" tabindex="-1"><code>ERR_MANIFEST_TDZ</code> <a class="header-anchor" href="#err_manifest_tdz" aria-label="Permalink to “ERR_MANIFEST_TDZ”">​</a></h3><p><strong>제거됨: v22.2.0</strong></p><p>정책 매니페스트에서 읽기를 시도했지만 매니페스트 초기화가 아직 수행되지 않았습니다. 이는 Node.js의 버그일 가능성이 높습니다.</p><h3 id="err_manifest_unknown_onerror" tabindex="-1"><code>ERR_MANIFEST_UNKNOWN_ONERROR</code> <a class="header-anchor" href="#err_manifest_unknown_onerror" aria-label="Permalink to “ERR_MANIFEST_UNKNOWN_ONERROR”">​</a></h3><p><strong>제거됨: v22.2.0</strong></p><p>정책 매니페스트가 로드되었지만 해당 &quot;onerror&quot; 동작에 대한 알 수 없는 값이 있습니다. 자세한 내용은 정책 매니페스트 설명서를 참조하십시오.</p><h3 id="err_missing_message_port_in_transfer_list" tabindex="-1"><code>ERR_MISSING_MESSAGE_PORT_IN_TRANSFER_LIST</code> <a class="header-anchor" href="#err_missing_message_port_in_transfer_list" aria-label="Permalink to “ERR_MISSING_MESSAGE_PORT_IN_TRANSFER_LIST”">​</a></h3><p><strong>제거됨: v15.0.0</strong></p><p>이 오류 코드는 Node.js v15.0.0에서 <a href="/ko/nodejs/api/errors#err-missing-transferable-in-transfer-list"><code>ERR_MISSING_TRANSFERABLE_IN_TRANSFER_LIST</code></a>로 대체되었습니다. 그 이유는 다른 유형의 전송 가능한 객체도 이제 존재하므로 더 이상 정확하지 않기 때문입니다.</p><h3 id="err_missing_transferable_in_transfer_list" tabindex="-1"><code>ERR_MISSING_TRANSFERABLE_IN_TRANSFER_LIST</code> <a class="header-anchor" href="#err_missing_transferable_in_transfer_list" aria-label="Permalink to “ERR_MISSING_TRANSFERABLE_IN_TRANSFER_LIST”">​</a></h3><div class="info custom-block"><p class="custom-block-title">[History]</p><table tabindex="0"><thead><tr><th>Version</th><th>Changes</th></tr></thead><tbody><tr><td>v21.0.0</td><td><code>DOMException</code>이 대신 발생합니다.</td></tr><tr><td>v21.0.0</td><td>제거됨: v21.0.0</td></tr><tr><td>v15.0.0</td><td>추가됨: v15.0.0</td></tr></tbody></table></div><p><code>transferList</code> 인수에 명시적으로 나열해야 하는 객체가 <a href="/ko/nodejs/api/worker_threads#portpostmessagevalue-transferlist"><code>postMessage()</code></a> 호출에 전달된 객체에 있지만 해당 호출의 <code>transferList</code>에 제공되지 않습니다. 일반적으로 이는 <code>MessagePort</code>입니다.</p><p>v15.0.0 이전의 Node.js 버전에서 여기서 사용되는 오류 코드는 <a href="/ko/nodejs/api/errors#err-missing-message-port-in-transfer-list"><code>ERR_MISSING_MESSAGE_PORT_IN_TRANSFER_LIST</code></a>였습니다. 그러나 전송 가능한 객체 유형 세트가 확장되어 <code>MessagePort</code>보다 더 많은 유형을 포괄합니다.</p><h3 id="err_napi_cons_prototype_object" tabindex="-1"><code>ERR_NAPI_CONS_PROTOTYPE_OBJECT</code> <a class="header-anchor" href="#err_napi_cons_prototype_object" aria-label="Permalink to “ERR_NAPI_CONS_PROTOTYPE_OBJECT”">​</a></h3><p><strong>추가됨: v9.0.0</strong></p><p><strong>제거됨: v10.0.0</strong></p><p><code>Constructor.prototype</code>이 객체가 아닐 때 <code>Node-API</code>에서 사용됩니다.</p><h3 id="err_napi_tsfn_start_idle_loop" tabindex="-1"><code>ERR_NAPI_TSFN_START_IDLE_LOOP</code> <a class="header-anchor" href="#err_napi_tsfn_start_idle_loop" aria-label="Permalink to “ERR_NAPI_TSFN_START_IDLE_LOOP”">​</a></h3><p><strong>Added in: v10.6.0, v8.16.0</strong></p><p><strong>Removed in: v14.2.0, v12.17.0</strong></p><p>메인 스레드에서 스레드 안전 함수와 관련된 큐에서 유휴 루프를 통해 값이 제거됩니다. 이 오류는 루프 시작을 시도할 때 오류가 발생했음을 나타냅니다.</p><h3 id="err_napi_tsfn_stop_idle_loop" tabindex="-1"><code>ERR_NAPI_TSFN_STOP_IDLE_LOOP</code> <a class="header-anchor" href="#err_napi_tsfn_stop_idle_loop" aria-label="Permalink to “ERR_NAPI_TSFN_STOP_IDLE_LOOP”">​</a></h3><p><strong>Added in: v10.6.0, v8.16.0</strong></p><p><strong>Removed in: v14.2.0, v12.17.0</strong></p><p>큐에 더 이상 항목이 남아 있지 않으면 유휴 루프를 일시 중단해야 합니다. 이 오류는 유휴 루프가 중지되지 않았음을 나타냅니다.</p><h3 id="err_no_longer_supported" tabindex="-1"><code>ERR_NO_LONGER_SUPPORTED</code> <a class="header-anchor" href="#err_no_longer_supported" aria-label="Permalink to “ERR_NO_LONGER_SUPPORTED”">​</a></h3><p><code>Buffer.write(string, encoding, offset[, length])</code>와 같이 지원되지 않는 방식으로 Node.js API가 호출되었습니다.</p><h3 id="err_outofmemory" tabindex="-1"><code>ERR_OUTOFMEMORY</code> <a class="header-anchor" href="#err_outofmemory" aria-label="Permalink to “ERR_OUTOFMEMORY”">​</a></h3><p><strong>Added in: v9.0.0</strong></p><p><strong>Removed in: v10.0.0</strong></p><p>작업으로 인해 메모리 부족 상태가 발생했음을 일반적으로 식별하는 데 사용됩니다.</p><h3 id="err_parse_history_data" tabindex="-1"><code>ERR_PARSE_HISTORY_DATA</code> <a class="header-anchor" href="#err_parse_history_data" aria-label="Permalink to “ERR_PARSE_HISTORY_DATA”">​</a></h3><p><strong>Added in: v9.0.0</strong></p><p><strong>Removed in: v10.0.0</strong></p><p><code>node:repl</code> 모듈이 REPL 기록 파일에서 데이터를 파싱할 수 없습니다.</p><h3 id="err_socket_cannot_send" tabindex="-1"><code>ERR_SOCKET_CANNOT_SEND</code> <a class="header-anchor" href="#err_socket_cannot_send" aria-label="Permalink to “ERR_SOCKET_CANNOT_SEND”">​</a></h3><p><strong>Added in: v9.0.0</strong></p><p><strong>Removed in: v14.0.0</strong></p><p>소켓에서 데이터를 보낼 수 없습니다.</p><h3 id="err_stderr_close" tabindex="-1"><code>ERR_STDERR_CLOSE</code> <a class="header-anchor" href="#err_stderr_close" aria-label="Permalink to “ERR_STDERR_CLOSE”">​</a></h3><div class="info custom-block"><p class="custom-block-title">[History]</p><table tabindex="0"><thead><tr><th>Version</th><th>Changes</th></tr></thead><tbody><tr><td>v10.12.0</td><td>오류를 발생시키는 대신 <code>process.stderr.end()</code>는 이제 스트림 측만 닫고 기본 리소스는 닫지 않아 이 오류가 불필요해졌습니다.</td></tr><tr><td>v10.12.0</td><td>Removed in: v10.12.0</td></tr></tbody></table></div><p><code>process.stderr</code> 스트림을 닫으려고 시도했습니다. 설계상 Node.js는 사용자 코드가 <code>stdout</code> 또는 <code>stderr</code> 스트림을 닫는 것을 허용하지 않습니다.</p><h3 id="err_stdout_close" tabindex="-1"><code>ERR_STDOUT_CLOSE</code> <a class="header-anchor" href="#err_stdout_close" aria-label="Permalink to “ERR_STDOUT_CLOSE”">​</a></h3><div class="info custom-block"><p class="custom-block-title">[History]</p><table tabindex="0"><thead><tr><th>Version</th><th>Changes</th></tr></thead><tbody><tr><td>v10.12.0</td><td>오류를 발생시키는 대신 <code>process.stderr.end()</code>는 이제 스트림 측만 닫고 기본 리소스는 닫지 않아 이 오류가 불필요해졌습니다.</td></tr><tr><td>v10.12.0</td><td>Removed in: v10.12.0</td></tr></tbody></table></div><p><code>process.stdout</code> 스트림을 닫으려고 시도했습니다. 설계상 Node.js는 사용자 코드가 <code>stdout</code> 또는 <code>stderr</code> 스트림을 닫는 것을 허용하지 않습니다.</p><h3 id="err_stream_read_not_implemented" tabindex="-1"><code>ERR_STREAM_READ_NOT_IMPLEMENTED</code> <a class="header-anchor" href="#err_stream_read_not_implemented" aria-label="Permalink to “ERR_STREAM_READ_NOT_IMPLEMENTED”">​</a></h3><p><strong>Added in: v9.0.0</strong></p><p><strong>Removed in: v10.0.0</strong></p><p><a href="/ko/nodejs/api/stream#readable-readsize"><code>readable._read()</code></a>를 구현하지 않은 읽기 가능한 스트림을 사용하려고 시도할 때 사용됩니다.</p><h3 id="err_tls_renegotiation_failed" tabindex="-1"><code>ERR_TLS_RENEGOTIATION_FAILED</code> <a class="header-anchor" href="#err_tls_renegotiation_failed" aria-label="Permalink to “ERR_TLS_RENEGOTIATION_FAILED”">​</a></h3><p><strong>추가된 버전: v9.0.0</strong></p><p><strong>제거된 버전: v10.0.0</strong></p><p>TLS 재협상 요청이 특정되지 않은 방식으로 실패했을 때 사용됩니다.</p><h3 id="err_transferring_externalized_sharedarraybuffer" tabindex="-1"><code>ERR_TRANSFERRING_EXTERNALIZED_SHAREDARRAYBUFFER</code> <a class="header-anchor" href="#err_transferring_externalized_sharedarraybuffer" aria-label="Permalink to “ERR_TRANSFERRING_EXTERNALIZED_SHAREDARRAYBUFFER”">​</a></h3><p><strong>추가된 버전: v10.5.0</strong></p><p><strong>제거된 버전: v14.0.0</strong></p><p>JavaScript 엔진이나 Node.js에서 관리하지 않는 메모리를 가진 <code>SharedArrayBuffer</code>가 직렬화 중에 발견되었습니다. 이러한 <code>SharedArrayBuffer</code>는 직렬화할 수 없습니다.</p><p>이것은 네이티브 애드온이 &quot;externalized&quot; 모드에서 <code>SharedArrayBuffer</code>를 만들거나 기존 <code>SharedArrayBuffer</code>를 externalized 모드로 전환할 때만 발생할 수 있습니다.</p><h3 id="err_unknown_stdin_type" tabindex="-1"><code>ERR_UNKNOWN_STDIN_TYPE</code> <a class="header-anchor" href="#err_unknown_stdin_type" aria-label="Permalink to “ERR_UNKNOWN_STDIN_TYPE”">​</a></h3><p><strong>추가된 버전: v8.0.0</strong></p><p><strong>제거된 버전: v11.7.0</strong></p><p>알 수 없는 <code>stdin</code> 파일 유형으로 Node.js 프로세스를 시작하려고 시도했습니다. 이 오류는 일반적으로 Node.js 자체 내의 버그를 나타내지만 사용자 코드가 트리거할 수도 있습니다.</p><h3 id="err_unknown_stream_type" tabindex="-1"><code>ERR_UNKNOWN_STREAM_TYPE</code> <a class="header-anchor" href="#err_unknown_stream_type" aria-label="Permalink to “ERR_UNKNOWN_STREAM_TYPE”">​</a></h3><p><strong>추가된 버전: v8.0.0</strong></p><p><strong>제거된 버전: v11.7.0</strong></p><p>알 수 없는 <code>stdout</code> 또는 <code>stderr</code> 파일 유형으로 Node.js 프로세스를 시작하려고 시도했습니다. 이 오류는 일반적으로 Node.js 자체 내의 버그를 나타내지만 사용자 코드가 트리거할 수도 있습니다.</p><h3 id="err_v8breakiterator" tabindex="-1"><code>ERR_V8BREAKITERATOR</code> <a class="header-anchor" href="#err_v8breakiterator" aria-label="Permalink to “ERR_V8BREAKITERATOR”">​</a></h3><p>V8 <code>BreakIterator</code> API가 사용되었지만 전체 ICU 데이터 세트가 설치되지 않았습니다.</p><h3 id="err_value_out_of_range" tabindex="-1"><code>ERR_VALUE_OUT_OF_RANGE</code> <a class="header-anchor" href="#err_value_out_of_range" aria-label="Permalink to “ERR_VALUE_OUT_OF_RANGE”">​</a></h3><p><strong>추가된 버전: v9.0.0</strong></p><p><strong>제거된 버전: v10.0.0</strong></p><p>주어진 값이 허용된 범위를 벗어날 때 사용됩니다.</p><h3 id="err_vm_module_linking_errored" tabindex="-1"><code>ERR_VM_MODULE_LINKING_ERRORED</code> <a class="header-anchor" href="#err_vm_module_linking_errored" aria-label="Permalink to “ERR_VM_MODULE_LINKING_ERRORED”">​</a></h3><p><strong>추가된 버전: v10.0.0</strong></p><p><strong>제거된 버전: v18.1.0, v16.17.0</strong></p><p>링커 함수가 연결에 실패한 모듈을 반환했습니다.</p><h3 id="err_vm_module_not_linked" tabindex="-1"><code>ERR_VM_MODULE_NOT_LINKED</code> <a class="header-anchor" href="#err_vm_module_not_linked" aria-label="Permalink to “ERR_VM_MODULE_NOT_LINKED”">​</a></h3><p>모듈은 인스턴스화하기 전에 성공적으로 연결되어야 합니다.</p><h3 id="err_worker_unsupported_extension" tabindex="-1"><code>ERR_WORKER_UNSUPPORTED_EXTENSION</code> <a class="header-anchor" href="#err_worker_unsupported_extension" aria-label="Permalink to “ERR_WORKER_UNSUPPORTED_EXTENSION”">​</a></h3><p><strong>추가된 버전: v11.0.0</strong></p><p><strong>제거된 버전: v16.9.0</strong></p><p>워커의 메인 스크립트에 사용된 경로 이름에 알 수 없는 파일 확장명이 있습니다.</p><h3 id="err_zlib_binding_closed" tabindex="-1"><code>ERR_ZLIB_BINDING_CLOSED</code> <a class="header-anchor" href="#err_zlib_binding_closed" aria-label="Permalink to “ERR_ZLIB_BINDING_CLOSED”">​</a></h3><p><strong>추가된 버전: v9.0.0</strong></p><p><strong>제거된 버전: v10.0.0</strong></p><p>이미 닫힌 <code>zlib</code> 객체를 사용하려고 시도했을 때 사용됩니다.</p><h2 id="openssl-error-codes" tabindex="-1">OpenSSL 오류 코드 <a class="header-anchor" href="#openssl-error-codes" aria-label="Permalink to “OpenSSL 오류 코드”">​</a></h2><h3 id="time-validity-errors" tabindex="-1">시간 유효성 오류 <a class="header-anchor" href="#time-validity-errors" aria-label="Permalink to “시간 유효성 오류”">​</a></h3><h4 id="cert_not_yet_valid" tabindex="-1"><code>CERT_NOT_YET_VALID</code> <a class="header-anchor" href="#cert_not_yet_valid" aria-label="Permalink to “CERT_NOT_YET_VALID”">​</a></h4><p>인증서가 아직 유효하지 않습니다. notBefore 날짜가 현재 시간 이후입니다.</p><h4 id="cert_has_expired" tabindex="-1"><code>CERT_HAS_EXPIRED</code> <a class="header-anchor" href="#cert_has_expired" aria-label="Permalink to “CERT_HAS_EXPIRED”">​</a></h4><p>인증서가 만료되었습니다. notAfter 날짜가 현재 시간 이전입니다.</p><h4 id="crl_not_yet_valid" tabindex="-1"><code>CRL_NOT_YET_VALID</code> <a class="header-anchor" href="#crl_not_yet_valid" aria-label="Permalink to “CRL_NOT_YET_VALID”">​</a></h4><p>인증서 해지 목록(CRL)에 미래 발행 날짜가 있습니다.</p><h4 id="crl_has_expired" tabindex="-1"><code>CRL_HAS_EXPIRED</code> <a class="header-anchor" href="#crl_has_expired" aria-label="Permalink to “CRL_HAS_EXPIRED”">​</a></h4><p>인증서 해지 목록(CRL)이 만료되었습니다.</p><h4 id="cert_revoked" tabindex="-1"><code>CERT_REVOKED</code> <a class="header-anchor" href="#cert_revoked" aria-label="Permalink to “CERT_REVOKED”">​</a></h4><p>인증서가 해지되었습니다. 인증서 해지 목록(CRL)에 있습니다.</p><h3 id="trust-or-chain-related-errors" tabindex="-1">신뢰 또는 체인 관련 오류 <a class="header-anchor" href="#trust-or-chain-related-errors" aria-label="Permalink to “신뢰 또는 체인 관련 오류”">​</a></h3><h4 id="unable_to_get_issuer_cert" tabindex="-1"><code>UNABLE_TO_GET_ISSUER_CERT</code> <a class="header-anchor" href="#unable_to_get_issuer_cert" aria-label="Permalink to “UNABLE_TO_GET_ISSUER_CERT”">​</a></h4><p>조회된 인증서의 발급자 인증서를 찾을 수 없습니다. 이는 일반적으로 신뢰할 수 있는 인증서 목록이 완전하지 않음을 의미합니다.</p><h4 id="unable_to_get_issuer_cert_locally" tabindex="-1"><code>UNABLE_TO_GET_ISSUER_CERT_LOCALLY</code> <a class="header-anchor" href="#unable_to_get_issuer_cert_locally" aria-label="Permalink to “UNABLE_TO_GET_ISSUER_CERT_LOCALLY”">​</a></h4><p>인증서의 발급자를 알 수 없습니다. 발급자가 신뢰할 수 있는 인증서 목록에 포함되지 않은 경우입니다.</p><h4 id="depth_zero_self_signed_cert" tabindex="-1"><code>DEPTH_ZERO_SELF_SIGNED_CERT</code> <a class="header-anchor" href="#depth_zero_self_signed_cert" aria-label="Permalink to “DEPTH_ZERO_SELF_SIGNED_CERT”">​</a></h4><p>전달된 인증서가 자체 서명되었으며 동일한 인증서를 신뢰할 수 있는 인증서 목록에서 찾을 수 없습니다.</p><h4 id="self_signed_cert_in_chain" tabindex="-1"><code>SELF_SIGNED_CERT_IN_CHAIN</code> <a class="header-anchor" href="#self_signed_cert_in_chain" aria-label="Permalink to “SELF_SIGNED_CERT_IN_CHAIN”">​</a></h4><p>인증서의 발급자를 알 수 없습니다. 발급자가 신뢰할 수 있는 인증서 목록에 포함되지 않은 경우입니다.</p><h4 id="cert_chain_too_long" tabindex="-1"><code>CERT_CHAIN_TOO_LONG</code> <a class="header-anchor" href="#cert_chain_too_long" aria-label="Permalink to “CERT_CHAIN_TOO_LONG”">​</a></h4><p>인증서 체인 길이가 최대 깊이보다 깁니다.</p><h4 id="unable_to_get_crl" tabindex="-1"><code>UNABLE_TO_GET_CRL</code> <a class="header-anchor" href="#unable_to_get_crl" aria-label="Permalink to “UNABLE_TO_GET_CRL”">​</a></h4><p>인증서에서 참조하는 CRL을 찾을 수 없습니다.</p><h4 id="unable_to_verify_leaf_signature" tabindex="-1"><code>UNABLE_TO_VERIFY_LEAF_SIGNATURE</code> <a class="header-anchor" href="#unable_to_verify_leaf_signature" aria-label="Permalink to “UNABLE_TO_VERIFY_LEAF_SIGNATURE”">​</a></h4><p>체인에 인증서가 하나만 포함되어 있고 자체 서명되지 않았기 때문에 서명을 확인할 수 없습니다.</p><h4 id="cert_untrusted" tabindex="-1"><code>CERT_UNTRUSTED</code> <a class="header-anchor" href="#cert_untrusted" aria-label="Permalink to “CERT_UNTRUSTED”">​</a></h4><p>루트 인증 기관(CA)이 지정된 목적에 대해 신뢰할 수 있는 것으로 표시되지 않았습니다.</p><h3 id="basic-extension-errors" tabindex="-1">기본 확장 오류 <a class="header-anchor" href="#basic-extension-errors" aria-label="Permalink to “기본 확장 오류”">​</a></h3><h4 id="invalid_ca" tabindex="-1"><code>INVALID_CA</code> <a class="header-anchor" href="#invalid_ca" aria-label="Permalink to “INVALID_CA”">​</a></h4><p>CA 인증서가 유효하지 않습니다. CA가 아니거나 해당 확장이 제공된 목적과 일치하지 않습니다.</p><h4 id="path_length_exceeded" tabindex="-1"><code>PATH_LENGTH_EXCEEDED</code> <a class="header-anchor" href="#path_length_exceeded" aria-label="Permalink to “PATH_LENGTH_EXCEEDED”">​</a></h4><p>basicConstraints pathlength 매개변수가 초과되었습니다.</p><h3 id="name-related-errors" tabindex="-1">이름 관련 오류 <a class="header-anchor" href="#name-related-errors" aria-label="Permalink to “이름 관련 오류”">​</a></h3><h4 id="hostname_mismatch" tabindex="-1"><code>HOSTNAME_MISMATCH</code> <a class="header-anchor" href="#hostname_mismatch" aria-label="Permalink to “HOSTNAME_MISMATCH”">​</a></h4><p>인증서가 제공된 이름과 일치하지 않습니다.</p><h3 id="usage-and-policy-errors" tabindex="-1">사용 및 정책 오류 <a class="header-anchor" href="#usage-and-policy-errors" aria-label="Permalink to “사용 및 정책 오류”">​</a></h3><h4 id="invalid_purpose" tabindex="-1"><code>INVALID_PURPOSE</code> <a class="header-anchor" href="#invalid_purpose" aria-label="Permalink to “INVALID_PURPOSE”">​</a></h4><p>제공된 인증서를 지정된 용도로 사용할 수 없습니다.</p><h4 id="cert_rejected" tabindex="-1"><code>CERT_REJECTED</code> <a class="header-anchor" href="#cert_rejected" aria-label="Permalink to “CERT_REJECTED”">​</a></h4><p>루트 CA가 지정된 용도를 거부하도록 표시되었습니다.</p><h3 id="formatting-errors" tabindex="-1">서식 오류 <a class="header-anchor" href="#formatting-errors" aria-label="Permalink to “서식 오류”">​</a></h3><h4 id="cert_signature_failure" tabindex="-1"><code>CERT_SIGNATURE_FAILURE</code> <a class="header-anchor" href="#cert_signature_failure" aria-label="Permalink to “CERT_SIGNATURE_FAILURE”">​</a></h4><p>인증서의 서명이 유효하지 않습니다.</p><h4 id="crl_signature_failure" tabindex="-1"><code>CRL_SIGNATURE_FAILURE</code> <a class="header-anchor" href="#crl_signature_failure" aria-label="Permalink to “CRL_SIGNATURE_FAILURE”">​</a></h4><p>인증서 해지 목록(CRL)의 서명이 유효하지 않습니다.</p><h4 id="error_in_cert_not_before_field" tabindex="-1"><code>ERROR_IN_CERT_NOT_BEFORE_FIELD</code> <a class="header-anchor" href="#error_in_cert_not_before_field" aria-label="Permalink to “ERROR_IN_CERT_NOT_BEFORE_FIELD”">​</a></h4><p>인증서 notBefore 필드에 유효하지 않은 시간이 포함되어 있습니다.</p><h4 id="error_in_cert_not_after_field" tabindex="-1"><code>ERROR_IN_CERT_NOT_AFTER_FIELD</code> <a class="header-anchor" href="#error_in_cert_not_after_field" aria-label="Permalink to “ERROR_IN_CERT_NOT_AFTER_FIELD”">​</a></h4><p>인증서 notAfter 필드에 유효하지 않은 시간이 포함되어 있습니다.</p><h4 id="error_in_crl_last_update_field" tabindex="-1"><code>ERROR_IN_CRL_LAST_UPDATE_FIELD</code> <a class="header-anchor" href="#error_in_crl_last_update_field" aria-label="Permalink to “ERROR_IN_CRL_LAST_UPDATE_FIELD”">​</a></h4><p>CRL lastUpdate 필드에 유효하지 않은 시간이 포함되어 있습니다.</p><h4 id="error_in_crl_next_update_field" tabindex="-1"><code>ERROR_IN_CRL_NEXT_UPDATE_FIELD</code> <a class="header-anchor" href="#error_in_crl_next_update_field" aria-label="Permalink to “ERROR_IN_CRL_NEXT_UPDATE_FIELD”">​</a></h4><p>CRL nextUpdate 필드에 유효하지 않은 시간이 포함되어 있습니다.</p><h4 id="unable_to_decrypt_cert_signature" tabindex="-1"><code>UNABLE_TO_DECRYPT_CERT_SIGNATURE</code> <a class="header-anchor" href="#unable_to_decrypt_cert_signature" aria-label="Permalink to “UNABLE_TO_DECRYPT_CERT_SIGNATURE”">​</a></h4><p>인증서 서명을 해독할 수 없습니다. 이는 예상 값과 일치하지 않는 것이 아니라 실제 서명 값을 확인할 수 없음을 의미하며, RSA 키에만 의미가 있습니다.</p><h4 id="unable_to_decrypt_crl_signature" tabindex="-1"><code>UNABLE_TO_DECRYPT_CRL_SIGNATURE</code> <a class="header-anchor" href="#unable_to_decrypt_crl_signature" aria-label="Permalink to “UNABLE_TO_DECRYPT_CRL_SIGNATURE”">​</a></h4><p>인증서 해지 목록(CRL) 서명을 해독할 수 없습니다. 이는 예상 값과 일치하지 않는 것이 아니라 실제 서명 값을 확인할 수 없음을 의미합니다.</p><h4 id="unable_to_decode_issuer_public_key" tabindex="-1"><code>UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY</code> <a class="header-anchor" href="#unable_to_decode_issuer_public_key" aria-label="Permalink to “UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY”">​</a></h4><p>인증서 SubjectPublicKeyInfo의 공개 키를 읽을 수 없습니다.</p><h3 id="other-openssl-errors" tabindex="-1">기타 OpenSSL 오류 <a class="header-anchor" href="#other-openssl-errors" aria-label="Permalink to “기타 OpenSSL 오류”">​</a></h3><h4 id="out_of_mem" tabindex="-1"><code>OUT_OF_MEM</code> <a class="header-anchor" href="#out_of_mem" aria-label="Permalink to “OUT_OF_MEM”">​</a></h4><p>메모리를 할당하는 동안 오류가 발생했습니다. 이런 일은 없어야 합니다.</p>`,1159)])}var s=e(a,[[`render`,o]]);export{i as __pageData,s as default};