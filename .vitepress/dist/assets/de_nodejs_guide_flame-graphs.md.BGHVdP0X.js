import{__plugin_vue_export_helper_default as e,createElementBlock as t,createStaticVNode as n,openBlock as r}from"./chunks/plugin-vue_export-helper.Bts1mPc7.js";const i=JSON.parse(`{"title":"Flammendiagramme für die Leistungsoptimierung von Node.js","description":"Erfahren Sie, wie Sie Flammendiagramme erstellen, um die CPU-Zeit, die in Funktionen aufgewendet wird, zu visualisieren und die Leistung von Node.js zu optimieren.","frontmatter":{"title":"Flammendiagramme für die Leistungsoptimierung von Node.js","description":"Erfahren Sie, wie Sie Flammendiagramme erstellen, um die CPU-Zeit, die in Funktionen aufgewendet wird, zu visualisieren und die Leistung von Node.js zu optimieren.","head":[["meta",{"name":"og:title","content":"Flammendiagramme für die Leistungsoptimierung von Node.js | Node.js - iDoc.dev"}],["meta",{"name":"og:description","content":"Erfahren Sie, wie Sie Flammendiagramme erstellen, um die CPU-Zeit, die in Funktionen aufgewendet wird, zu visualisieren und die Leistung von Node.js zu optimieren."}],["meta",{"name":"twitter:title","content":"Flammendiagramme für die Leistungsoptimierung von Node.js | Node.js - iDoc.dev"}],["meta",{"name":"twitter:description","content":"Erfahren Sie, wie Sie Flammendiagramme erstellen, um die CPU-Zeit, die in Funktionen aufgewendet wird, zu visualisieren und die Leistung von Node.js zu optimieren."}],["link",{"rel":"canonical","href":"https://idoc.dev/de/nodejs/guide/flame-graphs"}],["meta",{"property":"og:url","content":"https://idoc.dev/de/nodejs/guide/flame-graphs"}]]},"headers":[],"relativePath":"de/nodejs/guide/flame-graphs.md","filePath":"de/nodejs/guide/flame-graphs.md","lastUpdated":null}`),a={name:`de/nodejs/guide/flame-graphs.md`};function o(e,i,a,o,s,c){return r(),t(`div`,null,i[0]||=[n(`<h1 id="flame-graphs" tabindex="-1">Flame Graphs <a class="header-anchor" href="#flame-graphs" aria-label="Permalink to “Flame Graphs”">​</a></h1><h2 id="wozu-ist-ein-flame-graph-nutzlich" tabindex="-1">Wozu ist ein Flame Graph nützlich? <a class="header-anchor" href="#wozu-ist-ein-flame-graph-nutzlich" aria-label="Permalink to “Wozu ist ein Flame Graph nützlich?”">​</a></h2><p>Flame Graphs sind eine Möglichkeit, die CPU-Zeit zu visualisieren, die in Funktionen verbracht wird. Sie können Ihnen helfen, festzustellen, wo Sie zu viel Zeit mit synchronen Operationen verbringen.</p><h2 id="wie-man-einen-flame-graph-erstellt" tabindex="-1">Wie man einen Flame Graph erstellt <a class="header-anchor" href="#wie-man-einen-flame-graph-erstellt" aria-label="Permalink to “Wie man einen Flame Graph erstellt”">​</a></h2><p>Sie haben vielleicht gehört, dass das Erstellen eines Flame Graphs für Node.js schwierig ist, aber das stimmt (nicht mehr). Solaris VMs werden nicht mehr für Flame Graphs benötigt!</p><p>Flame Graphs werden aus der <code>perf</code>-Ausgabe generiert, die kein Node-spezifisches Tool ist. Obwohl es die leistungsstärkste Möglichkeit ist, die verbrauchte CPU-Zeit zu visualisieren, kann es Probleme damit geben, wie JavaScript-Code in Node.js 8 und höher optimiert wird. Siehe Abschnitt <a href="#perf-output-issues">perf output issues</a> unten.</p><h3 id="verwenden-sie-ein-vorgefertigtes-tool" tabindex="-1">Verwenden Sie ein vorgefertigtes Tool <a class="header-anchor" href="#verwenden-sie-ein-vorgefertigtes-tool" aria-label="Permalink to “Verwenden Sie ein vorgefertigtes Tool”">​</a></h3><p>Wenn Sie einen einzelnen Schritt wünschen, der lokal einen Flame Graph erzeugt, versuchen Sie es mit <a href="https://www.npmjs.com/package/0x" target="_blank" rel="noreferrer">0x</a></p><p>Für die Diagnose von Produktionsumgebungen lesen Sie diese Hinweise: <a href="https://github.com/davidmarkclements/0x/blob/master/docs/production-servers.md" target="_blank" rel="noreferrer">0x production servers</a>.</p><h3 id="erstellen-sie-einen-flame-graph-mit-system-perf-tools" tabindex="-1">Erstellen Sie einen Flame Graph mit System-Perf-Tools <a class="header-anchor" href="#erstellen-sie-einen-flame-graph-mit-system-perf-tools" aria-label="Permalink to “Erstellen Sie einen Flame Graph mit System-Perf-Tools”">​</a></h3><p>Der Zweck dieser Anleitung ist es, die Schritte zur Erstellung eines Flame Graphs zu zeigen und Ihnen die Kontrolle über jeden Schritt zu ermöglichen.</p><p>Wenn Sie jeden Schritt besser verstehen möchten, werfen Sie einen Blick auf die folgenden Abschnitte, in denen wir detaillierter darauf eingehen.</p><p>Jetzt lasst uns an die Arbeit gehen.</p><ol><li>Installieren Sie <code>perf</code> (normalerweise über das Paket linux-tools-common verfügbar, falls noch nicht installiert)</li><li>Versuchen Sie, <code>perf</code> auszuführen - es könnte sich über fehlende Kernel-Module beschweren, installieren Sie diese ebenfalls</li><li>Führen Sie Node mit aktiviertem Perf aus (siehe <a href="#perf-output-issues">perf output issues</a> für Tipps speziell für Node.js-Versionen)</li></ol><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">perf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> record</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cycles:u</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --perf-basic-prof</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app.js</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ol start="4"><li>Ignorieren Sie Warnungen, es sei denn, sie besagen, dass Sie Perf aufgrund fehlender Pakete nicht ausführen können. Sie erhalten möglicherweise einige Warnungen, dass Sie nicht auf Kernelmodul-Samples zugreifen können, nach denen Sie sowieso nicht suchen.</li><li>Führen Sie <code>perf script &gt; perfs.out</code> aus, um die Datendatei zu generieren, die Sie gleich visualisieren werden. Es ist nützlich, etwas Bereinigung anzuwenden, um einen besser lesbaren Graphen zu erhalten</li><li>Installieren Sie Stackvis, falls noch nicht installiert <code>npm i -g stackvis</code></li><li>Führen Sie <code>stackvis perf &lt; perfs.out &gt; flamegraph.htm</code> aus</li></ol><p>Öffnen Sie nun die Flame-Graph-Datei in Ihrem Lieblingsbrowser und sehen Sie zu, wie sie brennt. Sie ist farblich gekennzeichnet, sodass Sie sich zuerst auf die am stärksten gesättigten orangefarbenen Balken konzentrieren können. Diese stellen wahrscheinlich CPU-intensive Funktionen dar.</p><p>Erwähnenswert ist, dass beim Klicken auf ein Element eines Flame Graphs eine Vergrößerung seiner Umgebung über dem Graphen angezeigt wird.</p><h3 id="verwenden-von-perf-zum-sampeln-eines-laufenden-prozesses" tabindex="-1">Verwenden von <code>perf</code> zum Sampeln eines laufenden Prozesses <a class="header-anchor" href="#verwenden-von-perf-zum-sampeln-eines-laufenden-prozesses" aria-label="Permalink to “Verwenden von perf zum Sampeln eines laufenden Prozesses”">​</a></h3><p>Dies ist ideal, um Flame-Graph-Daten von einem bereits laufenden Prozess aufzuzeichnen, den Sie nicht unterbrechen möchten. Stellen Sie sich einen Produktionsprozess mit einem schwer zu reproduzierenden Problem vor.</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">perf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> record</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -F99</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pgrep</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node\`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> --</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sleep</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Wozu dient dieses <code>sleep 3</code>? Es dient dazu, perf am Laufen zu halten - obwohl die Option <code>-p</code> auf eine andere PID verweist, muss der Befehl in einem Prozess ausgeführt werden und mit diesem enden. perf läuft für die Lebensdauer des Befehls, den Sie ihm übergeben, unabhängig davon, ob Sie diesen Befehl tatsächlich profilieren oder nicht. <code>sleep 3</code> stellt sicher, dass perf 3 Sekunden lang läuft.</p><p>Warum ist <code>-F</code> (Profiling-Frequenz) auf 99 gesetzt? Dies ist ein sinnvoller Standardwert. Sie können ihn bei Bedarf anpassen. <code>-F99</code> weist perf an, 99 Samples pro Sekunde zu nehmen. Erhöhen Sie den Wert, um eine höhere Präzision zu erzielen. Niedrigere Werte sollten weniger Ausgaben mit weniger präzisen Ergebnissen erzeugen. Die benötigte Präzision hängt davon ab, wie lange Ihre CPU-intensiven Funktionen tatsächlich laufen. Wenn Sie nach der Ursache für eine spürbare Verlangsamung suchen, sollten 99 Frames pro Sekunde mehr als ausreichend sein.</p><p>Nachdem Sie die 3-Sekunden-perf-Aufzeichnung erhalten haben, fahren Sie mit den letzten beiden Schritten von oben fort, um den Flame-Graph zu erstellen.</p><h3 id="herausfiltern-von-internen-node-js-funktionen" tabindex="-1">Herausfiltern von internen Node.js-Funktionen <a class="header-anchor" href="#herausfiltern-von-internen-node-js-funktionen" aria-label="Permalink to “Herausfiltern von internen Node.js-Funktionen”">​</a></h3><p>Normalerweise möchten Sie nur die Leistung Ihrer Aufrufe betrachten. Das Herausfiltern von internen Node.js- und V8-Funktionen kann den Graph erheblich übersichtlicher machen. Sie können Ihre perf-Datei mit folgendem Befehl bereinigen:</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sed</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -i</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -r</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/(_libc_start|LazyCompile) |v8::internal::BuiltIn|Stub|LoadIC:\\\\[\\\\[&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/^$/d&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    perf.data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> perf.out</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Wenn Ihr Flame-Graph seltsam erscheint, als ob in der Schlüsselfunktion, die die meiste Zeit beansprucht, etwas fehlt, versuchen Sie, Ihren Flame-Graph ohne die Filter zu erstellen - vielleicht haben Sie einen seltenen Fall eines Problems mit Node.js selbst.</p><h3 id="profiling-optionen-von-node-js" tabindex="-1">Profiling-Optionen von Node.js <a class="header-anchor" href="#profiling-optionen-von-node-js" aria-label="Permalink to “Profiling-Optionen von Node.js”">​</a></h3><p><code>--perf-basic-prof-only-functions</code> und <code>--perf-basic-prof</code> sind die beiden Optionen, die für das Debuggen Ihres JavaScript-Codes nützlich sind. Andere Optionen werden für das Profilieren von Node.js selbst verwendet, was jedoch außerhalb des Rahmens dieses Leitfadens liegt.</p><p><code>--perf-basic-prof-only-functions</code> erzeugt weniger Ausgaben, daher ist es die Option mit dem geringsten Overhead.</p><h3 id="warum-brauche-ich-sie-uberhaupt" tabindex="-1">Warum brauche ich sie überhaupt? <a class="header-anchor" href="#warum-brauche-ich-sie-uberhaupt" aria-label="Permalink to “Warum brauche ich sie überhaupt?”">​</a></h3><p>Nun, ohne diese Optionen erhalten Sie zwar trotzdem ein Flame Graph, aber die meisten Balken sind mit <code>v8::Function::Call</code> beschriftet.</p><h2 id="perf-ausgabe-probleme" tabindex="-1"><code>Perf</code> Ausgabe Probleme <a class="header-anchor" href="#perf-ausgabe-probleme" aria-label="Permalink to “Perf Ausgabe Probleme”">​</a></h2><h3 id="node-js-8-x-v8-pipeline-anderungen" tabindex="-1">Node.js 8.x V8 Pipeline Änderungen <a class="header-anchor" href="#node-js-8-x-v8-pipeline-anderungen" aria-label="Permalink to “Node.js 8.x V8 Pipeline Änderungen”">​</a></h3><p>Node.js 8.x und höher werden mit neuen Optimierungen an der JavaScript-Kompilierungs-Pipeline in der V8-Engine ausgeliefert, die Funktionsnamen/Referenzen für perf manchmal unerreichbar macht. (Es heißt Turbofan)</p><p>Das Ergebnis ist, dass Sie möglicherweise nicht die richtigen Funktionsnamen im Flame Graph erhalten.</p><p>Sie werden <code>ByteCodeHandler:</code> bemerken, wo Sie Funktionsnamen erwarten würden.</p><p>0x hat einige integrierte Abschwächungen dafür.</p><p>Für Details siehe:</p><ul><li><a href="https://github.com/nodejs/benchmarking/issues/168" target="_blank" rel="noreferrer">https://github.com/nodejs/benchmarking/issues/168</a></li><li><a href="https://github.com/nodejs/diagnostics/issues/148#issuecomment-369348961" target="_blank" rel="noreferrer">https://github.com/nodejs/diagnostics/issues/148#issuecomment-369348961</a></li></ul><h3 id="node-js-10" tabindex="-1">Node.js 10+ <a class="header-anchor" href="#node-js-10" aria-label="Permalink to “Node.js 10+”">​</a></h3><p>Node.js 10.x behebt das Problem mit Turbofan mit dem Flag <code>--interpreted-frames-native-stack</code>.</p><p>Führen Sie <code>node --interpreted-frames-native-stack --perf-basic-prof-only-functions</code> aus, um Funktionsnamen im Flame Graph zu erhalten, unabhängig davon, welche Pipeline V8 zum Kompilieren Ihres JavaScript verwendet hat.</p><h3 id="fehlerhafte-beschriftungen-im-flame-graph" tabindex="-1">Fehlerhafte Beschriftungen im Flame Graph <a class="header-anchor" href="#fehlerhafte-beschriftungen-im-flame-graph" aria-label="Permalink to “Fehlerhafte Beschriftungen im Flame Graph”">​</a></h3><p>Wenn Sie Beschriftungen sehen, die so aussehen</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">node</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_ZN2v88internal11interpreter17BytecodeGenerator15VisitStatementsEPMS0_8Zone</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>bedeutet dies, dass das von Ihnen verwendete Linux perf nicht mit Demangle-Unterstützung kompiliert wurde, siehe z.B. <a href="https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1396654" target="_blank" rel="noreferrer">https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1396654</a></p><h2 id="beispiele" tabindex="-1">Beispiele <a class="header-anchor" href="#beispiele" aria-label="Permalink to “Beispiele”">​</a></h2><p>Üben Sie selbst das Erstellen von Flame Graphs mit einer <a href="https://github.com/naugtur/node-example-flamegraph" target="_blank" rel="noreferrer">Flame Graph Übung</a>!</p>`,50)])}var s=e(a,[[`render`,o]]);export{i as __pageData,s as default};