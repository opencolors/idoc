import{__plugin_vue_export_helper_default as e,createElementBlock as t,createStaticVNode as n,openBlock as r}from"./chunks/plugin-vue_export-helper.Bts1mPc7.js";const i=JSON.parse(`{"title":"Node.js 소개","description":"Node.js 는 오픈소스, 크로스 플랫폼 JavaScript 런타임 환경으로, 개발자가 서버 측에서 JavaScript 를 실행할 수 있게 해주며, 높은 성능과 확장성을 제공합니다.","frontmatter":{"title":"Node.js 소개","description":"Node.js 는 오픈소스, 크로스 플랫폼 JavaScript 런타임 환경으로, 개발자가 서버 측에서 JavaScript 를 실행할 수 있게 해주며, 높은 성능과 확장성을 제공합니다.","head":[["meta",{"name":"og:title","content":"Node.js 소개 | Node.js - iDoc.dev"}],["meta",{"name":"og:description","content":"Node.js 는 오픈소스, 크로스 플랫폼 JavaScript 런타임 환경으로, 개발자가 서버 측에서 JavaScript 를 실행할 수 있게 해주며, 높은 성능과 확장성을 제공합니다."}],["meta",{"name":"twitter:title","content":"Node.js 소개 | Node.js - iDoc.dev"}],["meta",{"name":"twitter:description","content":"Node.js 는 오픈소스, 크로스 플랫폼 JavaScript 런타임 환경으로, 개발자가 서버 측에서 JavaScript 를 실행할 수 있게 해주며, 높은 성능과 확장성을 제공합니다."}],["link",{"rel":"canonical","href":"https://idoc.dev/ko/nodejs/guide/what-is-nodejs"}],["meta",{"property":"og:url","content":"https://idoc.dev/ko/nodejs/guide/what-is-nodejs"}]]},"headers":[],"relativePath":"ko/nodejs/guide/what-is-nodejs.md","filePath":"ko/nodejs/guide/what-is-nodejs.md","lastUpdated":1749464498000}`),a={name:`ko/nodejs/guide/what-is-nodejs.md`};function o(e,i,a,o,s,c){return r(),t(`div`,null,i[0]||=[n(`<h1 id="node-js-소개" tabindex="-1">Node.js 소개 <a class="header-anchor" href="#node-js-소개" aria-label="Permalink to “Node.js 소개”">​</a></h1><p>Node.js는 오픈 소스 및 크로스 플랫폼 JavaScript 런타임 환경입니다. 거의 모든 종류의 프로젝트에서 인기 있는 도구입니다!</p><p>Node.js는 Google Chrome의 핵심인 V8 JavaScript 엔진을 브라우저 외부에서 실행합니다. 이를 통해 Node.js는 매우 뛰어난 성능을 발휘할 수 있습니다.</p><p>Node.js 앱은 각 요청에 대해 새 스레드를 생성하지 않고 단일 프로세스에서 실행됩니다. Node.js는 JavaScript 코드가 차단되는 것을 방지하는 비동기 I/O 기본 요소 집합을 표준 라이브러리에서 제공하며 일반적으로 Node.js의 라이브러리는 비차단 패러다임을 사용하여 작성되므로 차단 동작은 규범보다는 예외입니다.</p><p>Node.js가 네트워크에서 읽거나 데이터베이스 또는 파일 시스템에 액세스하는 것과 같은 I/O 작업을 수행할 때 스레드를 차단하고 CPU 사이클을 낭비하는 대신 응답이 돌아오면 작업을 다시 시작합니다.</p><p>이를 통해 Node.js는 스레드 동시성 관리의 부담을 주지 않고 단일 서버로 수천 개의 동시 연결을 처리할 수 있으며 이는 버그의 중요한 원인이 될 수 있습니다.</p><p>Node.js는 브라우저용 JavaScript를 작성하는 수백만 명의 프런트엔드 개발자가 완전히 다른 언어를 배울 필요 없이 클라이언트 측 코드 외에 서버 측 코드를 작성할 수 있기 때문에 고유한 이점이 있습니다.</p><p>Node.js에서는 모든 사용자가 브라우저를 업데이트할 때까지 기다릴 필요가 없으므로 새 ECMAScript 표준을 문제 없이 사용할 수 있습니다. Node.js 버전을 변경하여 사용할 ECMAScript 버전을 결정하고 플래그와 함께 Node.js를 실행하여 특정 실험적 기능을 활성화할 수도 있습니다.</p><h2 id="node-js-애플리케이션-예제" tabindex="-1">Node.js 애플리케이션 예제 <a class="header-anchor" href="#node-js-애플리케이션-예제" aria-label="Permalink to “Node.js 애플리케이션 예제”">​</a></h2><p>Node.js의 가장 일반적인 Hello World 예제는 웹 서버입니다.</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { createServer } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;node:http&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> hostname</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;127.0.0.1&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> port</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3000</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> server</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">req</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.statusCode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 200</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setHeader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Content-Type&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;text/plain&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello World&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">server.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(port, hostname, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Server running at http://\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">hostname</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}:\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">port</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}/\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>이 스니펫을 실행하려면 <code>server.js</code> 파일로 저장하고 터미널에서 <code>node server.js</code>를 실행합니다. 코드의 mjs 버전을 사용하는 경우 <code>server.mjs</code> 파일로 저장하고 터미널에서 <code>node server.mjs</code>를 실행해야 합니다.</p><p>이 코드는 먼저 Node.js <a href="/ko/nodejs/api/http">http 모듈</a>을 포함합니다.</p><p>Node.js에는 네트워킹을 위한 최고 수준의 지원을 포함하여 환상적인 <a href="/ko/nodejs/api/synopsis">표준 라이브러리</a>가 있습니다.</p><p><code>http</code>의 <code>createServer()</code> 메서드는 새 HTTP 서버를 만들고 반환합니다.</p><p>서버는 지정된 포트 및 호스트 이름에서 수신하도록 설정됩니다. 서버가 준비되면 콜백 함수가 호출되며 이 경우 서버가 실행 중임을 알려줍니다.</p><p>새 요청이 수신될 때마다 <a href="/ko/nodejs/api/http">요청 이벤트</a>가 호출되어 요청(<code>http.IncomingMessage</code> 객체)과 응답(<code>http.ServerResponse</code> 객체)의 두 객체를 제공합니다.</p><p>이 2개의 객체는 HTTP 호출을 처리하는 데 필수적입니다.</p><p>첫 번째는 요청 세부 정보를 제공합니다. 이 간단한 예에서는 사용되지 않지만 요청 헤더 및 요청 데이터에 액세스할 수 있습니다.</p><p>두 번째는 호출자에게 데이터를 반환하는 데 사용됩니다.</p><p>이 경우:</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setHeader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Content-Type&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;text/plain&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>statusCode 속성을 200으로 설정하여 성공적인 응답을 나타냅니다.</p><p>Content-Type 헤더를 설정합니다.</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setHeader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Content-Type&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;text/plain&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>그리고 응답을 닫고 콘텐츠를 <code>end()</code>에 인수로 추가합니다.</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello World&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>이렇게 하면 응답이 클라이언트로 전송됩니다.</p>`,28)])}var s=e(a,[[`render`,o]]);export{i as __pageData,s as default};