import{__plugin_vue_export_helper_default as e,createElementBlock as t,createStaticVNode as n,openBlock as r}from"./chunks/plugin-vue_export-helper.Bts1mPc7.js";const i=JSON.parse(`{"title":"Aplicações Executáveis Únicas com Node.js","description":"Saiba como criar e gerenciar aplicações executáveis únicas com Node.js, incluindo como empacotar sua aplicação, gerenciar dependências e lidar com considerações de segurança.","frontmatter":{"title":"Aplicações Executáveis Únicas com Node.js","description":"Saiba como criar e gerenciar aplicações executáveis únicas com Node.js, incluindo como empacotar sua aplicação, gerenciar dependências e lidar com considerações de segurança.","head":[["meta",{"name":"og:title","content":"Aplicações Executáveis Únicas com Node.js | Node.js - iDoc.dev"}],["meta",{"name":"og:description","content":"Saiba como criar e gerenciar aplicações executáveis únicas com Node.js, incluindo como empacotar sua aplicação, gerenciar dependências e lidar com considerações de segurança."}],["meta",{"name":"twitter:title","content":"Aplicações Executáveis Únicas com Node.js | Node.js - iDoc.dev"}],["meta",{"name":"twitter:description","content":"Saiba como criar e gerenciar aplicações executáveis únicas com Node.js, incluindo como empacotar sua aplicação, gerenciar dependências e lidar com considerações de segurança."}],["link",{"rel":"canonical","href":"https://idoc.dev/pt/nodejs/api/single-executable-applications"}],["meta",{"property":"og:url","content":"https://idoc.dev/pt/nodejs/api/single-executable-applications"}]]},"headers":[],"relativePath":"pt/nodejs/api/single-executable-applications.md","filePath":"pt/nodejs/api/single-executable-applications.md","lastUpdated":1749464498000}`),a={name:`pt/nodejs/api/single-executable-applications.md`};function o(e,i,a,o,s,c){return r(),t(`div`,null,i[0]||=[n(`<h1 id="single-executable-applications" tabindex="-1">Aplicações executáveis únicas <a class="header-anchor" href="#single-executable-applications" aria-label="Permalink to “Aplicações executáveis únicas”">​</a></h1><div class="info custom-block"><p class="custom-block-title">[Histórico]</p><table tabindex="0"><thead><tr><th>Versão</th><th>Mudanças</th></tr></thead><tbody><tr><td>v20.6.0</td><td>Adicionado suporte para &quot;useSnapshot&quot;.</td></tr><tr><td>v20.6.0</td><td>Adicionado suporte para &quot;useCodeCache&quot;.</td></tr><tr><td>v19.7.0, v18.16.0</td><td>Adicionado em: v19.7.0, v18.16.0</td></tr></tbody></table></div><div class="warning custom-block"><p class="custom-block-title">[Estável: 1 - Experimental]</p><p><a href="/pt/nodejs/api/documentation#stability-index">Estável: 1</a> <a href="/pt/nodejs/api/documentation#stability-index">Estabilidade: 1</a>.1 - Desenvolvimento ativo</p></div><p><strong>Código Fonte:</strong> <a href="https://github.com/nodejs/node/blob/v23.5.0/src/node_sea.cc" target="_blank" rel="noreferrer">src/node_sea.cc</a></p><p>Este recurso permite a distribuição de uma aplicação Node.js convenientemente para um sistema que não tem o Node.js instalado.</p><p>Node.js suporta a criação de <a href="https://github.com/nodejs/single-executable" target="_blank" rel="noreferrer">aplicações executáveis únicas</a> permitindo a injeção de um blob preparado pelo Node.js, que pode conter um script empacotado, no binário <code>node</code>. Durante a inicialização, o programa verifica se algo foi injetado. Se o blob for encontrado, ele executa o script no blob. Caso contrário, o Node.js opera como normalmente.</p><p>O recurso de aplicação executável única atualmente suporta apenas a execução de um único script embutido usando o sistema de módulos <a href="/pt/nodejs/api/modules#modules-commonjs-modules">CommonJS</a>.</p><p>Os usuários podem criar uma aplicação executável única a partir de seu script empacotado com o próprio binário <code>node</code> e qualquer ferramenta que possa injetar recursos no binário.</p><p>Aqui estão os passos para criar uma aplicação executável única usando uma dessas ferramentas, <a href="https://github.com/nodejs/postject" target="_blank" rel="noreferrer">postject</a>:</p><h2 id="generating-single-executable-preparation-blobs" tabindex="-1">Gerando blobs de preparação para executáveis únicos <a class="header-anchor" href="#generating-single-executable-preparation-blobs" aria-label="Permalink to “Gerando blobs de preparação para executáveis únicos”">​</a></h2><p>Blobs de preparação para executáveis únicos que são injetados na aplicação podem ser gerados usando a flag <code>--experimental-sea-config</code> do binário Node.js que será usado para construir o executável único. Ele recebe um caminho para um arquivo de configuração no formato JSON. Se o caminho passado não for absoluto, o Node.js usará o caminho relativo ao diretório de trabalho atual.</p><p>A configuração atualmente lê os seguintes campos de nível superior:</p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;main&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/caminho/para/script/empacotado.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;output&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/caminho/para/escrever/o/blob/gerado.blob&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;disableExperimentalSEAWarning&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Padrão: false</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;useSnapshot&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Padrão: false</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;useCodeCache&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Padrão: false</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;assets&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Opcional</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;a.dat&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/caminho/para/a.dat&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;b.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/caminho/para/b.txt&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>Se os caminhos não forem absolutos, o Node.js usará o caminho relativo ao diretório de trabalho atual. A versão do binário Node.js usado para produzir o blob deve ser a mesma daquele no qual o blob será injetado.</p><p>Nota: Ao gerar SEAs multiplataforma (por exemplo, gerar uma SEA para <code>linux-x64</code> em <code>darwin-arm64</code>), <code>useCodeCache</code> e <code>useSnapshot</code> devem ser definidos como false para evitar gerar executáveis incompatíveis. Como o cache de código e os snapshots só podem ser carregados na mesma plataforma onde são compilados, o executável gerado pode falhar na inicialização ao tentar carregar o cache de código ou os snapshots construídos em uma plataforma diferente.</p><h3 id="assets" tabindex="-1">Recursos <a class="header-anchor" href="#assets" aria-label="Permalink to “Recursos”">​</a></h3><p>Os usuários podem incluir recursos adicionando um dicionário de chave-caminho à configuração como o campo <code>assets</code>. No momento da construção, o Node.js leria os recursos dos caminhos especificados e os agruparia no blob de preparação. No executável gerado, os usuários podem recuperar os recursos usando as APIs <a href="/pt/nodejs/api/single-executable-applications#seagetassetkey-encoding"><code>sea.getAsset()</code></a> e <a href="/pt/nodejs/api/single-executable-applications#seagetassetasblobkey-options"><code>sea.getAssetAsBlob()</code></a>.</p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;main&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/path/to/bundled/script.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;output&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/path/to/write/the/generated/blob.blob&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;assets&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;a.jpg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/path/to/a.jpg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;b.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/path/to/b.txt&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>O aplicativo executável único pode acessar os recursos da seguinte forma:</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getAsset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getAssetAsBlob</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getRawAsset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;node:sea&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Retorna uma cópia dos dados em um ArrayBuffer.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> image</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getAsset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a.jpg&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Retorna uma string decodificada do recurso como UTF8.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> text</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getAsset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;b.txt&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;utf8&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Retorna um Blob contendo o recurso.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> blob</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getAssetAsBlob</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a.jpg&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Retorna um ArrayBuffer contendo o recurso bruto sem copiar.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> raw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getRawAsset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a.jpg&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>Consulte a documentação das APIs <a href="/pt/nodejs/api/single-executable-applications#seagetassetkey-encoding"><code>sea.getAsset()</code></a>, <a href="/pt/nodejs/api/single-executable-applications#seagetassetasblobkey-options"><code>sea.getAssetAsBlob()</code></a> e <a href="/pt/nodejs/api/single-executable-applications#seagetrawassetkey"><code>sea.getRawAsset()</code></a> para obter mais informações.</p><h3 id="startup-snapshot-support" tabindex="-1">Suporte a snapshot de inicialização <a class="header-anchor" href="#startup-snapshot-support" aria-label="Permalink to “Suporte a snapshot de inicialização”">​</a></h3><p>O campo <code>useSnapshot</code> pode ser usado para habilitar o suporte a snapshot de inicialização. Nesse caso, o script <code>main</code> não seria executado quando o executável final fosse lançado. Em vez disso, ele seria executado quando o blob de preparação do aplicativo executável único fosse gerado na máquina de construção. O blob de preparação gerado incluiria então um snapshot capturando os estados inicializados pelo script <code>main</code>. O executável final com o blob de preparação injetado deserializaria o snapshot em tempo de execução.</p><p>Quando <code>useSnapshot</code> é verdadeiro, o script principal deve invocar a API <a href="/pt/nodejs/api/v8#v8startupsnapshotsetdeserializemainfunctioncallback-data"><code>v8.startupSnapshot.setDeserializeMainFunction()</code></a> para configurar o código que precisa ser executado quando o executável final for lançado pelos usuários.</p><p>O padrão típico para um aplicativo usar snapshot em um aplicativo executável único é:</p><p>As restrições gerais dos scripts de snapshot de inicialização também se aplicam ao script principal quando ele é usado para construir o snapshot para o aplicativo executável único, e o script principal pode usar a API <a href="/pt/nodejs/api/v8#startup-snapshot-api"><code>v8.startupSnapshot</code> API</a> para se adaptar a essas restrições. Consulte a <a href="/pt/nodejs/api/cli#build-snapshot">documentação sobre suporte a snapshot de inicialização no Node.js</a>.</p><h3 id="v8-code-cache-support" tabindex="-1">Suporte ao cache de código V8 <a class="header-anchor" href="#v8-code-cache-support" aria-label="Permalink to “Suporte ao cache de código V8”">​</a></h3><p>Quando <code>useCodeCache</code> é definido como <code>true</code> na configuração, durante a geração do blob de preparação executável único, o Node.js compilará o script <code>main</code> para gerar o cache de código V8. O cache de código gerado fará parte do blob de preparação e será injetado no executável final. Quando o aplicativo executável único for iniciado, em vez de compilar o script <code>main</code> do zero, o Node.js usará o cache de código para acelerar a compilação e, em seguida, executará o script, o que melhoraria o desempenho de inicialização.</p><p><strong>Nota:</strong> <code>import()</code> não funciona quando <code>useCodeCache</code> é <code>true</code>.</p><h2 id="in-the-injected-main-script" tabindex="-1">No script principal injetado <a class="header-anchor" href="#in-the-injected-main-script" aria-label="Permalink to “No script principal injetado”">​</a></h2><h3 id="single-executable-application-api" tabindex="-1">API de aplicação executável única <a class="header-anchor" href="#single-executable-application-api" aria-label="Permalink to “API de aplicação executável única”">​</a></h3><p>O builtin <code>node:sea</code> permite a interação com a aplicação executável única a partir do script principal JavaScript incorporado no executável.</p><h4 id="seaissea" tabindex="-1"><code>sea.isSea()</code> <a class="header-anchor" href="#seaissea" aria-label="Permalink to “sea.isSea()”">​</a></h4><p><strong>Adicionado em: v21.7.0, v20.12.0</strong></p><ul><li>Retorna: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" target="_blank" rel="noreferrer">&lt;boolean&gt;</a> Se este script está sendo executado dentro de uma aplicação executável única.</li></ul><h3 id="seagetassetkey-encoding" tabindex="-1"><code>sea.getAsset(key[, encoding])</code> <a class="header-anchor" href="#seagetassetkey-encoding" aria-label="Permalink to “sea.getAsset(key[, encoding])”">​</a></h3><p><strong>Adicionado em: v21.7.0, v20.12.0</strong></p><p>Este método pode ser usado para recuperar os ativos configurados para serem agrupados na aplicação executável única no momento da construção. Um erro é lançado quando nenhum ativo correspondente pode ser encontrado.</p><ul><li><code>key</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> a chave para o ativo no dicionário especificado pelo campo <code>assets</code> na configuração da aplicação executável única.</li><li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> Se especificado, o ativo será decodificado como uma string. Qualquer codificação suportada pelo <code>TextDecoder</code> é aceita. Se não especificado, um <code>ArrayBuffer</code> contendo uma cópia do ativo seria retornado em vez disso.</li><li>Retorna: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noreferrer">&lt;ArrayBuffer&gt;</a></li></ul><h3 id="seagetassetasblobkey-options" tabindex="-1"><code>sea.getAssetAsBlob(key[, options])</code> <a class="header-anchor" href="#seagetassetasblobkey-options" aria-label="Permalink to “sea.getAssetAsBlob(key[, options])”">​</a></h3><p><strong>Adicionado em: v21.7.0, v20.12.0</strong></p><p>Similar a <a href="/pt/nodejs/api/single-executable-applications#seagetassetkey-encoding"><code>sea.getAsset()</code></a>, mas retorna o resultado em um <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank" rel="noreferrer"><code>Blob</code></a>. Um erro é lançado quando nenhum recurso correspondente pode ser encontrado.</p><ul><li><p><code>key</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> a chave para o recurso no dicionário especificado pelo campo <code>assets</code> na configuração do aplicativo executável único.</p></li><li><p><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noreferrer">&lt;Object&gt;</a></p><ul><li><code>type</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> Um tipo mime opcional para o blob.</li></ul></li><li><p>Retorna: <a href="/pt/nodejs/api/buffer#class-blob">&lt;Blob&gt;</a></p></li></ul><h3 id="seagetrawassetkey" tabindex="-1"><code>sea.getRawAsset(key)</code> <a class="header-anchor" href="#seagetrawassetkey" aria-label="Permalink to “sea.getRawAsset(key)”">​</a></h3><p><strong>Adicionado em: v21.7.0, v20.12.0</strong></p><p>Este método pode ser usado para recuperar os recursos configurados para serem agrupados no aplicativo executável único no momento da construção. Um erro é lançado quando nenhum recurso correspondente pode ser encontrado.</p><p>Ao contrário de <code>sea.getAsset()</code> ou <code>sea.getAssetAsBlob()</code>, este método não retorna uma cópia. Em vez disso, ele retorna o recurso bruto agrupado dentro do executável.</p><p>Por enquanto, os usuários devem evitar escrever no buffer de array retornado. Se a seção injetada não estiver marcada como gravável ou não estiver alinhada corretamente, as gravações no buffer de array retornado provavelmente resultarão em uma falha.</p><ul><li><code>key</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" target="_blank" rel="noreferrer">&lt;string&gt;</a> a chave para o recurso no dicionário especificado pelo campo <code>assets</code> na configuração do aplicativo executável único.</li><li>Retorna: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noreferrer">&lt;ArrayBuffer&gt;</a></li></ul><h3 id="requireid-in-the-injected-main-script-is-not-file-based" tabindex="-1"><code>require(id)</code> no script principal injetado não é baseado em arquivo <a class="header-anchor" href="#requireid-in-the-injected-main-script-is-not-file-based" aria-label="Permalink to “require(id) no script principal injetado não é baseado em arquivo”">​</a></h3><p><code>require()</code> no script principal injetado não é o mesmo que o <a href="/pt/nodejs/api/modules#requireid"><code>require()</code></a> disponível para módulos que não são injetados. Ele também não possui nenhuma das propriedades que o <a href="/pt/nodejs/api/modules#requireid"><code>require()</code></a> não injetado possui, exceto <a href="/pt/nodejs/api/modules#accessing-the-main-module"><code>require.main</code></a>. Ele só pode ser usado para carregar módulos integrados. A tentativa de carregar um módulo que só pode ser encontrado no sistema de arquivos lançará um erro.</p><p>Em vez de confiar em um <code>require()</code> baseado em arquivo, os usuários podem agrupar seu aplicativo em um arquivo JavaScript independente para injetar no executável. Isso também garante um gráfico de dependência mais determinístico.</p><p>No entanto, se um <code>require()</code> baseado em arquivo ainda for necessário, isso também pode ser alcançado:</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">createRequire</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;node:module&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">require </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createRequire</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__filename);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="__filename-and-modulefilename-in-the-injected-main-script" tabindex="-1"><code>__filename</code> e <code>module.filename</code> no script principal injetado <a class="header-anchor" href="#__filename-and-modulefilename-in-the-injected-main-script" aria-label="Permalink to “__filename e module.filename no script principal injetado”">​</a></h3><p>Os valores de <code>__filename</code> e <code>module.filename</code> no script principal injetado são iguais a <a href="/pt/nodejs/api/process#processexecpath"><code>process.execPath</code></a>.</p><h3 id="__dirname-in-the-injected-main-script" tabindex="-1"><code>__dirname</code> no script principal injetado <a class="header-anchor" href="#__dirname-in-the-injected-main-script" aria-label="Permalink to “__dirname no script principal injetado”">​</a></h3><p>O valor de <code>__dirname</code> no script principal injetado é igual ao nome do diretório de <a href="/pt/nodejs/api/process#processexecpath"><code>process.execPath</code></a>.</p><h2 id="notes" tabindex="-1">Notas <a class="header-anchor" href="#notes" aria-label="Permalink to “Notas”">​</a></h2><h3 id="single-executable-application-creation-process" tabindex="-1">Processo de criação de aplicativo executável único <a class="header-anchor" href="#single-executable-application-creation-process" aria-label="Permalink to “Processo de criação de aplicativo executável único”">​</a></h3><p>Uma ferramenta com o objetivo de criar um aplicativo Node.js executável único deve injetar o conteúdo do blob preparado com <code>--experimental-sea-config&quot;</code> em:</p><ul><li>um recurso chamado <code>NODE_SEA_BLOB</code> se o binário <code>node</code> for um arquivo <a href="https://en.wikipedia.org/wiki/Portable_Executable" target="_blank" rel="noreferrer">PE</a></li><li>uma seção chamada <code>NODE_SEA_BLOB</code> no segmento <code>NODE_SEA</code> se o binário <code>node</code> for um arquivo <a href="https://en.wikipedia.org/wiki/Mach-O" target="_blank" rel="noreferrer">Mach-O</a></li><li>uma nota chamada <code>NODE_SEA_BLOB</code> se o binário <code>node</code> for um arquivo <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" target="_blank" rel="noreferrer">ELF</a></li></ul><p>Procure no binário pela string <a href="https://www.electronjs.org/docs/latest/tutorial/fuses" target="_blank" rel="noreferrer">fuse</a> <code>NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2:0</code> e inverta o último caractere para <code>1</code> para indicar que um recurso foi injetado.</p><h3 id="platform-support" tabindex="-1">Suporte de plataforma <a class="header-anchor" href="#platform-support" aria-label="Permalink to “Suporte de plataforma”">​</a></h3><p>O suporte a executável único é testado regularmente no CI apenas nas seguintes plataformas:</p><ul><li>Windows</li><li>macOS</li><li>Linux (todas as distribuições <a href="https://github.com/nodejs/node/blob/main/BUILDING.md#platform-list" target="_blank" rel="noreferrer">suportadas pelo Node.js</a> exceto Alpine e todas as arquiteturas <a href="https://github.com/nodejs/node/blob/main/BUILDING.md#platform-list" target="_blank" rel="noreferrer">suportadas pelo Node.js</a> exceto s390x)</li></ul><p>Isso se deve à falta de melhores ferramentas para gerar executáveis ​​únicos que possam ser usados ​​para testar esse recurso em outras plataformas.</p><p>Sugestões para outras ferramentas/fluxos de trabalho de injeção de recursos são bem-vindas. Por favor, inicie uma discussão em <a href="https://github.com/nodejs/single-executable/discussions" target="_blank" rel="noreferrer">https://github.com/nodejs/single-executable/discussions</a> para nos ajudar a documentá-las.</p>`,68)])}var s=e(a,[[`render`,o]]);export{i as __pageData,s as default};