import{__plugin_vue_export_helper_default as e,createElementBlock as t,createStaticVNode as n,openBlock as r}from"./chunks/plugin-vue_export-helper.Bts1mPc7.js";const i=JSON.parse(`{"title":"Flame Graphs for Node.js Performance Optimization","description":"Learn how to create flame graphs to visualize CPU time spent in functions and optimize Node.js performance.","frontmatter":{"title":"Flame Graphs for Node.js Performance Optimization","description":"Learn how to create flame graphs to visualize CPU time spent in functions and optimize Node.js performance.","head":[["meta",{"name":"og:title","content":"Flame Graphs for Node.js Performance Optimization | Node.js - iDoc.dev"}],["meta",{"name":"og:description","content":"Learn how to create flame graphs to visualize CPU time spent in functions and optimize Node.js performance."}],["meta",{"name":"twitter:title","content":"Flame Graphs for Node.js Performance Optimization | Node.js - iDoc.dev"}],["meta",{"name":"twitter:description","content":"Learn how to create flame graphs to visualize CPU time spent in functions and optimize Node.js performance."}],["link",{"rel":"canonical","href":"https://idoc.dev/nodejs/guide/flame-graphs"}],["meta",{"property":"og:url","content":"https://idoc.dev/nodejs/guide/flame-graphs"}]]},"headers":[],"relativePath":"nodejs/guide/flame-graphs.md","filePath":"en/nodejs/guide/flame-graphs.md","lastUpdated":1749464498000}`),a={name:`nodejs/guide/flame-graphs.md`};function o(e,i,a,o,s,c){return r(),t(`div`,null,i[0]||=[n(`<h1 id="flame-graphs" tabindex="-1">Flame Graphs <a class="header-anchor" href="#flame-graphs" aria-label="Permalink to “Flame Graphs”">​</a></h1><h2 id="what-s-a-flame-graph-useful-for" tabindex="-1">What&#39;s a flame graph useful for? <a class="header-anchor" href="#what-s-a-flame-graph-useful-for" aria-label="Permalink to “What&#39;s a flame graph useful for?”">​</a></h2><p>Flame graphs are a way of visualizing CPU time spent in functions. They can help you pin down where you spend too much time doing synchronous operations.</p><h2 id="how-to-create-a-flame-graph" tabindex="-1">How to create a flame graph <a class="header-anchor" href="#how-to-create-a-flame-graph" aria-label="Permalink to “How to create a flame graph”">​</a></h2><p>You might have heard creating a flame graph for Node.js is difficult, but that&#39;s not true (anymore). Solaris vms are no longer needed for flame graphs!</p><p>Flame graphs are generated from <code>perf</code> output, which is not a node-specific tool. While it&#39;s the most powerful way to visualize CPU time spent, it may have issues with how JavaScript code is optimized in Node.js 8 and above. See <a href="#perf-output-issues">perf output issues</a> section below.</p><h3 id="use-a-pre-packaged-tool" tabindex="-1">Use a pre-packaged tool <a class="header-anchor" href="#use-a-pre-packaged-tool" aria-label="Permalink to “Use a pre-packaged tool”">​</a></h3><p>If you want a single step that produces a flame graph locally, try <a href="https://www.npmjs.com/package/0x" target="_blank" rel="noreferrer">0x</a></p><p>For diagnosing production deployments, read these notes: <a href="https://github.com/davidmarkclements/0x/blob/master/docs/production-servers.md" target="_blank" rel="noreferrer">0x production servers</a>.</p><h3 id="create-a-flame-graph-with-system-perf-tools" tabindex="-1">Create a flame graph with system perf tools <a class="header-anchor" href="#create-a-flame-graph-with-system-perf-tools" aria-label="Permalink to “Create a flame graph with system perf tools”">​</a></h3><p>The purpose of this guide is to show the steps involved in creating a flame graph and keep you in control of each step.</p><p>If you want to understand each step better, take a look at the sections that follow where we go into more detail.</p><p>Now let&#39;s get to work.</p><ol><li>Install <code>perf</code> (usually available through the linux-tools-common package if not already installed)</li><li>Try running <code>perf</code> - it might complain about missing kernel modules, install them too</li><li>Run node with perf enabled (see <a href="#perf-output-issues">perf output issues</a> for tips specific to Node.js versions)</li></ol><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">perf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> record</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cycles:u</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --perf-basic-prof</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app.js</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ol start="4"><li>Disregard warnings unless they&#39;re saying you can&#39;t run perf due to missing packages; you may get some warnings about not being able to access kernel module samples which you&#39;re not after anyway.</li><li>Run <code>perf script &gt; perfs.out</code> to generate the data file you&#39;ll visualize in a moment. It&#39;s useful to apply some cleanup for a more readable graph</li><li>Install stackvis if not yet installed <code>npm i -g stackvis</code></li><li>Run <code>stackvis perf &lt; perfs.out &gt; flamegraph.htm</code></li></ol><p>Now open the flame graph file in your favorite browser and watch it burn. It&#39;s color-coded so you can focus on the most saturated orange bars first. They&#39;re likely to represent CPU heavy functions.</p><p>Worth mentioning - if you click an element of a flame graph a zoom-in of its surroundings will be displayed above the graph.</p><h3 id="using-perf-to-sample-a-running-process" tabindex="-1">Using <code>perf</code> to sample a running process <a class="header-anchor" href="#using-perf-to-sample-a-running-process" aria-label="Permalink to “Using perf to sample a running process”">​</a></h3><p>This is great for recording flame graph data from an already running process that you don&#39;t want to interrupt. Imagine a production process with a hard to reproduce issue.</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">perf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> record</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -F99</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pgrep</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node\`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> --</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sleep</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>what is that <code>sleep 3</code> for? It&#39;s there to keep the perf running - despite <code>-p</code> option pointing to a different pid, the command needs to be executed on a process and end with it. perf runs for the life of the command you pass to it, whether or not you&#39;re actually profiling that command. <code>sleep 3</code> ensures that perf runs for 3 seconds.</p><p>Why is <code>-F</code> (profiling frequency) set to 99? It&#39;s a reasonable default. You can adjust if you want. <code>-F99</code> tells perf to take 99 samples per second, for more precision increase the value. Lower values should produce less output with less precise results. The precision you need depends on how long your CPU intensive functions really run. If you&#39;re looking for the reason for a noticeable slowdown, 99 frames per second should be more than enough.</p><p>After you get that 3 second perf record, proceed with generating the flame graph with the last two steps from above.</p><h3 id="filtering-out-node-js-internal-functions" tabindex="-1">Filtering out Node.js internal functions <a class="header-anchor" href="#filtering-out-node-js-internal-functions" aria-label="Permalink to “Filtering out Node.js internal functions”">​</a></h3><p>Usually, you just want to look at the performance of your calls, so filtering out Node.js and V8 internal functions can make the graph much easier to read. You can clean up your perf file with:</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sed</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -i</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -r</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/(_libc_start|LazyCompile) |v8::internal::BuiltIn|Stub|LoadIC:\\\\[\\\\[&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/^$/d&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    perf.data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> perf.out</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>If you read your flame graph and it seems odd, as if something is missing in the key function taking up most time, try generating your flame graph without the filters - maybe you got a rare case of an issue with Node.js itself.</p><h3 id="node-js-s-profiling-options" tabindex="-1">Node.js&#39;s profiling options <a class="header-anchor" href="#node-js-s-profiling-options" aria-label="Permalink to “Node.js&#39;s profiling options”">​</a></h3><p><code>--perf-basic-prof-only-functions</code> and <code>--perf-basic-prof</code> are the two that are useful for debugging your JavaScript code. Other options are used for profiling Node.js itself, which is outside the scope of this guide.</p><p><code>--perf-basic-prof-only-functions</code> produces less output, so it&#39;s the option with the least overhead.</p><h3 id="why-do-i-need-them-at-all" tabindex="-1">Why do I need them at all? <a class="header-anchor" href="#why-do-i-need-them-at-all" aria-label="Permalink to “Why do I need them at all?”">​</a></h3><p>Well, without these options, you&#39;ll still get a flame graph, but with most bars labeled <code>v8::Function::Call</code>.</p><h2 id="perf-output-issues" tabindex="-1"><code>Perf</code> Output issues <a class="header-anchor" href="#perf-output-issues" aria-label="Permalink to “Perf Output issues”">​</a></h2><h3 id="node-js-8-x-v8-pipeline-changes" tabindex="-1">Node.js 8.x V8 pipeline changes <a class="header-anchor" href="#node-js-8-x-v8-pipeline-changes" aria-label="Permalink to “Node.js 8.x V8 pipeline changes”">​</a></h3><p>Node.js 8.x and above ships with new optimizations to the JavaScript compilation pipeline in the V8 engine which makes function names/references unreachable for perf sometimes. (It&#39;s called Turbofan)</p><p>The result is you might not get your function names right in the flame graph.</p><p>You&#39;ll notice <code>ByteCodeHandler:</code> where you&#39;d expect function names.</p><p>0x has some mitigations for that built in.</p><p>For details see:</p><ul><li><a href="https://github.com/nodejs/benchmarking/issues/168" target="_blank" rel="noreferrer">https://github.com/nodejs/benchmarking/issues/168</a></li><li><a href="https://github.com/nodejs/diagnostics/issues/148#issuecomment-369348961" target="_blank" rel="noreferrer">https://github.com/nodejs/diagnostics/issues/148#issuecomment-369348961</a></li></ul><h3 id="node-js-10" tabindex="-1">Node.js 10+ <a class="header-anchor" href="#node-js-10" aria-label="Permalink to “Node.js 10+”">​</a></h3><p>Node.js 10.x addresses the issue with Turbofan using the <code>--interpreted-frames-native-stack</code> flag.</p><p>Run <code>node --interpreted-frames-native-stack --perf-basic-prof-only-functions</code> to get function names in the flame graph regardless of which pipeline V8 used to compile your JavaScript.</p><h3 id="broken-labels-in-the-flame-graph" tabindex="-1">Broken labels in the flame graph <a class="header-anchor" href="#broken-labels-in-the-flame-graph" aria-label="Permalink to “Broken labels in the flame graph”">​</a></h3><p>If you&#39;re seeing labels looking like this</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">node</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_ZN2v88internal11interpreter17BytecodeGenerator15VisitStatementsEPMS0_8Zone</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>it means the Linux perf you&#39;re using was not compiled with demangle support, see <a href="https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1396654" target="_blank" rel="noreferrer">https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1396654</a> for example</p><h2 id="examples" tabindex="-1">Examples <a class="header-anchor" href="#examples" aria-label="Permalink to “Examples”">​</a></h2><p>Practice capturing flame graphs yourself with a <a href="https://github.com/naugtur/node-example-flamegraph" target="_blank" rel="noreferrer">flame graph exercise</a>!</p>`,50)])}var s=e(a,[[`render`,o]]);export{i as __pageData,s as default};