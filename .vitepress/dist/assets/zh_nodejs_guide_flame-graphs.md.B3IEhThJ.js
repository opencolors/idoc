import{__plugin_vue_export_helper_default as e,createElementBlock as t,createStaticVNode as n,openBlock as r}from"./chunks/plugin-vue_export-helper.Bts1mPc7.js";const i=JSON.parse(`{"title":"Node.js 性能优化中的火焰图","description":"了解如何创建火焰图来可视化 CPU 时间花费在函数中，并优化 Node.js 性能。","frontmatter":{"title":"Node.js 性能优化中的火焰图","description":"了解如何创建火焰图来可视化 CPU 时间花费在函数中，并优化 Node.js 性能。","head":[["meta",{"name":"og:title","content":"Node.js 性能优化中的火焰图 | Node.js - iDoc.dev"}],["meta",{"name":"og:description","content":"了解如何创建火焰图来可视化 CPU 时间花费在函数中，并优化 Node.js 性能。"}],["meta",{"name":"twitter:title","content":"Node.js 性能优化中的火焰图 | Node.js - iDoc.dev"}],["meta",{"name":"twitter:description","content":"了解如何创建火焰图来可视化 CPU 时间花费在函数中，并优化 Node.js 性能。"}],["link",{"rel":"canonical","href":"https://idoc.dev/zh/nodejs/guide/flame-graphs"}],["meta",{"property":"og:url","content":"https://idoc.dev/zh/nodejs/guide/flame-graphs"}]]},"headers":[],"relativePath":"zh/nodejs/guide/flame-graphs.md","filePath":"zh/nodejs/guide/flame-graphs.md","lastUpdated":null}`),a={name:`zh/nodejs/guide/flame-graphs.md`};function o(e,i,a,o,s,c){return r(),t(`div`,null,i[0]||=[n(`<h1 id="火焰图" tabindex="-1">火焰图 <a class="header-anchor" href="#火焰图" aria-label="Permalink to “火焰图”">​</a></h1><h2 id="火焰图有什么用" tabindex="-1">火焰图有什么用？ <a class="header-anchor" href="#火焰图有什么用" aria-label="Permalink to “火焰图有什么用？”">​</a></h2><p>火焰图是一种可视化函数中花费的 CPU 时间的方式。它们可以帮助你确定在同步操作上花费过多时间的地方。</p><h2 id="如何创建火焰图" tabindex="-1">如何创建火焰图 <a class="header-anchor" href="#如何创建火焰图" aria-label="Permalink to “如何创建火焰图”">​</a></h2><p>你可能听说过为 Node.js 创建火焰图很困难，但事实并非如此（现在不是了）。不再需要 Solaris 虚拟机来生成火焰图了！</p><p>火焰图由 <code>perf</code> 输出生成，这不是一个特定于 Node 的工具。虽然它是可视化 CPU 时间花费的最强大的方式，但它可能在 Node.js 8 及更高版本中对 JavaScript 代码的优化存在问题。请参阅下面的 <a href="#perf-output-issues">perf 输出问题</a> 部分。</p><h3 id="使用预打包的工具" tabindex="-1">使用预打包的工具 <a class="header-anchor" href="#使用预打包的工具" aria-label="Permalink to “使用预打包的工具”">​</a></h3><p>如果你想要一个可以在本地生成火焰图的单步操作，请尝试 <a href="https://www.npmjs.com/package/0x" target="_blank" rel="noreferrer">0x</a></p><p>对于诊断生产环境部署，请阅读这些说明：<a href="https://github.com/davidmarkclements/0x/blob/master/docs/production-servers.md" target="_blank" rel="noreferrer">0x 生产服务器</a>。</p><h3 id="使用系统-perf-工具创建火焰图" tabindex="-1">使用系统 perf 工具创建火焰图 <a class="header-anchor" href="#使用系统-perf-工具创建火焰图" aria-label="Permalink to “使用系统 perf 工具创建火焰图”">​</a></h3><p>本指南的目的是展示创建火焰图所涉及的步骤，并让你控制每个步骤。</p><p>如果你想更好地理解每个步骤，请查看后面的章节，在那里我们将更详细地介绍。</p><p>现在开始工作吧。</p><ol><li>安装 <code>perf</code>（如果尚未安装，通常可以通过 linux-tools-common 包获得）</li><li>尝试运行 <code>perf</code> - 它可能会抱怨缺少内核模块，也安装它们</li><li>运行启用 perf 的 node (有关特定于 Node.js 版本的提示，请参阅 <a href="#perf-output-issues">perf 输出问题</a>)</li></ol><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">perf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> record</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cycles:u</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --perf-basic-prof</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app.js</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ol start="4"><li>忽略警告，除非它们说由于缺少软件包而无法运行 perf；你可能会收到一些关于无法访问内核模块样本的警告，你无论如何都不需要它们。</li><li>运行 <code>perf script &gt; perfs.out</code> 来生成你稍后将可视化的数据文件。应用一些清理以获得更易读的图表是很有用的</li><li>如果尚未安装 stackvis，请安装它 <code>npm i -g stackvis</code></li><li>运行 <code>stackvis perf &lt; perfs.out &gt; flamegraph.htm</code></li></ol><p>现在在您喜欢的浏览器中打开火焰图文件并观看它燃烧。它是颜色编码的，因此您可以首先关注最饱和的橙色条。它们可能代表 CPU 密集型函数。</p><p>值得一提的是 - 如果你点击火焰图的元素，该元素周围环境的放大视图将显示在图表上方。</p><h3 id="使用-perf-采样运行中的进程" tabindex="-1">使用 <code>perf</code> 采样运行中的进程 <a class="header-anchor" href="#使用-perf-采样运行中的进程" aria-label="Permalink to “使用 perf 采样运行中的进程”">​</a></h3><p>这非常适合从一个正在运行的，你不想中断的进程中记录火焰图数据。想象一下，一个生产环境的进程出现了一个难以重现的问题。</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">perf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> record</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -F99</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pgrep</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node\`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> --</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sleep</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><code>sleep 3</code> 是做什么用的？它的作用是保持 perf 运行 —— 尽管 <code>-p</code> 选项指向了不同的 pid，但该命令需要在进程上执行并随之结束。perf 在你传递给它的命令的生命周期内运行，无论你是否真的在分析该命令。<code>sleep 3</code> 确保 perf 运行 3 秒钟。</p><p>为什么 <code>-F</code>（分析频率）设置为 99？这是一个合理的默认值。你可以根据需要进行调整。<code>-F99</code> 告诉 perf 每秒采集 99 个样本，如果想要更高的精度，可以增加这个值。较低的值会产生较少的输出，但结果精度较低。你需要的精度取决于你的 CPU 密集型函数实际运行的时间。如果你正在寻找导致明显减速的原因，那么每秒 99 帧应该足够了。</p><p>在你获得 3 秒的 perf 记录后，按照上面的最后两个步骤生成火焰图。</p><h3 id="过滤掉-node-js-内部函数" tabindex="-1">过滤掉 Node.js 内部函数 <a class="header-anchor" href="#过滤掉-node-js-内部函数" aria-label="Permalink to “过滤掉 Node.js 内部函数”">​</a></h3><p>通常，你只想查看你的调用的性能，因此过滤掉 Node.js 和 V8 内部函数可以使图形更容易阅读。你可以使用以下命令清理 perf 文件：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sed</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -i</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -r</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/(_libc_start|LazyCompile) |v8::internal::BuiltIn|Stub|LoadIC:\\\\[\\\\[&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/^$/d&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    perf.data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> perf.out</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如果你阅读火焰图时发现有些奇怪，好像在占用大部分时间的关键函数中缺少了某些东西，请尝试不使用过滤器生成火焰图 —— 也许你遇到了 Node.js 本身问题的罕见情况。</p><h3 id="node-js-的-profiling-选项" tabindex="-1">Node.js 的 profiling 选项 <a class="header-anchor" href="#node-js-的-profiling-选项" aria-label="Permalink to “Node.js 的 profiling 选项”">​</a></h3><p><code>--perf-basic-prof-only-functions</code> 和 <code>--perf-basic-prof</code> 这两个选项对于调试你的 JavaScript 代码非常有用。其他选项用于分析 Node.js 本身，这超出了本指南的范围。</p><p><code>--perf-basic-prof-only-functions</code> 产生的输出较少，因此它是开销最小的选项。</p><h3 id="为什么我需要它们" tabindex="-1">为什么我需要它们？ <a class="header-anchor" href="#为什么我需要它们" aria-label="Permalink to “为什么我需要它们？”">​</a></h3><p>嗯，如果没有这些选项，你仍然会得到火焰图，但大多数条都会被标记为 <code>v8::Function::Call</code>。</p><h2 id="perf-输出问题" tabindex="-1"><code>Perf</code> 输出问题 <a class="header-anchor" href="#perf-输出问题" aria-label="Permalink to “Perf 输出问题”">​</a></h2><h3 id="node-js-8-x-v8-管道更改" tabindex="-1">Node.js 8.x V8 管道更改 <a class="header-anchor" href="#node-js-8-x-v8-管道更改" aria-label="Permalink to “Node.js 8.x V8 管道更改”">​</a></h3><p>Node.js 8.x 及以上版本对 V8 引擎中的 JavaScript 编译管道进行了新的优化，这使得有时 <code>perf</code> 无法访问函数名称/引用。（它被称为 Turbofan）</p><p>结果是，您可能无法在火焰图中正确获取您的函数名称。</p><p>您会注意到 <code>ByteCodeHandler:</code> 出现在您期望函数名称的地方。</p><p>0x 内置了一些缓解措施。</p><p>有关详细信息，请参见：</p><ul><li><a href="https://github.com/nodejs/benchmarking/issues/168" target="_blank" rel="noreferrer">https://github.com/nodejs/benchmarking/issues/168</a></li><li><a href="https://github.com/nodejs/diagnostics/issues/148#issuecomment-369348961" target="_blank" rel="noreferrer">https://github.com/nodejs/diagnostics/issues/148#issuecomment-369348961</a></li></ul><h3 id="node-js-10" tabindex="-1">Node.js 10+ <a class="header-anchor" href="#node-js-10" aria-label="Permalink to “Node.js 10+”">​</a></h3><p>Node.js 10.x 使用 <code>--interpreted-frames-native-stack</code> 标志解决了 Turbofan 的问题。</p><p>运行 <code>node --interpreted-frames-native-stack --perf-basic-prof-only-functions</code> 以在火焰图中获取函数名称，而不管 V8 使用哪个管道来编译您的 JavaScript。</p><h3 id="火焰图中的标签损坏" tabindex="-1">火焰图中的标签损坏 <a class="header-anchor" href="#火焰图中的标签损坏" aria-label="Permalink to “火焰图中的标签损坏”">​</a></h3><p>如果您看到的标签看起来像这样</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">node</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_ZN2v88internal11interpreter17BytecodeGenerator15VisitStatementsEPMS0_8Zone</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这意味着您使用的 Linux perf 没有使用 demangle 支持编译，例如，请参见 <a href="https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1396654" target="_blank" rel="noreferrer">https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1396654</a></p><h2 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to “示例”">​</a></h2><p>通过<a href="https://github.com/naugtur/node-example-flamegraph" target="_blank" rel="noreferrer">火焰图练习</a>自己练习捕获火焰图！</p>`,50)])}var s=e(a,[[`render`,o]]);export{i as __pageData,s as default};