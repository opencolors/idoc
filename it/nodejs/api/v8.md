---
title: Documentazione del modulo v8 di Node.js
description: Il modulo v8 in Node.js fornisce un'API per interagire con il motore JavaScript V8, inclusa la serializzazione, deserializzazione e gestione della memoria.
head:
  - - meta
    - name: og:title
      content: Documentazione del modulo v8 di Node.js | Node.js - iDoc.dev
  - - meta
    - name: og:description
      content: Il modulo v8 in Node.js fornisce un'API per interagire con il motore JavaScript V8, inclusa la serializzazione, deserializzazione e gestione della memoria.
  - - meta
    - name: twitter:title
      content: Documentazione del modulo v8 di Node.js | Node.js - iDoc.dev
  - - meta
    - name: twitter:description
      content: Il modulo v8 in Node.js fornisce un'API per interagire con il motore JavaScript V8, inclusa la serializzazione, deserializzazione e gestione della memoria.
---


# V8 {#v8}

**Codice sorgente:** [lib/v8.js](https://github.com/nodejs/node/blob/v23.5.0/lib/v8.js)

Il modulo `node:v8` espone API specifiche per la versione di [V8](https://developers.google.com/v8/) integrata nel binario di Node.js. È possibile accedervi utilizzando:

```js [ESM]
const v8 = require('node:v8');
```
## `v8.cachedDataVersionTag()` {#v8cacheddataversiontag}

**Aggiunto in: v8.0.0**

- Restituisce: [\<integer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

Restituisce un numero intero che rappresenta un tag di versione derivato dalla versione di V8, dai flag della riga di comando e dalle funzionalità della CPU rilevate. Ciò è utile per determinare se un buffer `cachedData` di [`vm.Script`](/it/nodejs/api/vm#new-vmscriptcode-options) è compatibile con questa istanza di V8.

```js [ESM]
console.log(v8.cachedDataVersionTag()); // 3947234607
// Il valore restituito da v8.cachedDataVersionTag() deriva dalla versione di V8,
// dai flag della riga di comando e dalle funzionalità della CPU rilevate. Verifica
// che il valore si aggiorni effettivamente quando i flag vengono attivati/disattivati.
v8.setFlagsFromString('--allow_natives_syntax');
console.log(v8.cachedDataVersionTag()); // 183726201
```
## `v8.getHeapCodeStatistics()` {#v8getheapcodestatistics}

**Aggiunto in: v12.8.0**

- Restituisce: [\<Object\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

Ottiene statistiche sul codice e sui suoi metadati nell'heap, vedi l'API V8 [`GetHeapCodeAndMetadataStatistics`](https://v8docs.nodesource.com/node-13.2/d5/dda/classv8_1_1_isolate#a6079122af17612ef54ef3348ce170866). Restituisce un oggetto con le seguenti proprietà:

- `code_and_metadata_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `bytecode_and_metadata_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `external_script_source_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `cpu_profiler_metadata_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

```js [ESM]
{
  code_and_metadata_size: 212208,
  bytecode_and_metadata_size: 161368,
  external_script_source_size: 1410794,
  cpu_profiler_metadata_size: 0,
}
```

## `v8.getHeapSnapshot([options])` {#v8getheapsnapshotoptions}


::: info [Cronologia]
| Versione | Modifiche |
| --- | --- |
| v19.1.0 | Supporta le opzioni per configurare l'istantanea dell'heap. |
| v11.13.0 | Aggiunto in: v11.13.0 |
:::

-  `options` [\<Object\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    - `exposeInternals` [\<boolean\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) Se vero, espone gli elementi interni nell'istantanea dell'heap. **Predefinito:** `false`.
    - `exposeNumericValues` [\<boolean\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) Se vero, espone i valori numerici in campi artificiali. **Predefinito:** `false`.
  
 
-  Restituisce: [\<stream.Readable\>](/it/nodejs/api/stream#class-streamreadable) Un Readable contenente l'istantanea dell'heap V8.

Genera un'istantanea dell'heap V8 corrente e restituisce uno Stream Readable che può essere utilizzato per leggere la rappresentazione serializzata in JSON. Questo formato di flusso JSON è destinato all'uso con strumenti come Chrome DevTools. Lo schema JSON non è documentato ed è specifico del motore V8. Pertanto, lo schema potrebbe cambiare da una versione di V8 all'altra.

La creazione di un'istantanea dell'heap richiede una memoria di circa il doppio della dimensione dell'heap al momento della creazione dell'istantanea. Ciò comporta il rischio che i killer OOM terminino il processo.

La generazione di un'istantanea è un'operazione sincrona che blocca il ciclo di eventi per una durata dipendente dalla dimensione dell'heap.

```js [ESM]
// Stampa l'istantanea dell'heap sulla console
const v8 = require('node:v8');
const stream = v8.getHeapSnapshot();
stream.pipe(process.stdout);
```
## `v8.getHeapSpaceStatistics()` {#v8getheapspacestatistics}


::: info [Cronologia]
| Versione | Modifiche |
| --- | --- |
| v7.5.0 | Supporta valori che superano l'intervallo intero senza segno a 32 bit. |
| v6.0.0 | Aggiunto in: v6.0.0 |
:::

- Restituisce: [\<Object[]\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

Restituisce statistiche sugli spazi heap V8, ovvero i segmenti che compongono l'heap V8. Né l'ordinamento degli spazi heap, né la disponibilità di uno spazio heap possono essere garantiti in quanto le statistiche sono fornite tramite la funzione V8 [`GetHeapSpaceStatistics`](https://v8docs.nodesource.com/node-13.2/d5/dda/classv8_1_1_isolate#ac673576f24fdc7a33378f8f57e1d13a4) e potrebbero cambiare da una versione V8 all'altra.

Il valore restituito è un array di oggetti contenenti le seguenti proprietà:

- `space_name` [\<string\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
- `space_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `space_used_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `space_available_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `physical_space_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

```json [JSON]
[
  {
    "space_name": "new_space",
    "space_size": 2063872,
    "space_used_size": 951112,
    "space_available_size": 80824,
    "physical_space_size": 2063872
  },
  {
    "space_name": "old_space",
    "space_size": 3090560,
    "space_used_size": 2493792,
    "space_available_size": 0,
    "physical_space_size": 3090560
  },
  {
    "space_name": "code_space",
    "space_size": 1260160,
    "space_used_size": 644256,
    "space_available_size": 960,
    "physical_space_size": 1260160
  },
  {
    "space_name": "map_space",
    "space_size": 1094160,
    "space_used_size": 201608,
    "space_available_size": 0,
    "physical_space_size": 1094160
  },
  {
    "space_name": "large_object_space",
    "space_size": 0,
    "space_used_size": 0,
    "space_available_size": 1490980608,
    "physical_space_size": 0
  }
]
```

## `v8.getHeapStatistics()` {#v8getheapstatistics}

::: info [Cronologia]
| Versione | Modifiche |
| --- | --- |
| v7.5.0 | Supporta valori che superano l'intervallo di interi senza segno a 32 bit. |
| v7.2.0 | Aggiunti `malloced_memory`, `peak_malloced_memory` e `does_zap_garbage`. |
| v1.0.0 | Aggiunto in: v1.0.0 |
:::

- Restituisce: [\<Object\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

Restituisce un oggetto con le seguenti proprietà:

- `total_heap_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `total_heap_size_executable` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `total_physical_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `total_available_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `used_heap_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `heap_size_limit` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `malloced_memory` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `peak_malloced_memory` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `does_zap_garbage` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `number_of_native_contexts` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `number_of_detached_contexts` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `total_global_handles_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `used_global_handles_size` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `external_memory` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

`total_heap_size` Il valore di total_heap_size è il numero di byte che V8 ha allocato per l'heap. Questo può crescere se used_heap ha bisogno di più memoria.

`total_heap_size_executable` Il valore di total_heap_size_executable è la porzione dell'heap che può contenere codice eseguibile, in byte. Questo include la memoria utilizzata dal codice compilato JIT e qualsiasi memoria che deve essere mantenuta eseguibile.

`total_physical_size` Il valore di total_physical_size è la memoria fisica effettiva utilizzata dall'heap di V8, in byte. Questa è la quantità di memoria che è stata impegnata (o in uso) piuttosto che riservata.

`total_available_size` Il valore di total_available_size è il numero di byte di memoria disponibile per l'heap di V8. Questo valore rappresenta quanta memoria in più V8 può utilizzare prima di superare il limite dell'heap.

`used_heap_size` Il valore di used_heap_size è il numero di byte attualmente utilizzati dagli oggetti JavaScript di V8. Questa è la memoria effettiva in uso e non include la memoria che è stata allocata ma non ancora utilizzata.

`heap_size_limit` Il valore di heap_size_limit è la dimensione massima dell'heap di V8, in byte (o il limite predefinito, determinato dalle risorse di sistema, o il valore passato all'opzione `--max_old_space_size`).

`malloced_memory` Il valore di malloced_memory è il numero di byte allocati tramite `malloc` da V8.

`peak_malloced_memory` Il valore di peak_malloced_memory è il numero massimo di byte allocati tramite `malloc` da V8 durante la durata del processo.

`does_zap_garbage` è un valore booleano 0/1, che indica se l'opzione `--zap_code_space` è abilitata o meno. Questo fa sì che V8 sovrascriva la spazzatura dell'heap con un pattern di bit. L'impronta RSS (resident set size) diventa più grande perché tocca continuamente tutte le pagine dell'heap e questo le rende meno probabili da scambiare dal sistema operativo.

`number_of_native_contexts` Il valore di native_context è il numero di contesti di livello superiore attualmente attivi. L'aumento di questo numero nel tempo indica una perdita di memoria.

`number_of_detached_contexts` Il valore di detached_context è il numero di contesti che sono stati staccati e non ancora sottoposti a garbage collection. Questo numero diverso da zero indica una potenziale perdita di memoria.

`total_global_handles_size` Il valore di total_global_handles_size è la dimensione totale della memoria degli handle globali V8.

`used_global_handles_size` Il valore di used_global_handles_size è la dimensione della memoria utilizzata degli handle globali V8.

`external_memory` Il valore di external_memory è la dimensione della memoria dei buffer di array e delle stringhe esterne.

```js [ESM]
{
  total_heap_size: 7326976,
  total_heap_size_executable: 4194304,
  total_physical_size: 7326976,
  total_available_size: 1152656,
  used_heap_size: 3476208,
  heap_size_limit: 1535115264,
  malloced_memory: 16384,
  peak_malloced_memory: 1127496,
  does_zap_garbage: 0,
  number_of_native_contexts: 1,
  number_of_detached_contexts: 0,
  total_global_handles_size: 8192,
  used_global_handles_size: 3296,
  external_memory: 318824
}
```

## `v8.queryObjects(ctor[, options])` {#v8queryobjectsctor-options}

**Aggiunto in: v22.0.0, v20.13.0**

::: warning [Stable: 1 - Sperimentale]
[Stable: 1](/it/nodejs/api/documentation#stability-index) [Stabilità: 1](/it/nodejs/api/documentation#stability-index).1 - Sviluppo attivo
:::

- `ctor` [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Il costruttore che può essere utilizzato per cercare nella catena del prototipo al fine di filtrare gli oggetti target nell'heap.
- `options` [\<undefined\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type) | [\<Object\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    - `format` [\<string\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) Se è `'count'`, viene restituito il conteggio degli oggetti corrispondenti. Se è `'summary'`, viene restituito un array con stringhe di riepilogo degli oggetti corrispondenti.
  
 
- Restituisce: {number|Array

Questo è simile alla [`queryObjects()` console API](https://developer.chrome.com/docs/devtools/console/utilities#queryObjects-function) fornita dalla console di Chromium DevTools. Può essere utilizzato per cercare oggetti che hanno il costruttore corrispondente nella sua catena del prototipo nell'heap dopo una garbage collection completa, il che può essere utile per i test di regressione delle perdite di memoria. Per evitare risultati sorprendenti, gli utenti dovrebbero evitare di utilizzare questa API su costruttori di cui non controllano l'implementazione o su costruttori che possono essere invocati da altre parti nell'applicazione.

Per evitare perdite accidentali, questa API non restituisce riferimenti raw agli oggetti trovati. Per impostazione predefinita, restituisce il conteggio degli oggetti trovati. Se `options.format` è `'summary'`, restituisce un array contenente brevi rappresentazioni stringa per ciascun oggetto. La visibilità fornita in questa API è simile a quella fornita dallo snapshot dell'heap, mentre gli utenti possono risparmiare il costo della serializzazione e dell'analisi e filtrare direttamente gli oggetti target durante la ricerca.

Solo gli oggetti creati nel contesto di esecuzione corrente sono inclusi nei risultati.

::: code-group
```js [CJS]
const { queryObjects } = require('node:v8');
class A { foo = 'bar'; }
console.log(queryObjects(A)); // 0
const a = new A();
console.log(queryObjects(A)); // 1
// [ "A { foo: 'bar' }" ]
console.log(queryObjects(A, { format: 'summary' }));

class B extends A { bar = 'qux'; }
const b = new B();
console.log(queryObjects(B)); // 1
// [ "B { foo: 'bar', bar: 'qux' }" ]
console.log(queryObjects(B, { format: 'summary' }));

// Note that, when there are child classes inheriting from a constructor,
// the constructor also shows up in the prototype chain of the child
// classes's prototype, so the child classes's prototype would also be
// included in the result.
console.log(queryObjects(A));  // 3
// [ "B { foo: 'bar', bar: 'qux' }", 'A {}', "A { foo: 'bar' }" ]
console.log(queryObjects(A, { format: 'summary' }));
```

```js [ESM]
import { queryObjects } from 'node:v8';
class A { foo = 'bar'; }
console.log(queryObjects(A)); // 0
const a = new A();
console.log(queryObjects(A)); // 1
// [ "A { foo: 'bar' }" ]
console.log(queryObjects(A, { format: 'summary' }));

class B extends A { bar = 'qux'; }
const b = new B();
console.log(queryObjects(B)); // 1
// [ "B { foo: 'bar', bar: 'qux' }" ]
console.log(queryObjects(B, { format: 'summary' }));

// Note that, when there are child classes inheriting from a constructor,
// the constructor also shows up in the prototype chain of the child
// classes's prototype, so the child classes's prototype would also be
// included in the result.
console.log(queryObjects(A));  // 3
// [ "B { foo: 'bar', bar: 'qux' }", 'A {}', "A { foo: 'bar' }" ]
console.log(queryObjects(A, { format: 'summary' }));
```
:::


## `v8.setFlagsFromString(flags)` {#v8setflagsfromstringflags}

**Aggiunto in: v1.0.0**

- `flags` [\<stringa\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

Il metodo `v8.setFlagsFromString()` può essere utilizzato per impostare programmaticamente i flag della riga di comando di V8. Questo metodo dovrebbe essere usato con cautela. La modifica delle impostazioni dopo l'avvio della VM può comportare comportamenti imprevedibili, inclusi arresti anomali e perdita di dati; oppure potrebbe semplicemente non fare nulla.

Le opzioni V8 disponibili per una versione di Node.js possono essere determinate eseguendo `node --v8-options`.

Utilizzo:

```js [ESM]
// Stampa gli eventi GC su stdout per un minuto.
const v8 = require('node:v8');
v8.setFlagsFromString('--trace_gc');
setTimeout(() => { v8.setFlagsFromString('--notrace_gc'); }, 60e3);
```
## `v8.stopCoverage()` {#v8stopcoverage}

**Aggiunto in: v15.1.0, v14.18.0, v12.22.0**

Il metodo `v8.stopCoverage()` consente all'utente di interrompere la raccolta della copertura iniziata da [`NODE_V8_COVERAGE`](/it/nodejs/api/cli#node_v8_coveragedir), in modo che V8 possa rilasciare i record del conteggio delle esecuzioni e ottimizzare il codice. Questo può essere usato in combinazione con [`v8.takeCoverage()`](/it/nodejs/api/v8#v8takecoverage) se l'utente vuole raccogliere la copertura su richiesta.

## `v8.takeCoverage()` {#v8takecoverage}

**Aggiunto in: v15.1.0, v14.18.0, v12.22.0**

Il metodo `v8.takeCoverage()` consente all'utente di scrivere su disco la copertura avviata da [`NODE_V8_COVERAGE`](/it/nodejs/api/cli#node_v8_coveragedir) su richiesta. Questo metodo può essere invocato più volte durante la durata del processo. Ogni volta il contatore di esecuzione verrà resettato e un nuovo report di copertura verrà scritto nella directory specificata da [`NODE_V8_COVERAGE`](/it/nodejs/api/cli#node_v8_coveragedir).

Quando il processo sta per terminare, un'ultima copertura verrà comunque scritta su disco a meno che non venga invocato [`v8.stopCoverage()`](/it/nodejs/api/v8#v8stopcoverage) prima che il processo termini.

## `v8.writeHeapSnapshot([filename[,options]])` {#v8writeheapsnapshotfilenameoptions}


::: info [Cronologia]
| Versione | Modifiche |
| --- | --- |
| v19.1.0 | Supporta opzioni per configurare l'heap snapshot. |
| v18.0.0 | Ora verrà generata un'eccezione se il file non può essere scritto. |
| v18.0.0 | Rendi i codici di errore restituiti coerenti su tutte le piattaforme. |
| v11.13.0 | Aggiunto in: v11.13.0 |
:::

- `filename` [\<stringa\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) Il percorso del file in cui deve essere salvato l'heap snapshot di V8. Se non specificato, verrà generato un nome file con il pattern `'Heap-${yyyymmdd}-${hhmmss}-${pid}-${thread_id}.heapsnapshot'`, dove `{pid}` sarà il PID del processo Node.js, `{thread_id}` sarà `0` quando `writeHeapSnapshot()` viene chiamato dal thread principale di Node.js o l'id di un thread worker.
- `options` [\<Oggetto\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    - `exposeInternals` [\<booleano\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) Se true, espone gli interni nell'heap snapshot. **Predefinito:** `false`.
    - `exposeNumericValues` [\<booleano\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) Se true, espone valori numerici in campi artificiali. **Predefinito:** `false`.


- Restituisce: [\<stringa\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) Il nome del file in cui è stato salvato lo snapshot.

Genera uno snapshot dell'heap V8 corrente e lo scrive in un file JSON. Questo file è destinato all'uso con strumenti come Chrome DevTools. Lo schema JSON non è documentato e specifico per il motore V8 e può cambiare da una versione di V8 all'altra.

Un heap snapshot è specifico per un singolo isolato V8. Quando si utilizzano i [thread worker](/it/nodejs/api/worker_threads), un heap snapshot generato dal thread principale non conterrà alcuna informazione sui worker e viceversa.

La creazione di un heap snapshot richiede una memoria di circa il doppio della dimensione dell'heap al momento della creazione dello snapshot. Ciò comporta il rischio che gli OOM killer terminino il processo.

La generazione di uno snapshot è un'operazione sincrona che blocca l'event loop per una durata dipendente dalla dimensione dell'heap.

```js [ESM]
const { writeHeapSnapshot } = require('node:v8');
const {
  Worker,
  isMainThread,
  parentPort,
} = require('node:worker_threads');

if (isMainThread) {
  const worker = new Worker(__filename);

  worker.once('message', (filename) => {
    console.log(`worker heapdump: ${filename}`);
    // Now get a heapdump for the main thread.
    console.log(`main thread heapdump: ${writeHeapSnapshot()}`);
  });

  // Tell the worker to create a heapdump.
  worker.postMessage('heapdump');
} else {
  parentPort.once('message', (message) => {
    if (message === 'heapdump') {
      // Generate a heapdump for the worker
      // and return the filename to the parent.
      parentPort.postMessage(writeHeapSnapshot());
    }
  });
}
```

## `v8.setHeapSnapshotNearHeapLimit(limit)` {#v8setheapsnapshotnearheaplimitlimit}

**Aggiunto in: v18.10.0, v16.18.0**

::: warning [Stabile: 1 - Sperimentale]
[Stabile: 1](/it/nodejs/api/documentation#stability-index) [Stabilità: 1](/it/nodejs/api/documentation#stability-index) - Sperimentale
:::

- `limit` [\<integer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

L'API è un no-op se `--heapsnapshot-near-heap-limit` è già stato impostato dalla riga di comando o se l'API viene chiamata più di una volta. `limit` deve essere un numero intero positivo. Consulta [`--heapsnapshot-near-heap-limit`](/it/nodejs/api/cli#--heapsnapshot-near-heap-limitmax_count) per maggiori informazioni.

## API di serializzazione {#serialization-api}

L'API di serializzazione fornisce mezzi per serializzare i valori JavaScript in un modo compatibile con l'[algoritmo di clonazione strutturata HTML](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm).

Il formato è retrocompatibile (ovvero sicuro da memorizzare su disco). Valori JavaScript uguali possono produrre output serializzati diversi.

### `v8.serialize(value)` {#v8serializevalue}

**Aggiunto in: v8.0.0**

- `value` [\<any\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)
- Restituisce: [\<Buffer\>](/it/nodejs/api/buffer#class-buffer)

Utilizza un [`DefaultSerializer`](/it/nodejs/api/v8#class-v8defaultserializer) per serializzare `value` in un buffer.

[`ERR_BUFFER_TOO_LARGE`](/it/nodejs/api/errors#err_buffer_too_large) verrà generato quando si tenta di serializzare un oggetto enorme che richiede un buffer più grande di [`buffer.constants.MAX_LENGTH`](/it/nodejs/api/buffer#bufferconstantsmax_length).

### `v8.deserialize(buffer)` {#v8deserializebuffer}

**Aggiunto in: v8.0.0**

- `buffer` [\<Buffer\>](/it/nodejs/api/buffer#class-buffer) | [\<TypedArray\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [\<DataView\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) Un buffer restituito da [`serialize()`](/it/nodejs/api/v8#v8serializevalue).

Utilizza un [`DefaultDeserializer`](/it/nodejs/api/v8#class-v8defaultdeserializer) con opzioni predefinite per leggere un valore JS da un buffer.


### Classe: `v8.Serializer` {#class-v8serializer}

**Aggiunto in: v8.0.0**

#### `new Serializer()` {#new-serializer}

Crea un nuovo oggetto `Serializer`.

#### `serializer.writeHeader()` {#serializerwriteheader}

Scrive un header, che include la versione del formato di serializzazione.

#### `serializer.writeValue(value)` {#serializerwritevaluevalue}

- `value` [\<any\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)

Serializza un valore JavaScript e aggiunge la rappresentazione serializzata al buffer interno.

Questo genera un errore se `value` non può essere serializzato.

#### `serializer.releaseBuffer()` {#serializerreleasebuffer}

- Restituisce: [\<Buffer\>](/it/nodejs/api/buffer#class-buffer)

Restituisce il buffer interno memorizzato. Questo serializzatore non deve essere utilizzato una volta che il buffer è stato rilasciato. La chiamata a questo metodo risulta in un comportamento indefinito se una scrittura precedente non è andata a buon fine.

#### `serializer.transferArrayBuffer(id, arrayBuffer)` {#serializertransferarraybufferid-arraybuffer}

- `id` [\<integer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) Un intero senza segno a 32 bit.
- `arrayBuffer` [\<ArrayBuffer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) Un'istanza di `ArrayBuffer`.

Marca un `ArrayBuffer` come se il suo contenuto fosse stato trasferito fuori banda. Passa l' `ArrayBuffer` corrispondente nel contesto di deserializzazione a [`deserializer.transferArrayBuffer()`](/it/nodejs/api/v8#deserializertransferarraybufferid-arraybuffer).

#### `serializer.writeUint32(value)` {#serializerwriteuint32value}

- `value` [\<integer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

Scrive un intero senza segno raw a 32 bit. Da utilizzare all'interno di un [`serializer._writeHostObject()`](/it/nodejs/api/v8#serializer_writehostobjectobject) personalizzato.

#### `serializer.writeUint64(hi, lo)` {#serializerwriteuint64hi-lo}

- `hi` [\<integer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `lo` [\<integer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

Scrive un intero senza segno raw a 64 bit, suddiviso in parti alte e basse a 32 bit. Da utilizzare all'interno di un [`serializer._writeHostObject()`](/it/nodejs/api/v8#serializer_writehostobjectobject) personalizzato.


#### `serializer.writeDouble(value)` {#serializerwritedoublevalue}

- `value` [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

Scrive un valore `number` JS. Da utilizzare all'interno di un [`serializer._writeHostObject()`](/it/nodejs/api/v8#serializer_writehostobjectobject) personalizzato.

#### `serializer.writeRawBytes(buffer)` {#serializerwriterawbytesbuffer}

- `buffer` [\<Buffer\>](/it/nodejs/api/buffer#class-buffer) | [\<TypedArray\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [\<DataView\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)

Scrive byte raw nel buffer interno del serializzatore. Il deserializzatore richiederà un modo per calcolare la lunghezza del buffer. Da utilizzare all'interno di un [`serializer._writeHostObject()`](/it/nodejs/api/v8#serializer_writehostobjectobject) personalizzato.

#### `serializer._writeHostObject(object)` {#serializer_writehostobjectobject}

- `object` [\<Object\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

Questo metodo viene chiamato per scrivere una sorta di oggetto host, ovvero un oggetto creato da binding C++ nativi. Se non è possibile serializzare `object`, è necessario generare un'eccezione appropriata.

Questo metodo non è presente nella classe `Serializer` stessa, ma può essere fornito dalle sottoclassi.

#### `serializer._getDataCloneError(message)` {#serializer_getdatacloneerrormessage}

- `message` [\<string\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

Questo metodo viene chiamato per generare oggetti di errore che verranno generati quando un oggetto non può essere clonato.

Questo metodo è predefinito per il costruttore [`Error`](/it/nodejs/api/errors#class-error) e può essere sovrascritto sulle sottoclassi.

#### `serializer._getSharedArrayBufferId(sharedArrayBuffer)` {#serializer_getsharedarraybufferidsharedarraybuffer}

- `sharedArrayBuffer` [\<SharedArrayBuffer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer)

Questo metodo viene chiamato quando il serializzatore sta per serializzare un oggetto `SharedArrayBuffer`. Deve restituire un ID intero a 32 bit senza segno per l'oggetto, utilizzando lo stesso ID se questo `SharedArrayBuffer` è già stato serializzato. Durante la deserializzazione, questo ID verrà passato a [`deserializer.transferArrayBuffer()`](/it/nodejs/api/v8#deserializertransferarraybufferid-arraybuffer).

Se l'oggetto non può essere serializzato, è necessario generare un'eccezione.

Questo metodo non è presente nella classe `Serializer` stessa, ma può essere fornito dalle sottoclassi.


#### `serializer._setTreatArrayBufferViewsAsHostObjects(flag)` {#serializer_settreatarraybufferviewsashostobjectsflag}

- `flag` [\<boolean\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) **Predefinito:** `false`

Indica se trattare gli oggetti `TypedArray` e `DataView` come oggetti host, ovvero passarli a [`serializer._writeHostObject()`](/it/nodejs/api/v8#serializer_writehostobjectobject).

### Classe: `v8.Deserializer` {#class-v8deserializer}

**Aggiunto in: v8.0.0**

#### `new Deserializer(buffer)` {#new-deserializerbuffer}

- `buffer` [\<Buffer\>](/it/nodejs/api/buffer#class-buffer) | [\<TypedArray\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [\<DataView\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) Un buffer restituito da [`serializer.releaseBuffer()`](/it/nodejs/api/v8#serializerreleasebuffer).

Crea un nuovo oggetto `Deserializer`.

#### `deserializer.readHeader()` {#deserializerreadheader}

Legge e convalida un'intestazione (inclusa la versione del formato). Potrebbe, ad esempio, rifiutare un formato wire non valido o non supportato. In tal caso, viene generato un `Error`.

#### `deserializer.readValue()` {#deserializerreadvalue}

Deserializza un valore JavaScript dal buffer e lo restituisce.

#### `deserializer.transferArrayBuffer(id, arrayBuffer)` {#deserializertransferarraybufferid-arraybuffer}

- `id` [\<integer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) Un intero senza segno a 32 bit.
- `arrayBuffer` [\<ArrayBuffer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [\<SharedArrayBuffer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) Un'istanza di `ArrayBuffer`.

Contrassegna un `ArrayBuffer` come avente il suo contenuto trasferito fuori banda. Passare il corrispondente `ArrayBuffer` nel contesto di serializzazione a [`serializer.transferArrayBuffer()`](/it/nodejs/api/v8#serializertransferarraybufferid-arraybuffer) (o restituire l'`id` da [`serializer._getSharedArrayBufferId()`](/it/nodejs/api/v8#serializer_getsharedarraybufferidsharedarraybuffer) nel caso di `SharedArrayBuffer`).


#### `deserializer.getWireFormatVersion()` {#deserializergetwireformatversion}

- Restituisce: [\<integer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

Legge la versione del formato wire sottostante. Probabilmente utile soprattutto per il codice legacy che legge vecchie versioni del formato wire. Potrebbe non essere chiamato prima di `.readHeader()`.

#### `deserializer.readUint32()` {#deserializerreaduint32}

- Restituisce: [\<integer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

Legge un intero senza segno raw a 32 bit e lo restituisce. Da utilizzare all'interno di un [`deserializer._readHostObject()`](/it/nodejs/api/v8#deserializer_readhostobject) personalizzato.

#### `deserializer.readUint64()` {#deserializerreaduint64}

- Restituisce: [\<integer[]\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

Legge un intero senza segno raw a 64 bit e lo restituisce come un array `[hi, lo]` con due voci intere senza segno a 32 bit. Da utilizzare all'interno di un [`deserializer._readHostObject()`](/it/nodejs/api/v8#deserializer_readhostobject) personalizzato.

#### `deserializer.readDouble()` {#deserializerreaddouble}

- Restituisce: [\<number\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

Legge un valore `number` JS. Da utilizzare all'interno di un [`deserializer._readHostObject()`](/it/nodejs/api/v8#deserializer_readhostobject) personalizzato.

#### `deserializer.readRawBytes(length)` {#deserializerreadrawbyteslength}

- `length` [\<integer\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- Restituisce: [\<Buffer\>](/it/nodejs/api/buffer#class-buffer)

Legge byte raw dal buffer interno del deserializzatore. Il parametro `length` deve corrispondere alla lunghezza del buffer che è stato passato a [`serializer.writeRawBytes()`](/it/nodejs/api/v8#serializerwriterawbytesbuffer). Da utilizzare all'interno di un [`deserializer._readHostObject()`](/it/nodejs/api/v8#deserializer_readhostobject) personalizzato.

#### `deserializer._readHostObject()` {#deserializer_readhostobject}

Questo metodo viene chiamato per leggere un qualche tipo di oggetto host, ovvero un oggetto creato da binding C++ nativi. Se non è possibile deserializzare i dati, dovrebbe essere generata un'eccezione appropriata.

Questo metodo non è presente nella classe `Deserializer` stessa, ma può essere fornito dalle sottoclassi.


### Classe: `v8.DefaultSerializer` {#class-v8defaultserializer}

**Aggiunto in: v8.0.0**

Una sottoclasse di [`Serializer`](/it/nodejs/api/v8#class-v8serializer) che serializza gli oggetti `TypedArray` (in particolare [`Buffer`](/it/nodejs/api/buffer)) e `DataView` come oggetti host, e memorizza solo la parte dei loro `ArrayBuffer` sottostanti a cui si riferiscono.

### Classe: `v8.DefaultDeserializer` {#class-v8defaultdeserializer}

**Aggiunto in: v8.0.0**

Una sottoclasse di [`Deserializer`](/it/nodejs/api/v8#class-v8deserializer) corrispondente al formato scritto da [`DefaultSerializer`](/it/nodejs/api/v8#class-v8defaultserializer).

## Hook delle Promise {#promise-hooks}

L'interfaccia `promiseHooks` può essere utilizzata per tenere traccia degli eventi del ciclo di vita delle promise. Per tenere traccia di *tutta* l'attività asincrona, consulta [`async_hooks`](/it/nodejs/api/async_hooks) che internamente utilizza questo modulo per produrre eventi del ciclo di vita delle promise in aggiunta agli eventi per altre risorse asincrone. Per la gestione del contesto delle richieste, consulta [`AsyncLocalStorage`](/it/nodejs/api/async_context#class-asynclocalstorage).

```js [ESM]
import { promiseHooks } from 'node:v8';

// Ci sono quattro eventi del ciclo di vita prodotti dalle promise:

// L'evento `init` rappresenta la creazione di una promise. Questa potrebbe essere
// una creazione diretta come con `new Promise(...)` o una continuazione come
// `then()` o `catch()`. Succede anche ogni volta che una funzione async viene
// chiamata o fa un `await`. Se viene creata una promise di continuazione, il
// `parent` sarà la promise da cui è una continuazione.
function init(promise, parent) {
  console.log('una promise è stata creata', { promise, parent });
}

// L'evento `settled` si verifica quando una promise riceve una risoluzione o
// un valore di rifiuto. Questo può accadere in modo sincrono come quando si usa
// `Promise.resolve()` su input non promise.
function settled(promise) {
  console.log('una promise è stata risolta o rifiutata', { promise });
}

// L'evento `before` viene eseguito immediatamente prima che venga eseguito un gestore `then()` o `catch()`
// o una `await` riprenda l'esecuzione.
function before(promise) {
  console.log('una promise sta per chiamare un gestore then', { promise });
}

// L'evento `after` viene eseguito immediatamente dopo che viene eseguito un gestore `then()` o quando
// un `await` inizia dopo la ripresa da un altro.
function after(promise) {
  console.log('una promise ha finito di chiamare un gestore then', { promise });
}

// Gli hook del ciclo di vita possono essere avviati e arrestati individualmente
const stopWatchingInits = promiseHooks.onInit(init);
const stopWatchingSettleds = promiseHooks.onSettled(settled);
const stopWatchingBefores = promiseHooks.onBefore(before);
const stopWatchingAfters = promiseHooks.onAfter(after);

// Oppure possono essere avviati e arrestati in gruppi
const stopHookSet = promiseHooks.createHook({
  init,
  settled,
  before,
  after,
});

// Per interrompere un hook, chiama la funzione restituita alla sua creazione.
stopWatchingInits();
stopWatchingSettleds();
stopWatchingBefores();
stopWatchingAfters();
stopHookSet();
```

### `promiseHooks.onInit(init)` {#promisehooksoninitinit}

**Aggiunto in: v17.1.0, v16.14.0**

- `init` [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Il [`callback init`](/it/nodejs/api/v8#initpromise-parent) da chiamare quando viene creata una promise.
- Restituisce: [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Chiama per interrompere l'hook.

**L'hook <code>init</code> deve essere una funzione semplice. Fornire una funzione async genererà
un'eccezione poiché produrrebbe un loop infinito di microtask.**

::: code-group
```js [ESM]
import { promiseHooks } from 'node:v8';

const stop = promiseHooks.onInit((promise, parent) => {});
```

```js [CJS]
const { promiseHooks } = require('node:v8');

const stop = promiseHooks.onInit((promise, parent) => {});
```
:::

### `promiseHooks.onSettled(settled)` {#promisehooksonsettledsettled}

**Aggiunto in: v17.1.0, v16.14.0**

- `settled` [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Il [`callback settled`](/it/nodejs/api/v8#settledpromise) da chiamare quando una promise viene risolta o rifiutata.
- Restituisce: [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Chiama per interrompere l'hook.

**L'hook <code>settled</code> deve essere una funzione semplice. Fornire una funzione async genererà
un'eccezione poiché produrrebbe un loop infinito di microtask.**

::: code-group
```js [ESM]
import { promiseHooks } from 'node:v8';

const stop = promiseHooks.onSettled((promise) => {});
```

```js [CJS]
const { promiseHooks } = require('node:v8');

const stop = promiseHooks.onSettled((promise) => {});
```
:::

### `promiseHooks.onBefore(before)` {#promisehooksonbeforebefore}

**Aggiunto in: v17.1.0, v16.14.0**

- `before` [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Il [`callback before`](/it/nodejs/api/v8#beforepromise) da chiamare prima che venga eseguita una continuazione della promise.
- Restituisce: [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Chiama per interrompere l'hook.

**L'hook <code>before</code> deve essere una funzione semplice. Fornire una funzione async genererà
un'eccezione poiché produrrebbe un loop infinito di microtask.**

::: code-group
```js [ESM]
import { promiseHooks } from 'node:v8';

const stop = promiseHooks.onBefore((promise) => {});
```

```js [CJS]
const { promiseHooks } = require('node:v8');

const stop = promiseHooks.onBefore((promise) => {});
```
:::


### `promiseHooks.onAfter(after)` {#promisehooksonafterafter}

**Aggiunto in: v17.1.0, v16.14.0**

- `after` [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) La [`callback after`](/it/nodejs/api/v8#afterpromise) da chiamare dopo che un continuation di una promise viene eseguito.
- Restituisce: [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Chiama per fermare l'hook.

**L'hook <code>after</code> deve essere una funzione semplice. Fornire una funzione asincrona
genererà un'eccezione in quanto produrrebbe un ciclo infinito di microtask.**



::: code-group
```js [ESM]
import { promiseHooks } from 'node:v8';

const stop = promiseHooks.onAfter((promise) => {});
```

```js [CJS]
const { promiseHooks } = require('node:v8');

const stop = promiseHooks.onAfter((promise) => {});
```
:::

### `promiseHooks.createHook(callbacks)` {#promisehookscreatehookcallbacks}

**Aggiunto in: v17.1.0, v16.14.0**

- `callbacks` [\<Object\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) Le [Hook Callbacks](/it/nodejs/api/v8#hook-callbacks) da registrare
    - `init` [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) La [`callback init`](/it/nodejs/api/v8#initpromise-parent).
    - `before` [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) La [`callback before`](/it/nodejs/api/v8#beforepromise).
    - `after` [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) La [`callback after`](/it/nodejs/api/v8#afterpromise).
    - `settled` [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) La [`callback settled`](/it/nodejs/api/v8#settledpromise).
  
 
- Restituisce: [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Usato per disabilitare gli hook

**Le hook callbacks devono essere funzioni semplici. Fornire funzioni asincrone
genererà un'eccezione in quanto produrrebbe un ciclo infinito di microtask.**

Registra le funzioni da chiamare per diversi eventi del ciclo di vita di ogni promise.

Le callbacks `init()`/`before()`/`after()`/`settled()` vengono chiamate per i rispettivi eventi durante il ciclo di vita di una promise.

Tutte le callbacks sono opzionali. Ad esempio, se è necessario tracciare solo la creazione di una promise, allora deve essere passata solo la callback `init`. Le specifiche di tutte le funzioni che possono essere passate a `callbacks` si trovano nella sezione [Hook Callbacks](/it/nodejs/api/v8#hook-callbacks).



::: code-group
```js [ESM]
import { promiseHooks } from 'node:v8';

const stopAll = promiseHooks.createHook({
  init(promise, parent) {},
});
```

```js [CJS]
const { promiseHooks } = require('node:v8');

const stopAll = promiseHooks.createHook({
  init(promise, parent) {},
});
```
:::


### Hook callbacks {#hook-callbacks}

Gli eventi chiave nel ciclo di vita di una promise sono stati suddivisi in quattro aree: creazione di una promise, prima/dopo che viene chiamato un gestore di continuazione o intorno a un await, e quando la promise si risolve o viene rifiutata.

Sebbene questi hook siano simili a quelli di [`async_hooks`](/it/nodejs/api/async_hooks) mancano di un hook `destroy`. Altri tipi di risorse asincrone rappresentano in genere socket o descrittori di file che hanno un distinto stato "chiuso" per esprimere l'evento del ciclo di vita `destroy` mentre le promise rimangono utilizzabili fintanto che il codice può ancora raggiungerle. Il tracciamento della garbage collection viene utilizzato per adattare le promise al modello di evento `async_hooks`, tuttavia questo tracciamento è molto costoso e potrebbero non essere nemmeno mai sottoposte a garbage collection.

Poiché le promise sono risorse asincrone il cui ciclo di vita viene tracciato tramite il meccanismo degli hook delle promise, i callback `init()`, `before()`, `after()` e `settled()` *non devono* essere funzioni asincrone poiché creano più promise che produrrebbero un ciclo infinito.

Sebbene questa API venga utilizzata per alimentare gli eventi delle promise in [`async_hooks`](/it/nodejs/api/async_hooks), l'ordine tra i due non è definito. Entrambe le API sono multi-tenant e quindi potrebbero produrre eventi in qualsiasi ordine l'una rispetto all'altra.

#### `init(promise, parent)` {#initpromise-parent}

- `promise` [\<Promise\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) La promise che viene creata.
- `parent` [\<Promise\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) La promise continuata da, se applicabile.

Chiamato quando viene costruita una promise. Questo *non* significa che si verificheranno eventi `before`/`after` corrispondenti, solo che esiste la possibilità. Ciò accadrà se una promise viene creata senza mai ottenere una continuazione.

#### `before(promise)` {#beforepromise}

- `promise` [\<Promise\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)

Chiamato prima che venga eseguita una continuazione della promise. Questa può essere sotto forma di gestori `then()`, `catch()` o `finally()` o di una ripresa `await`.

Il callback `before` verrà chiamato da 0 a N volte. Il callback `before` verrà in genere chiamato 0 volte se non è mai stata effettuata alcuna continuazione per la promise. Il callback `before` può essere chiamato molte volte nel caso in cui siano state effettuate molte continuazioni dalla stessa promise.


#### `after(promise)` {#afterpromise}

- `promise` [\<Promise\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)

Chiamato immediatamente dopo l'esecuzione di una continuazione di una promise. Questo può avvenire dopo un gestore `then()`, `catch()` o `finally()` oppure prima di un `await` dopo un altro `await`.

#### `settled(promise)` {#settledpromise}

- `promise` [\<Promise\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)

Chiamato quando la promise riceve un valore di risoluzione o rifiuto. Ciò può verificarsi in modo sincrono nel caso di `Promise.resolve()` o `Promise.reject()`.

## API Snapshot di Avvio {#startup-snapshot-api}

**Aggiunto in: v18.6.0, v16.17.0**

::: warning [Stabile: 1 - Sperimentale]
[Stabile: 1](/it/nodejs/api/documentation#stability-index) [Stabilità: 1](/it/nodejs/api/documentation#stability-index) - Sperimentale
:::

L'interfaccia `v8.startupSnapshot` può essere utilizzata per aggiungere hook di serializzazione e deserializzazione per snapshot di avvio personalizzati.

```bash [BASH]
$ node --snapshot-blob snapshot.blob --build-snapshot entry.js
# Questo avvia un processo con lo snapshot {#this-launches-a-process-with-the-snapshot}
$ node --snapshot-blob snapshot.blob
```
Nell'esempio sopra, `entry.js` può utilizzare i metodi dell'interfaccia `v8.startupSnapshot` per specificare come salvare le informazioni per oggetti personalizzati nello snapshot durante la serializzazione e come le informazioni possono essere utilizzate per sincronizzare questi oggetti durante la deserializzazione dello snapshot. Ad esempio, se `entry.js` contiene il seguente script:

```js [CJS]
'use strict';

const fs = require('node:fs');
const zlib = require('node:zlib');
const path = require('node:path');
const assert = require('node:assert');

const v8 = require('node:v8');

class BookShelf {
  storage = new Map();

  // Lettura di una serie di file dalla directory e memorizzazione in storage.
  constructor(directory, books) {
    for (const book of books) {
      this.storage.set(book, fs.readFileSync(path.join(directory, book)));
    }
  }

  static compressAll(shelf) {
    for (const [ book, content ] of shelf.storage) {
      shelf.storage.set(book, zlib.gzipSync(content));
    }
  }

  static decompressAll(shelf) {
    for (const [ book, content ] of shelf.storage) {
      shelf.storage.set(book, zlib.gunzipSync(content));
    }
  }
}

// __dirname qui è dove viene posizionato lo script snapshot
// durante il tempo di costruzione dello snapshot.
const shelf = new BookShelf(__dirname, [
  'book1.en_US.txt',
  'book1.es_ES.txt',
  'book2.zh_CN.txt',
]);

assert(v8.startupSnapshot.isBuildingSnapshot());
// Durante la serializzazione dello snapshot, comprimi i libri per ridurre le dimensioni.
v8.startupSnapshot.addSerializeCallback(BookShelf.compressAll, shelf);
// Durante la deserializzazione dello snapshot, decomprimi i libri.
v8.startupSnapshot.addDeserializeCallback(BookShelf.decompressAll, shelf);
v8.startupSnapshot.setDeserializeMainFunction((shelf) => {
  // process.env e process.argv vengono aggiornati durante lo snapshot
  // deserializzazione.
  const lang = process.env.BOOK_LANG || 'en_US';
  const book = process.argv[1];
  const name = `${book}.${lang}.txt`;
  console.log(shelf.storage.get(name));
}, shelf);
```
Il binario risultante stamperà i dati deserializzati dallo snapshot durante l'avvio, utilizzando `process.env` e `process.argv` aggiornati del processo avviato:

```bash [BASH]
$ BOOK_LANG=es_ES node --snapshot-blob snapshot.blob book1
# Stampa il contenuto di book1.es_ES.txt deserializzato dallo snapshot. {#prints-content-of-book1es_estxt-deserialized-from-the-snapshot}
```
Attualmente, l'applicazione deserializzata da uno snapshot user-land non può essere nuovamente sottoposta a snapshot, quindi queste API sono disponibili solo per le applicazioni che non sono deserializzate da uno snapshot user-land.


### `v8.startupSnapshot.addSerializeCallback(callback[, data])` {#v8startupsnapshotaddserializecallbackcallback-data}

**Aggiunto in: v18.6.0, v16.17.0**

- `callback` [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Callback da invocare prima della serializzazione.
- `data` [\<any\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) Dati opzionali che verranno passati alla `callback` quando viene chiamata.

Aggiunge una callback che verrà chiamata quando l'istanza di Node.js sta per essere serializzata in uno snapshot ed uscire. Questo può essere utilizzato per rilasciare risorse che non dovrebbero o non possono essere serializzate o per convertire i dati dell'utente in una forma più adatta alla serializzazione.

Le callback vengono eseguite nell'ordine in cui vengono aggiunte.

### `v8.startupSnapshot.addDeserializeCallback(callback[, data])` {#v8startupsnapshotadddeserializecallbackcallback-data}

**Aggiunto in: v18.6.0, v16.17.0**

- `callback` [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Callback da invocare dopo che lo snapshot è stato deserializzato.
- `data` [\<any\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) Dati opzionali che verranno passati alla `callback` quando viene chiamata.

Aggiunge una callback che verrà chiamata quando l'istanza di Node.js viene deserializzata da uno snapshot. La `callback` ed i `data` (se forniti) verranno serializzati nello snapshot, possono essere utilizzati per reinizializzare lo stato dell'applicazione o per riacquisire le risorse di cui l'applicazione ha bisogno quando l'applicazione viene riavviata dallo snapshot.

Le callback vengono eseguite nell'ordine in cui vengono aggiunte.

### `v8.startupSnapshot.setDeserializeMainFunction(callback[, data])` {#v8startupsnapshotsetdeserializemainfunctioncallback-data}

**Aggiunto in: v18.6.0, v16.17.0**

- `callback` [\<Function\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Callback da invocare come punto di ingresso dopo che lo snapshot è stato deserializzato.
- `data` [\<any\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) Dati opzionali che verranno passati alla `callback` quando viene chiamata.

Questo imposta il punto di ingresso dell'applicazione Node.js quando viene deserializzata da uno snapshot. Questo può essere chiamato una sola volta nello script di creazione dello snapshot. Se chiamato, l'applicazione deserializzata non ha più bisogno di uno script di punto di ingresso aggiuntivo per avviarsi e invocherà semplicemente la callback insieme ai dati deserializzati (se forniti), altrimenti è necessario fornire comunque uno script di punto di ingresso all'applicazione deserializzata.


### `v8.startupSnapshot.isBuildingSnapshot()` {#v8startupsnapshotisbuildingsnapshot}

**Aggiunto in: v18.6.0, v16.17.0**

- Restituisce: [\<boolean\>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

Restituisce true se l'istanza di Node.js viene eseguita per creare uno snapshot.

## Classe: `v8.GCProfiler` {#class-v8gcprofiler}

**Aggiunto in: v19.6.0, v18.15.0**

Questa API raccoglie i dati GC nel thread corrente.

### `new v8.GCProfiler()` {#new-v8gcprofiler}

**Aggiunto in: v19.6.0, v18.15.0**

Crea una nuova istanza della classe `v8.GCProfiler`.

### `profiler.start()` {#profilerstart}

**Aggiunto in: v19.6.0, v18.15.0**

Inizia a raccogliere i dati GC.

### `profiler.stop()` {#profilerstop}

**Aggiunto in: v19.6.0, v18.15.0**

Interrompe la raccolta dei dati GC e restituisce un oggetto. Il contenuto dell'oggetto è il seguente.

```json [JSON]
{
  "version": 1,
  "startTime": 1674059033862,
  "statistics": [
    {
      "gcType": "Scavenge",
      "beforeGC": {
        "heapStatistics": {
          "totalHeapSize": 5005312,
          "totalHeapSizeExecutable": 524288,
          "totalPhysicalSize": 5226496,
          "totalAvailableSize": 4341325216,
          "totalGlobalHandlesSize": 8192,
          "usedGlobalHandlesSize": 2112,
          "usedHeapSize": 4883840,
          "heapSizeLimit": 4345298944,
          "mallocedMemory": 254128,
          "externalMemory": 225138,
          "peakMallocedMemory": 181760
        },
        "heapSpaceStatistics": [
          {
            "spaceName": "read_only_space",
            "spaceSize": 0,
            "spaceUsedSize": 0,
            "spaceAvailableSize": 0,
            "physicalSpaceSize": 0
          }
        ]
      },
      "cost": 1574.14,
      "afterGC": {
        "heapStatistics": {
          "totalHeapSize": 6053888,
          "totalHeapSizeExecutable": 524288,
          "totalPhysicalSize": 5500928,
          "totalAvailableSize": 4341101384,
          "totalGlobalHandlesSize": 8192,
          "usedGlobalHandlesSize": 2112,
          "usedHeapSize": 4059096,
          "heapSizeLimit": 4345298944,
          "mallocedMemory": 254128,
          "externalMemory": 225138,
          "peakMallocedMemory": 181760
        },
        "heapSpaceStatistics": [
          {
            "spaceName": "read_only_space",
            "spaceSize": 0,
            "spaceUsedSize": 0,
            "spaceAvailableSize": 0,
            "physicalSpaceSize": 0
          }
        ]
      }
    }
  ],
  "endTime": 1674059036865
}
```
Ecco un esempio.

```js [ESM]
const { GCProfiler } = require('node:v8');
const profiler = new GCProfiler();
profiler.start();
setTimeout(() => {
  console.log(profiler.stop());
}, 1000);
```
